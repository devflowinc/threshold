{"files":[{"path":["/","home","vidyootsenthil","TheValut-nameTBD","bin","cli","src","errors.rs"],"content":"use derive_more::Display;\n\n#[derive(Debug, Display)]\npub enum KeygenError {\n    #[display(\"Password mismatch\")]\n    PasswordMismatch,\n\n    #[display(\"Failed to create directory.\")]\n    DirectoryCreation(String),\n\n    #[display(\"Io error: {}\", _0)]\n    Io(std::io::Error),\n\n    #[display(\"Failed to encode key.\")]\n    KeyEncoding(String),\n\n    #[display(\"Failed to encrypt key.\")]\n    Encryption(String),\n\n    #[display(\"Failed to create directory.\")]\n    KeyFileNotFound(String),\n}\n\n#[derive(Debug)]\n#[allow(dead_code, clippy::enum_variant_names, clippy::large_enum_variant)]\npub enum CliError {\n    KeygenError(KeygenError),\n    RpcError(tonic::Status),\n    NodeError,\n}\n\nimpl From<KeygenError> for CliError {\n    fn from(error: KeygenError) -> Self {\n        CliError::KeygenError(error)\n    }\n}\n","traces":[{"line":33,"address":[5642608],"length":1,"stats":{"Line":0}},{"line":34,"address":[5642611],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":2},{"path":["/","home","vidyootsenthil","TheValut-nameTBD","bin","cli","src","main.rs"],"content":"mod errors;\nmod rpc_client;\n\nuse aes_gcm::{\n    aead::{Aead, KeyInit},\n    Aes256Gcm, Key, Nonce,\n};\nuse argon2::{\n    password_hash::{\n        rand_core::{OsRng, RngCore},\n        SaltString,\n    },\n    Argon2,\n};\nuse base64::{engine::general_purpose::STANDARD as BASE64, Engine as _};\nuse clap::{Parser, Subcommand};\nuse directories::ProjectDirs;\nuse libp2p::identity::Keypair;\nuse rpc_client::{\n    rpc_create_deposit_intent, rpc_send_direct_message, rpc_spend, rpc_start_signing,\n};\nuse std::{fs, path::PathBuf};\n\nuse node::{start_node::start_node, Config, EncryptionParams, KeyData, PeerData};\n\nuse crate::errors::{CliError, KeygenError};\n\nfn get_key_file_path() -> Result<PathBuf, KeygenError> {\n    let proj_dirs = ProjectDirs::from(\"\", \"\", \"TheVault\").ok_or_else(|| {\n        KeygenError::DirectoryCreation(\"Failed to determine project directory\".into())\n    })?;\n\n    let config_dir = proj_dirs.config_dir();\n    fs::create_dir_all(config_dir).map_err(|e| KeygenError::DirectoryCreation(e.to_string()))?;\n\n    Ok(config_dir.join(\"config.json\"))\n}\n\nfn get_log_file_path() -> Result<PathBuf, KeygenError> {\n    let proj_dirs = ProjectDirs::from(\"\", \"\", \"TheVault\").ok_or_else(|| {\n        KeygenError::DirectoryCreation(\"Failed to determine project directory\".into())\n    })?;\n\n    let log_dir = proj_dirs.config_dir();\n    let path = log_dir.join(\"node.log\");\n    Ok(path)\n}\n\nfn generate_key(password: &str, salt: &SaltString) -> Result<Vec<u8>, KeygenError> {\n    let argon2 = Argon2::default();\n    let password_bytes = password.as_bytes();\n    let mut key = vec![0u8; 32];\n\n    argon2\n        .hash_password_into(password_bytes, salt.as_str().as_bytes(), &mut key)\n        .map_err(|e| KeygenError::Encryption(e.to_string()))?;\n    Ok(key)\n}\n\nfn encrypt_private_key(\n    keypair: &Keypair,\n    password: &str,\n) -> Result<(String, EncryptionParams), KeygenError> {\n    let salt = SaltString::generate(&mut OsRng);\n    let key = generate_key(password, &salt)?;\n\n    let mut nonce_bytes = [0u8; 12];\n    OsRng.fill_bytes(&mut nonce_bytes);\n    let nonce = Nonce::from_slice(&nonce_bytes);\n\n    let private_key_bytes = keypair\n        .to_protobuf_encoding()\n        .map_err(|e| KeygenError::KeyEncoding(e.to_string()))?;\n\n    let cipher = Aes256Gcm::new(Key::<Aes256Gcm>::from_slice(&key));\n\n    let ciphertext = cipher\n        .encrypt(nonce, private_key_bytes.as_ref())\n        .map_err(|e| KeygenError::Encryption(e.to_string()))?;\n\n    let params = EncryptionParams {\n        kdf: \"argon2id\".to_string(),\n        salt_b64: salt.to_string(),\n        iv_b64: BASE64.encode(nonce_bytes),\n    };\n\n    Ok((BASE64.encode(ciphertext), params))\n}\n\nfn get_password() -> Result<String, KeygenError> {\n    let password = rpassword::prompt_password(\"Enter password: \").map_err(KeygenError::Io)?;\n\n    let confirm = rpassword::prompt_password(\"Confirm password: \").map_err(KeygenError::Io)?;\n\n    if password != confirm {\n        return Err(KeygenError::PasswordMismatch);\n    }\n\n    Ok(password)\n}\n\n#[derive(Parser)]\n#[command(name = \"keygen\")]\n#[command(about = \"Generate public and private key pairs for the Vault.\")]\n#[command(version = \"0.0.1\")]\nstruct Cli {\n    #[command(subcommand)]\n    command: Commands,\n}\n\n#[derive(Subcommand)]\nenum Commands {\n    /// Generate a new keypair and save it to a file set by the --output flag\n    Setup {\n        #[arg(short, long)]\n        output: Option<String>,\n        #[arg(short, long)]\n        allowed_peers: Option<Vec<String>>,\n    },\n    /// Run the node and connect to the network\n    Run {\n        #[arg(short, long)]\n        config: Option<String>,\n        #[arg(short, long)]\n        grpc_port: Option<u16>,\n        #[arg(short, long)]\n        log_file: Option<String>,\n        #[arg(short = 'n', long)]\n        max_signers: Option<u16>,\n        #[arg(short = 't', long)]\n        min_signers: Option<u16>,\n    },\n    Spend {\n        amount: u64,\n        #[arg(short, long)]\n        endpoint: Option<String>,\n    },\n    StartSigning {\n        hex_message: String,\n        #[arg(short, long)]\n        endpoint: Option<String>,\n    },\n    SendDirectMessage {\n        peer_id: String,\n        message: String,\n        #[arg(short, long)]\n        endpoint: Option<String>,\n    },\n    Deposit {\n        peer_id: String,\n        amount: u64,\n        #[arg(short, long)]\n        endpoint: Option<String>,\n    },\n}\n\n#[tokio::main]\n#[allow(clippy::result_large_err)]\nasync fn main() -> Result<(), CliError> {\n    let cli = Cli::parse();\n\n    match cli.command {\n        Commands::Setup {\n            output,\n            allowed_peers,\n        } => {\n            setup_config(output, allowed_peers).map_err(|e| {\n                println!(\"Keygen Error: {}\", e);\n                CliError::KeygenError(e)\n            })?;\n        }\n        Commands::Run {\n            config,\n            grpc_port,\n            log_file,\n            max_signers,\n            min_signers,\n        } => {\n            start_node_cli(config, grpc_port, log_file, max_signers, min_signers)\n                .await\n                .map_err(|_| CliError::NodeError)?;\n        }\n        Commands::Spend { amount, endpoint } => {\n            rpc_spend(endpoint, amount)\n                .await\n                .map_err(CliError::RpcError)?;\n        }\n        Commands::StartSigning {\n            hex_message,\n            endpoint,\n        } => {\n            rpc_start_signing(endpoint, hex_message)\n                .await\n                .map_err(CliError::RpcError)?;\n        }\n        Commands::SendDirectMessage {\n            peer_id,\n            message,\n            endpoint,\n        } => {\n            rpc_send_direct_message(endpoint, peer_id, message)\n                .await\n                .map_err(CliError::RpcError)?;\n        }\n        Commands::Deposit {\n            peer_id,\n            amount,\n            endpoint,\n        } => {\n            rpc_create_deposit_intent(endpoint, peer_id, amount)\n                .await\n                .map_err(CliError::RpcError)?;\n        }\n    };\n\n    Ok(())\n}\n\nfn setup_config(\n    output: Option<String>,\n    allowed_peers: Option<Vec<String>>,\n) -> Result<(), KeygenError> {\n    let keypair = Keypair::generate_ed25519();\n    let public_key_b58 = keypair.public().to_peer_id().to_base58();\n\n    let user_password = get_password()?;\n\n    let (encrypted_private_key, encryption_params) = encrypt_private_key(&keypair, &user_password)?;\n\n    let key_data = KeyData {\n        public_key_b58: public_key_b58.clone(),\n        encrypted_private_key_b64: encrypted_private_key,\n        encryption_params,\n    };\n\n    let allowed_peer_ids = allowed_peers.unwrap_or_default();\n\n    let allowed_peer_data = allowed_peer_ids\n        .iter()\n        .map(|peer_id| PeerData {\n            public_key: peer_id.to_string(),\n            name: peer_id.to_string(),\n        })\n        .collect();\n\n    let config = Config {\n        allowed_peers: allowed_peer_data,\n        key_data,\n        dkg_keys: None,\n        log_file_path: Some(get_log_file_path()?),\n    };\n\n    let json = serde_json::to_string_pretty(&config)\n        .map_err(|e| KeygenError::Io(std::io::Error::other(e)))?;\n\n    let key_file_path = if let Some(output) = output {\n        let path = PathBuf::from(output);\n        if path.is_dir() {\n            return Err(KeygenError::KeyFileNotFound(format!(\n                \"The path {} is a directory\",\n                path.display()\n            )));\n        } else {\n            path\n        }\n    } else {\n        get_key_file_path()?\n    };\n\n    fs::write(&key_file_path, json).map_err(KeygenError::Io)?;\n\n    println!(\n        \"Key data has been saved to {} with the peer id {}. To modify the allowed peers, edit the config file.\",\n        key_file_path.display(),\n        public_key_b58\n    );\n\n    Ok(())\n}\n\nasync fn start_node_cli(\n    config_filepath: Option<String>,\n    grpc_port: Option<u16>,\n    log_file: Option<String>,\n    max_signers: Option<u16>,\n    min_signers: Option<u16>,\n) -> Result<(), Box<dyn std::error::Error>> {\n    start_node(\n        max_signers,\n        min_signers,\n        config_filepath,\n        grpc_port,\n        log_file.map(PathBuf::from),\n    )\n    .await?;\n    Ok(())\n}\n\n#[cfg(test)]\nmod tests;\n","traces":[{"line":28,"address":[5335393,5334704,5335399],"length":1,"stats":{"Line":0}},{"line":29,"address":[5334721,5334914],"length":1,"stats":{"Line":0}},{"line":30,"address":[5605406],"length":1,"stats":{"Line":0}},{"line":33,"address":[5335016,5335088],"length":1,"stats":{"Line":0}},{"line":34,"address":[5335120],"length":1,"stats":{"Line":0}},{"line":36,"address":[5335276],"length":1,"stats":{"Line":0}},{"line":39,"address":[5335424,5335928,5335934],"length":1,"stats":{"Line":0}},{"line":40,"address":[5605648],"length":1,"stats":{"Line":0}},{"line":41,"address":[5605662],"length":1,"stats":{"Line":0}},{"line":44,"address":[5335736,5335808],"length":1,"stats":{"Line":0}},{"line":45,"address":[5335824],"length":1,"stats":{"Line":0}},{"line":46,"address":[5335861],"length":1,"stats":{"Line":0}},{"line":49,"address":[5336577,5335952,5336571],"length":1,"stats":{"Line":1}},{"line":50,"address":[5336008],"length":1,"stats":{"Line":1}},{"line":51,"address":[5336035],"length":1,"stats":{"Line":1}},{"line":52,"address":[5336072],"length":1,"stats":{"Line":1}},{"line":54,"address":[5336285,5336424],"length":1,"stats":{"Line":1}},{"line":55,"address":[5336108,5336189],"length":1,"stats":{"Line":2}},{"line":56,"address":[5336392],"length":1,"stats":{"Line":0}},{"line":57,"address":[5336451],"length":1,"stats":{"Line":1}},{"line":60,"address":[5338511,5336592,5338603],"length":1,"stats":{"Line":1}},{"line":64,"address":[5336648],"length":1,"stats":{"Line":1}},{"line":65,"address":[5336684],"length":1,"stats":{"Line":1}},{"line":67,"address":[5336909],"length":1,"stats":{"Line":1}},{"line":68,"address":[5336932],"length":1,"stats":{"Line":1}},{"line":69,"address":[5337008],"length":1,"stats":{"Line":1}},{"line":71,"address":[5338601,5337185,5337055],"length":1,"stats":{"Line":1}},{"line":73,"address":[5337153],"length":1,"stats":{"Line":0}},{"line":75,"address":[5337357,5337274],"length":1,"stats":{"Line":2}},{"line":77,"address":[5337621,5337483],"length":1,"stats":{"Line":1}},{"line":78,"address":[5337397],"length":1,"stats":{"Line":1}},{"line":79,"address":[5337589],"length":1,"stats":{"Line":0}},{"line":82,"address":[5337718],"length":1,"stats":{"Line":1}},{"line":83,"address":[5337803],"length":1,"stats":{"Line":1}},{"line":84,"address":[5337851],"length":1,"stats":{"Line":1}},{"line":87,"address":[5338175,5338052],"length":1,"stats":{"Line":2}},{"line":90,"address":[5339405,5339423,5338624],"length":1,"stats":{"Line":0}},{"line":91,"address":[5338641],"length":1,"stats":{"Line":0}},{"line":93,"address":[5338957,5339411,5338869],"length":1,"stats":{"Line":0}},{"line":95,"address":[5339141,5339217],"length":1,"stats":{"Line":0}},{"line":96,"address":[5339317],"length":1,"stats":{"Line":0}},{"line":99,"address":[5339228],"length":1,"stats":{"Line":0}},{"line":159,"address":[5390944,5391363,5391369],"length":1,"stats":{"Line":0}},{"line":160,"address":[5608075],"length":1,"stats":{"Line":0}},{"line":162,"address":[5608267],"length":1,"stats":{"Line":0}},{"line":163,"address":[5608371],"length":1,"stats":{"Line":0}},{"line":167,"address":[5611952,5609111,5609209,5609247,5612190,5608427],"length":1,"stats":{"Line":0}},{"line":168,"address":[5611979,5612023],"length":1,"stats":{"Line":0}},{"line":169,"address":[5612092],"length":1,"stats":{"Line":0}},{"line":172,"address":[5608588,5608577,5608597],"length":1,"stats":{"Line":0}},{"line":179,"address":[5608618,5608592,5610062,5608483,5609326,5609858,5608477,5608546,5608554,5608585,5609937,5610035],"length":1,"stats":{"Line":0}},{"line":180,"address":[5322881],"length":1,"stats":{"Line":0}},{"line":181,"address":[5610028,5612246,5612224],"length":1,"stats":{"Line":0}},{"line":183,"address":[5608664],"length":1,"stats":{"Line":0}},{"line":184,"address":[5610554,5610281,5608732,5609406,5610244,5610379],"length":1,"stats":{"Line":0}},{"line":185,"address":[5322897],"length":1,"stats":{"Line":0}},{"line":186,"address":[5323162,5323134],"length":1,"stats":{"Line":0}},{"line":188,"address":[5608774],"length":1,"stats":{"Line":0}},{"line":192,"address":[5611005,5610730,5608830,5609486,5610865,5610767],"length":1,"stats":{"Line":0}},{"line":193,"address":[5322916],"length":1,"stats":{"Line":0}},{"line":194,"address":[5323177,5323205],"length":1,"stats":{"Line":0}},{"line":196,"address":[5608840],"length":1,"stats":{"Line":0}},{"line":201,"address":[5609566,5611181,5608967,5611218,5611316,5611424],"length":1,"stats":{"Line":0}},{"line":202,"address":[5322935],"length":1,"stats":{"Line":0}},{"line":203,"address":[5323251,5323220],"length":1,"stats":{"Line":0}},{"line":205,"address":[5609029],"length":1,"stats":{"Line":0}},{"line":210,"address":[5611637,5609085,5611735,5611600,5609646,5611942],"length":1,"stats":{"Line":0}},{"line":211,"address":[5322954],"length":1,"stats":{"Line":0}},{"line":212,"address":[5323297,5323266],"length":1,"stats":{"Line":0}},{"line":216,"address":[5391238,5391057,5390997],"length":1,"stats":{"Line":0}},{"line":219,"address":[5342825,5339456,5344390],"length":1,"stats":{"Line":0}},{"line":223,"address":[5339495],"length":1,"stats":{"Line":0}},{"line":224,"address":[5339619,5339687],"length":1,"stats":{"Line":0}},{"line":226,"address":[5339749,5339816,5344179],"length":1,"stats":{"Line":0}},{"line":228,"address":[5339988,5344155,5340087],"length":1,"stats":{"Line":0}},{"line":231,"address":[5340443],"length":1,"stats":{"Line":0}},{"line":236,"address":[5340799],"length":1,"stats":{"Line":0}},{"line":238,"address":[5340894,5340986],"length":1,"stats":{"Line":0}},{"line":240,"address":[5606064,5606245,5606181,5606239],"length":1,"stats":{"Line":0}},{"line":241,"address":[5606101],"length":1,"stats":{"Line":0}},{"line":242,"address":[5606135],"length":1,"stats":{"Line":0}},{"line":250,"address":[5341326,5341259],"length":1,"stats":{"Line":0}},{"line":253,"address":[5341810,5343783,5341897,5341995],"length":1,"stats":{"Line":0}},{"line":254,"address":[5341963],"length":1,"stats":{"Line":0}},{"line":256,"address":[5342132,5342434,5343043],"length":1,"stats":{"Line":0}},{"line":257,"address":[5342219],"length":1,"stats":{"Line":0}},{"line":258,"address":[5342293,5342361],"length":1,"stats":{"Line":0}},{"line":259,"address":[5342585],"length":1,"stats":{"Line":0}},{"line":261,"address":[5342444,5342542],"length":1,"stats":{"Line":0}},{"line":264,"address":[5342386],"length":1,"stats":{"Line":0}},{"line":267,"address":[5342847,5342234,5343710],"length":1,"stats":{"Line":0}},{"line":270,"address":[5343105,5342461],"length":1,"stats":{"Line":0}},{"line":272,"address":[5343306],"length":1,"stats":{"Line":0}},{"line":278,"address":[5343453],"length":1,"stats":{"Line":0}},{"line":281,"address":[5344432],"length":1,"stats":{"Line":0}},{"line":291,"address":[5606620],"length":1,"stats":{"Line":0}},{"line":293,"address":[5606673],"length":1,"stats":{"Line":0}},{"line":295,"address":[5323732],"length":1,"stats":{"Line":0}},{"line":296,"address":[5607381],"length":1,"stats":{"Line":0}}],"covered":21,"coverable":99},{"path":["/","home","vidyootsenthil","TheValut-nameTBD","bin","cli","src","rpc_client.rs"],"content":"use node::grpc::grpc_handler::node_proto::{\n    self, node_control_client::NodeControlClient, CreateDepositIntentResponse,\n    SendDirectMessageResponse, SpendFundsResponse, StartSigningResponse,\n};\nuse tonic::Status;\n\npub async fn rpc_spend(\n    endpoint: Option<String>,\n    amount: u64,\n) -> Result<SpendFundsResponse, Status> {\n    println!(\"Spending {} satoshis\", amount);\n\n    let mut client =\n        NodeControlClient::connect(endpoint.unwrap_or(\"http://[::1]:50051\".to_string()))\n            .await\n            .expect(\"Failed to connect\");\n\n    let spendfunds_response = client\n        .spend_funds(tonic::Request::new(node_proto::SpendFundsRequest {\n            amount_satoshis: amount,\n        }))\n        .await?;\n\n    println!(\"Spent {:?} satoshis\", spendfunds_response);\n\n    Ok(spendfunds_response.into_inner())\n}\n\npub async fn rpc_start_signing(\n    endpoint: Option<String>,\n    hex_message: String,\n) -> Result<StartSigningResponse, Status> {\n    println!(\"Starting signing session for message: {}\", hex_message);\n\n    let mut client =\n        NodeControlClient::connect(endpoint.unwrap_or(\"http://[::1]:50051\".to_string()))\n            .await\n            .expect(\"Failed to connect\");\n\n    let start_signing_response = client\n        .start_signing(tonic::Request::new(node_proto::StartSigningRequest {\n            hex_message,\n        }))\n        .await?;\n\n    Ok(start_signing_response.into_inner())\n}\n\npub async fn rpc_send_direct_message(\n    endpoint: Option<String>,\n    peer_id: String,\n    message: String,\n) -> Result<SendDirectMessageResponse, Status> {\n    println!(\"Sending direct message to {}: {}\", peer_id, message);\n\n    let mut client =\n        NodeControlClient::connect(endpoint.unwrap_or(\"http://[::1]:50051\".to_string()))\n            .await\n            .expect(\"Failed to connect\");\n\n    let send_direct_message_response = client\n        .send_direct_message(tonic::Request::new(node_proto::SendDirectMessageRequest {\n            peer_id,\n            message,\n        }))\n        .await?;\n\n    Ok(send_direct_message_response.into_inner())\n}\n\npub async fn rpc_create_deposit_intent(\n    endpoint: Option<String>,\n    peer_id: String,\n    amount: u64,\n) -> Result<CreateDepositIntentResponse, Status> {\n    println!(\"Creating deposit intent for user {}: {}\", peer_id, amount);\n\n    let mut client =\n        NodeControlClient::connect(endpoint.unwrap_or(\"http://[::1]:50051\".to_string()))\n            .await\n            .expect(\"Failed to connect\");\n\n    let create_deposit_intent_response = client\n        .create_deposit_intent(tonic::Request::new(\n            node_proto::CreateDepositIntentRequest {\n                user_id: peer_id,\n                amount_satoshis: amount,\n            },\n        ))\n        .await?;\n\n    Ok(create_deposit_intent_response.into_inner())\n}\n","traces":[{"line":7,"address":[5298400],"length":1,"stats":{"Line":0}},{"line":11,"address":[5615963,5616091],"length":1,"stats":{"Line":0}},{"line":13,"address":[5616646,5616237,5616423,5616160,5616375,5616664],"length":1,"stats":{"Line":0}},{"line":15,"address":[5324105],"length":1,"stats":{"Line":0}},{"line":18,"address":[5616707,5617096,5617059,5616843,5617171,5616813],"length":1,"stats":{"Line":0}},{"line":19,"address":[5616736],"length":1,"stats":{"Line":0}},{"line":20,"address":[5616724],"length":1,"stats":{"Line":0}},{"line":22,"address":[5616873,5616897,5617164,5616036,5616836,5617061],"length":1,"stats":{"Line":0}},{"line":24,"address":[5617292,5617340],"length":1,"stats":{"Line":0}},{"line":26,"address":[5617409],"length":1,"stats":{"Line":0}},{"line":29,"address":[5298448],"length":1,"stats":{"Line":0}},{"line":33,"address":[5617941,5618069],"length":1,"stats":{"Line":0}},{"line":35,"address":[5618215,5618642,5618353,5618401,5618138,5618624],"length":1,"stats":{"Line":0}},{"line":37,"address":[5325453],"length":1,"stats":{"Line":0}},{"line":40,"address":[5619218,5618860,5619143,5619106,5618890,5618685],"length":1,"stats":{"Line":0}},{"line":41,"address":[5618735],"length":1,"stats":{"Line":0}},{"line":42,"address":[5618702],"length":1,"stats":{"Line":0}},{"line":44,"address":[5325468],"length":1,"stats":{"Line":0}},{"line":46,"address":[5619423,5619339],"length":1,"stats":{"Line":0}},{"line":49,"address":[5298512],"length":1,"stats":{"Line":0}},{"line":54,"address":[5619980,5620108],"length":1,"stats":{"Line":0}},{"line":56,"address":[5620710,5620436,5620487,5620221,5620728,5620298],"length":1,"stats":{"Line":0}},{"line":58,"address":[5326045],"length":1,"stats":{"Line":0}},{"line":61,"address":[5621374,5621299,5621016,5620771,5621046,5621262],"length":1,"stats":{"Line":0}},{"line":62,"address":[5620859],"length":1,"stats":{"Line":0}},{"line":63,"address":[5620788],"length":1,"stats":{"Line":0}},{"line":64,"address":[5620821],"length":1,"stats":{"Line":0}},{"line":66,"address":[5326063],"length":1,"stats":{"Line":0}},{"line":68,"address":[5621495,5621579],"length":1,"stats":{"Line":0}},{"line":71,"address":[5298592],"length":1,"stats":{"Line":0}},{"line":76,"address":[5622162,5622290],"length":1,"stats":{"Line":0}},{"line":78,"address":[5622666,5622907,5622480,5622889,5622403,5622618],"length":1,"stats":{"Line":0}},{"line":80,"address":[5326589],"length":1,"stats":{"Line":0}},{"line":83,"address":[5623142,5623500,5622950,5623172,5623388,5623425],"length":1,"stats":{"Line":0}},{"line":84,"address":[5623065],"length":1,"stats":{"Line":0}},{"line":85,"address":[5623009],"length":1,"stats":{"Line":0}},{"line":86,"address":[5622967],"length":1,"stats":{"Line":0}},{"line":87,"address":[5623000],"length":1,"stats":{"Line":0}},{"line":90,"address":[5326604],"length":1,"stats":{"Line":0}},{"line":92,"address":[5623621,5623705],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":40},{"path":["/","home","vidyootsenthil","TheValut-nameTBD","bin","cli","src","tests.rs"],"content":"use super::*;\nuse assert_matches::assert_matches;\nuse std::fs;\nuse tempfile::tempdir;\n\n// Helper function to decrypt private key\nfn decrypt_private_key(\n    encrypted_key: &str,\n    password: &str,\n    params: &EncryptionParams,\n) -> Result<Vec<u8>, KeygenError> {\n    let salt = SaltString::from_b64(&params.salt_b64)\n        .map_err(|e| KeygenError::Encryption(e.to_string()))?;\n    let key = generate_key(password, &salt)?;\n\n    let nonce_bytes = BASE64\n        .decode(&params.iv_b64)\n        .map_err(|e| KeygenError::Encryption(e.to_string()))?;\n    let nonce = Nonce::from_slice(&nonce_bytes);\n\n    let cipher = Aes256Gcm::new(Key::<Aes256Gcm>::from_slice(&key));\n\n    let ciphertext = BASE64\n        .decode(encrypted_key)\n        .map_err(|e| KeygenError::Encryption(e.to_string()))?;\n\n    cipher\n        .decrypt(nonce, ciphertext.as_ref())\n        .map_err(|e| KeygenError::Encryption(e.to_string()))\n}\n\n// Test helper to generate keypair without password prompt\nfn generate_test_keypair(output_path: Option<PathBuf>, password: &str) -> Result<(), KeygenError> {\n    let keypair = Keypair::generate_ed25519();\n    let public_key = keypair.public().encode_protobuf();\n    let public_key_b58 = bs58::encode(public_key).into_string();\n\n    let (encrypted_private_key, encryption_params) = encrypt_private_key(&keypair, password)?;\n\n    let key_data = KeyData {\n        public_key_b58: public_key_b58.clone(),\n        encrypted_private_key_b64: encrypted_private_key,\n        encryption_params,\n    };\n\n    let json = serde_json::to_string_pretty(&key_data)\n        .map_err(|e| KeygenError::Io(std::io::Error::other(e)))?;\n\n    let key_file_path = if let Some(path) = output_path {\n        if path.is_dir() {\n            path.join(\"config.json\")\n        } else {\n            path\n        }\n    } else {\n        get_key_file_path()?\n    };\n\n    fs::write(&key_file_path, json).map_err(KeygenError::Io)?;\n    Ok(())\n}\n\n#[test]\nfn test_key_generation_and_encryption() {\n    let keypair = Keypair::generate_ed25519();\n    let password = \"test_password123\";\n\n    let (encrypted_key, params) = encrypt_private_key(&keypair, password).unwrap();\n\n    assert_eq!(params.kdf, \"argon2id\");\n    assert!(!params.salt_b64.is_empty());\n    assert!(!params.iv_b64.is_empty());\n    assert!(!encrypted_key.is_empty());\n\n    // Verify we can decrypt with correct password\n    let decrypted = decrypt_private_key(&encrypted_key, password, &params).unwrap();\n    let original = keypair.to_protobuf_encoding().unwrap();\n    assert_eq!(decrypted, original);\n}\n\n#[test]\nfn test_decryption_with_wrong_password() {\n    let keypair = Keypair::generate_ed25519();\n    let password = \"correct_password\";\n    let wrong_password = \"wrong_password\";\n\n    let (encrypted_key, params) = encrypt_private_key(&keypair, password).unwrap();\n\n    // Attempt decryption with wrong password should fail\n    let result = decrypt_private_key(&encrypted_key, wrong_password, &params);\n    assert!(result.is_err());\n}\n\n#[test]\nfn test_key_file_operations() {\n    let temp_dir = tempdir().unwrap();\n    let output_path = temp_dir.path().join(\"test_config.json\");\n\n    // Test key generation and file writing\n    let result = generate_test_keypair(Some(output_path.clone()), \"test_password123\");\n    assert!(result.is_ok());\n\n    // Verify file exists and contains valid JSON\n    let contents = fs::read_to_string(&output_path).unwrap();\n    let key_data: KeyData = serde_json::from_str(&contents).unwrap();\n\n    assert!(!key_data.public_key_b58.is_empty());\n    assert!(!key_data.encrypted_private_key_b64.is_empty());\n    assert_eq!(key_data.encryption_params.kdf, \"argon2id\");\n}\n\n#[test]\nfn test_invalid_directory() {\n    // Test with a non-existent directory\n    let result = generate_test_keypair(\n        Some(PathBuf::from(\"/nonexistent/path/config.json\")),\n        \"test_password123\",\n    );\n    assert_matches!(result, Err(KeygenError::Io(_)));\n}\n\n#[test]\nfn test_key_encoding() {\n    let keypair = Keypair::generate_ed25519();\n    let public_key = keypair.public().encode_protobuf();\n    let public_key_b58 = bs58::encode(public_key).into_string();\n\n    // Verify the public key is properly encoded\n    assert!(!public_key_b58.is_empty());\n    assert!(bs58::decode(&public_key_b58).into_vec().is_ok());\n}\n\n#[test]\nfn test_encryption_params_serialization() {\n    let params = EncryptionParams {\n        kdf: \"argon2id\".to_string(),\n        salt_b64: \"test_salt\".to_string(),\n        iv_b64: \"test_iv\".to_string(),\n    };\n\n    let json = serde_json::to_string(&params).unwrap();\n    let deserialized: EncryptionParams = serde_json::from_str(&json).unwrap();\n\n    assert_eq!(params.kdf, deserialized.kdf);\n    assert_eq!(params.salt_b64, deserialized.salt_b64);\n    assert_eq!(params.iv_b64, deserialized.iv_b64);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","vidyootsenthil","TheValut-nameTBD","bin","esplora-client","src","main.rs"],"content":"use async_trait::async_trait;\nuse bitcoin::{consensus, Address, Network, Transaction};\nuse esplora_client::{AsyncClient, Builder};\nuse std::str::FromStr;\nuse tokio::sync::broadcast;\nuse tokio::time::{sleep, Duration};\n\n#[derive(Debug)]\npub enum NodeError {\n    Error(String),\n}\n\n#[async_trait]\npub trait WindowedConfirmedTransactionProvider {\n    // Must only return transactions that are confirmed in the given range [min_height, max_height].\n    // All returned transactions must have at least six confirmations (< current_chain_tip_height - 6).\n    async fn get_confirmed_transactions(\n        &self,\n        address: Address,\n        min_height: u32,\n        max_height: u32,\n    ) -> Result<Vec<Transaction>, NodeError>;\n\n    // Must poll for new transactions and send them to the given channel.\n    async fn poll_new_transactions(&self, address: Address);\n}\n\npub struct EsploraApiClient {\n    client: AsyncClient,\n    tx_channel: broadcast::Sender<Transaction>,\n}\n\nimpl EsploraApiClient {\n    pub fn new(client: AsyncClient, capacity: usize) -> Self {\n        Self {\n            client,\n            tx_channel: broadcast::channel(capacity).0,\n        }\n    }\n}\n\n#[async_trait]\nimpl WindowedConfirmedTransactionProvider for EsploraApiClient {\n    async fn get_confirmed_transactions(\n        &self,\n        address: Address,\n        min_height: u32,\n        max_height: u32,\n    ) -> Result<Vec<Transaction>, NodeError> {\n        let blockchain_height = self.client.get_height().await.map_err(|e| {\n            NodeError::Error(format!(\"Cannot retrieve height of blockchain: {}\", e))\n        })?;\n\n        let new_max_height = max_height.min(blockchain_height - 6);\n\n        let mut confirmed_txs = Vec::new();\n        let mut last_seen_txid = None;\n\n        loop {\n            let address_txs = self\n                .client\n                .scripthash_txs(&address.script_pubkey(), last_seen_txid)\n                .await\n                .map_err(|e| {\n                    NodeError::Error(format!(\"Cannot retrieve transactions for address: {}\", e))\n                })?;\n\n            if address_txs.is_empty() {\n                break;\n            }\n\n            let mut found_confirmed = false;\n            let last_tx_height = address_txs.last().and_then(|tx| tx.status.block_height);\n\n            for tx in address_txs {\n                if let Some(block_height) = tx.status.block_height {\n                    if block_height >= min_height && block_height <= new_max_height {\n                        if let Ok(full_tx) = self.client.get_tx(&tx.txid).await {\n                            if let Ok(bitcoin_tx) =\n                                consensus::deserialize(&consensus::serialize(&full_tx.unwrap()))\n                            {\n                                confirmed_txs.push(bitcoin_tx);\n                                found_confirmed = true;\n                            }\n                        }\n                    }\n                }\n                last_seen_txid = Some(tx.txid);\n            }\n\n            if !found_confirmed && last_tx_height.is_some_and(|height| height < min_height) {\n                break;\n            }\n        }\n\n        Ok(confirmed_txs)\n    }\n\n    async fn poll_new_transactions(&self, address: Address) {\n        let mut last_confirmed_height = match self.client.get_height().await {\n            Ok(height) => height - 6,\n            Err(e) => {\n                eprintln!(\"Cannot retrieve height of blockchain: {}\", e);\n                return;\n            }\n        };\n\n        println!(\n            \"Polling for new transactions for address {}, starting from confirmed height {}\",\n            address, last_confirmed_height\n        );\n\n        loop {\n            sleep(Duration::from_secs(60)).await;\n\n            let current_height = match self.client.get_height().await {\n                Ok(height) => height,\n                Err(e) => {\n                    eprintln!(\"Cannot retrieve height of blockchain: {}\", e);\n                    continue;\n                }\n            };\n\n            let new_confirmed_height = current_height - 6;\n\n            if new_confirmed_height > last_confirmed_height {\n                println!(\n                    \"New confirmed block found. From height {} to {}\",\n                    last_confirmed_height + 1,\n                    new_confirmed_height\n                );\n\n                let new_txs = match self\n                    .get_confirmed_transactions(\n                        address.clone(),\n                        last_confirmed_height + 1,\n                        new_confirmed_height,\n                    )\n                    .await\n                {\n                    Ok(txs) => txs,\n                    Err(e) => {\n                        eprintln!(\"Error getting confirmed transactions: {:?}\", e);\n                        continue;\n                    }\n                };\n\n                for tx in new_txs {\n                    println!(\"Found new confirmed transaction: {}\", tx.compute_txid());\n                    match self.tx_channel.send(tx) {\n                        Ok(_) => (),\n                        Err(e) => {\n                            eprintln!(\"Error sending transaction to channel: {:?}\", e);\n                        }\n                    }\n                }\n\n                last_confirmed_height = new_confirmed_height;\n            }\n        }\n    }\n}\n\n#[tokio::main]\nasync fn main() {\n    let client = EsploraApiClient::new(\n        Builder::new(\"https://blockstream.info/api\")\n            .build_async()\n            .unwrap(),\n        100,\n    );\n\n    let address = Address::from_str(\"bc1qezwz3yt46nsgzcwlg0dsw680nryjpq5u8pvzts\")\n        .unwrap()\n        .require_network(Network::Bitcoin)\n        .unwrap();\n\n    let transactions = client\n        .get_confirmed_transactions(address.clone(), 899900, 900000)\n        .await\n        .unwrap();\n    println!(\"Found {} transactions.\", transactions.len());\n    for tx in transactions {\n        println!(\"Transaction ID: {}\", tx.compute_txid());\n    }\n\n    client.poll_new_transactions(address).await;\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[tokio::test]\n    async fn test_get_confirmed_transactions() {\n        let client = EsploraApiClient::new(\n            Builder::new(\"https://blockstream.info/api\")\n                .build_async()\n                .unwrap(),\n            100,\n        );\n        let address = Address::from_str(\"bc1qezwz3yt46nsgzcwlg0dsw680nryjpq5u8pvzts\")\n            .unwrap()\n            .require_network(Network::Bitcoin)\n            .unwrap();\n        let transactions = client\n            .get_confirmed_transactions(address.clone(), 899900, 899930)\n            .await\n            .unwrap();\n\n        let correct_txs = vec![\n            \"99c024e891c3110297513a1bc8c6f36948b36461096e664be72c3ac96e958c5c\",\n            \"1d0249929acaf31c2c6b6e6f9c72f44bd663a426cb146afe0b7bbaa66e0bc0df\",\n            \"fdcd9cf8d660e359a6ab2993d649276fca60be01c2b4327f95ad2527cbe3db08\",\n            \"3fd280c3ccc13f0f88433f0ce95aeebacc249565c8e8b671005302de0616babe\",\n            \"a8705186a9d6b5063484a8029b0e2c4064e3e2723ea61ea10b6bc38d0abbc77a\",\n        ];\n\n        assert_eq!(transactions.len(), correct_txs.len());\n\n        for tx in transactions {\n            assert!(correct_txs.contains(&tx.compute_txid().to_string().as_str()));\n        }\n    }\n}\n","traces":[{"line":34,"address":[2157137,2156960,2157131],"length":1,"stats":{"Line":1}},{"line":37,"address":[2157018,2157070],"length":1,"stats":{"Line":2}},{"line":50,"address":[2119215,2118295,2118740,2123114,2119467,2122896,2118879],"length":1,"stats":{"Line":2}},{"line":51,"address":[2122974,2122926],"length":1,"stats":{"Line":0}},{"line":54,"address":[2119262],"length":1,"stats":{"Line":1}},{"line":56,"address":[2119385],"length":1,"stats":{"Line":1}},{"line":57,"address":[2119407],"length":1,"stats":{"Line":1}},{"line":59,"address":[2121288],"length":1,"stats":{"Line":1}},{"line":60,"address":[2121563,2121779,2121865,2121593,2121941,2119422],"length":1,"stats":{"Line":5}},{"line":62,"address":[2121494,2119439,2121395],"length":1,"stats":{"Line":3}},{"line":63,"address":[2006359],"length":1,"stats":{"Line":5}},{"line":64,"address":[2123136,2123354],"length":1,"stats":{"Line":0}},{"line":65,"address":[2123166,2123214],"length":1,"stats":{"Line":0}},{"line":68,"address":[2122085],"length":1,"stats":{"Line":1}},{"line":72,"address":[2122125],"length":1,"stats":{"Line":1}},{"line":73,"address":[2122140,2123376,2123381],"length":1,"stats":{"Line":3}},{"line":75,"address":[2121010,2122251],"length":1,"stats":{"Line":2}},{"line":76,"address":[2122692,2121117],"length":1,"stats":{"Line":2}},{"line":77,"address":[2120787,2122717],"length":1,"stats":{"Line":2}},{"line":78,"address":[2006378],"length":1,"stats":{"Line":5}},{"line":79,"address":[2120317,2120065,2120169,2120237],"length":1,"stats":{"Line":4}},{"line":82,"address":[2120499],"length":1,"stats":{"Line":1}},{"line":83,"address":[2120603],"length":1,"stats":{"Line":1}},{"line":88,"address":[2120808],"length":1,"stats":{"Line":1}},{"line":91,"address":[2121297,2123392,2121218,2123401],"length":1,"stats":{"Line":4}},{"line":96,"address":[2122415],"length":1,"stats":{"Line":1}},{"line":99,"address":[2123901,2124650,2123424,2123768,2123662,2123485],"length":1,"stats":{"Line":0}},{"line":100,"address":[2005906],"length":1,"stats":{"Line":0}},{"line":101,"address":[2124240,2124313],"length":1,"stats":{"Line":0}},{"line":102,"address":[2124166],"length":1,"stats":{"Line":0}},{"line":103,"address":[2124522,2124230],"length":1,"stats":{"Line":0}},{"line":108,"address":[2124333,2124286],"length":1,"stats":{"Line":0}},{"line":114,"address":[2126345,2126258,2123713,2124656,2124459],"length":1,"stats":{"Line":0}},{"line":116,"address":[2124690,2123734,2126507,2126595],"length":1,"stats":{"Line":0}},{"line":117,"address":[2126908],"length":1,"stats":{"Line":0}},{"line":118,"address":[2126834],"length":1,"stats":{"Line":0}},{"line":119,"address":[2127453,2126898],"length":1,"stats":{"Line":0}},{"line":124,"address":[2126989,2126922],"length":1,"stats":{"Line":0}},{"line":126,"address":[2125541,2126954],"length":1,"stats":{"Line":0}},{"line":127,"address":[2127047,2127095],"length":1,"stats":{"Line":0}},{"line":133,"address":[2127382,2124979,2124890,2127214,2127307],"length":1,"stats":{"Line":0}},{"line":135,"address":[2127231],"length":1,"stats":{"Line":0}},{"line":136,"address":[2127250,2127324],"length":1,"stats":{"Line":0}},{"line":137,"address":[2127285],"length":1,"stats":{"Line":0}},{"line":139,"address":[2005964],"length":1,"stats":{"Line":0}},{"line":141,"address":[2125051],"length":1,"stats":{"Line":0}},{"line":142,"address":[2124993],"length":1,"stats":{"Line":0}},{"line":143,"address":[2125041,2126152],"length":1,"stats":{"Line":0}},{"line":148,"address":[2125926,2125227,2125123,2125354],"length":1,"stats":{"Line":0}},{"line":149,"address":[2125587,2125463],"length":1,"stats":{"Line":0}},{"line":150,"address":[2125683],"length":1,"stats":{"Line":0}},{"line":152,"address":[2125831],"length":1,"stats":{"Line":0}},{"line":153,"address":[2125911,2125971],"length":1,"stats":{"Line":0}},{"line":158,"address":[2125505],"length":1,"stats":{"Line":0}},{"line":165,"address":[2157456,2157843,2157849],"length":1,"stats":{"Line":0}},{"line":167,"address":[2127636,2127769],"length":1,"stats":{"Line":0}},{"line":173,"address":[2127927,2127855,2127965],"length":1,"stats":{"Line":0}},{"line":175,"address":[2127957],"length":1,"stats":{"Line":0}},{"line":178,"address":[2128362,2128410,2128023,2128168,2128114],"length":1,"stats":{"Line":0}},{"line":179,"address":[2128048],"length":1,"stats":{"Line":0}},{"line":180,"address":[2128184,2128394,2127694,2128141,2128231],"length":1,"stats":{"Line":0}},{"line":182,"address":[2128450,2128522],"length":1,"stats":{"Line":0}},{"line":183,"address":[2128817,2128626],"length":1,"stats":{"Line":0}},{"line":184,"address":[2129178,2128918],"length":1,"stats":{"Line":0}},{"line":187,"address":[2008337],"length":1,"stats":{"Line":0}}],"covered":23,"coverable":65},{"path":["/","home","vidyootsenthil","TheValut-nameTBD","node","build.rs"],"content":"fn main() -> Result<(), Box<dyn std::error::Error>> {\n    tonic_build::compile_protos(\"proto/node.proto\")?;\n    Ok(())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","vidyootsenthil","TheValut-nameTBD","node","src","db.rs"],"content":"use rocksdb::DB;\n\nuse crate::{\n    errors::NodeError,\n    protocol::{\n        block::{Block, BlockHash},\n        chain_state::ChainState,\n    },\n};\n\npub struct Db {\n    pub db: DB,\n}\n\nimpl Db {\n    pub fn new(path: &str) -> Self {\n        let db = DB::open_default(path).unwrap();\n        Self { db }\n    }\n\n    pub fn get_value(&self, key: &str) -> Option<String> {\n        let value = self.db.get(key).unwrap();\n        value.map(|v| String::from_utf8(v).unwrap())\n    }\n\n    pub fn set_value(&self, key: &str, value: &str) {\n        self.db.put(key, value).unwrap();\n    }\n\n    pub fn get_block_by_height(&self, height: u64) -> Result<Option<Block>, NodeError> {\n        let block_hash = self.db.get(format!(\"h:{}\", height))?;\n        if let Some(block_hash) = block_hash {\n            let block = self.db.get(format!(\"b:{}\", hex::encode(block_hash)))?;\n            Ok(block.and_then(|b| Block::deserialize(&b).ok()))\n        } else {\n            Ok(None)\n        }\n    }\n\n    pub fn get_block_by_hash(&self, hash: BlockHash) -> Result<Option<Block>, NodeError> {\n        let block = self.db.get(format!(\"b:{}\", hex::encode(hash)))?;\n        Ok(block.and_then(|b| Block::deserialize(&b).ok()))\n    }\n\n    pub fn get_tip_block_hash(&self) -> Result<Option<BlockHash>, NodeError> {\n        let tip = self.db.get(\"h:tip\")?;\n        Ok(tip.and_then(|b| b.as_slice().try_into().ok()))\n    }\n\n    pub fn insert_chain_state(&self, chain_state: ChainState) -> Result<(), NodeError> {\n        self.db.put(\"c:state\", chain_state.serialize()?)?;\n        Ok(())\n    }\n\n    pub fn get_chain_state(&self) -> Result<Option<ChainState>, NodeError> {\n        let chain_state = self.db.get(\"c:state\")?;\n        Ok(chain_state.and_then(|b| ChainState::deserialize(&b).ok()))\n    }\n\n    pub fn insert_block(&self, block: Block) -> Result<(), NodeError> {\n        let block_hash = block.hash();\n        self.db\n            .put(format!(\"b:{}\", hex::encode(block_hash)), block.serialize()?)\n            .map_err(|e| NodeError::Error(format!(\"Failed to insert block: {}\", e)))?;\n\n        self.db\n            .put(format!(\"h:{}\", block.header.height), block_hash)\n            .map_err(|e| NodeError::Error(format!(\"Failed to insert block: {}\", e)))?;\n\n        self.db.put(\"h:tip\", block_hash)?;\n\n        Ok(())\n    }\n}\n","traces":[{"line":16,"address":[11410080],"length":1,"stats":{"Line":0}},{"line":17,"address":[8290625],"length":1,"stats":{"Line":0}},{"line":21,"address":[5497520],"length":1,"stats":{"Line":0}},{"line":22,"address":[11410221],"length":1,"stats":{"Line":0}},{"line":23,"address":[8461940],"length":1,"stats":{"Line":0}},{"line":26,"address":[8290800],"length":1,"stats":{"Line":0}},{"line":27,"address":[8290844],"length":1,"stats":{"Line":0}},{"line":30,"address":[8463334,8463300,8462048],"length":1,"stats":{"Line":0}},{"line":31,"address":[8290915],"length":1,"stats":{"Line":0}},{"line":32,"address":[11410749,11410885],"length":1,"stats":{"Line":0}},{"line":33,"address":[8291465,8291329],"length":1,"stats":{"Line":0}},{"line":34,"address":[10425136,10425164],"length":1,"stats":{"Line":0}},{"line":36,"address":[8462529],"length":1,"stats":{"Line":0}},{"line":40,"address":[8292256,8292970,8292941],"length":1,"stats":{"Line":0}},{"line":41,"address":[8292742,8292285],"length":1,"stats":{"Line":0}},{"line":42,"address":[5499579,5499675],"length":1,"stats":{"Line":0}},{"line":45,"address":[8293361,8292976,8293332],"length":1,"stats":{"Line":0}},{"line":46,"address":[8293000,8293123],"length":1,"stats":{"Line":0}},{"line":47,"address":[7447312,7447339],"length":1,"stats":{"Line":0}},{"line":50,"address":[8464969,8464544],"length":1,"stats":{"Line":0}},{"line":51,"address":[8464641,8464967,8464953,8464585],"length":1,"stats":{"Line":0}},{"line":52,"address":[8464921],"length":1,"stats":{"Line":0}},{"line":55,"address":[11413672,11413312,11413701],"length":1,"stats":{"Line":0}},{"line":56,"address":[5500584,5500704],"length":1,"stats":{"Line":0}},{"line":57,"address":[11413519,11413618],"length":1,"stats":{"Line":0}},{"line":60,"address":[11415237,11413712],"length":1,"stats":{"Line":0}},{"line":61,"address":[8294265],"length":1,"stats":{"Line":0}},{"line":62,"address":[5501674,5501763,5502362,5501579],"length":1,"stats":{"Line":0}},{"line":63,"address":[11415186,11413817,11414395],"length":1,"stats":{"Line":0}},{"line":64,"address":[10425824,10425846],"length":1,"stats":{"Line":0}},{"line":66,"address":[5501920,5502097,5502360],"length":1,"stats":{"Line":0}},{"line":67,"address":[8466264],"length":1,"stats":{"Line":0}},{"line":68,"address":[5502065],"length":1,"stats":{"Line":0}},{"line":70,"address":[8295680,8295447],"length":1,"stats":{"Line":0}},{"line":72,"address":[8295648],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":35},{"path":["/","home","vidyootsenthil","TheValut-nameTBD","node","src","dkg","mod.rs"],"content":"use std::collections::{BTreeMap, HashSet};\nuse tracing::{debug, error, info, warn};\n\nuse crate::{\n    errors::NodeError,\n    peer_id_to_identifier,\n    swarm_manager::{Network, PrivateRequest, PrivateResponse},\n};\nuse frost_secp256k1::{\n    self as frost, Identifier,\n    keys::dkg::{round1, round2},\n};\nuse libp2p::PeerId;\n\npub mod utils;\n\npub struct DkgState {\n    pub dkg_started: bool,\n    pub min_signers: u16,\n    pub max_signers: u16,\n    pub rng: frost::rand_core::OsRng,\n    pub peer_id: PeerId,\n    pub peers: HashSet<PeerId>,\n\n    pub peers_to_names: BTreeMap<PeerId, String>,\n    pub dkg_listeners: HashSet<PeerId>,\n\n    pub config_file: String,\n\n    pub start_dkg_topic: libp2p::gossipsub::IdentTopic,\n    pub round1_topic: libp2p::gossipsub::IdentTopic,\n\n    pub round1_peer_packages: BTreeMap<Identifier, round1::Package>,\n    pub round2_peer_packages: BTreeMap<Identifier, round2::Package>,\n\n    pub r1_secret_package: Option<round1::SecretPackage>,\n    pub r2_secret_package: Option<round2::SecretPackage>,\n\n    pub pubkey_package: Option<frost::keys::PublicKeyPackage>,\n    pub private_key_package: Option<frost::keys::KeyPackage>,\n}\n\nimpl DkgState {\n    pub fn handle_dkg_start(&mut self, network_handle: &impl Network) -> Result<(), NodeError> {\n        if self.dkg_started {\n            debug!(\"DKG already started, skipping DKG process\");\n            return Ok(());\n        }\n\n        // Check if DKG keys already exist\n        if self.private_key_package.is_some() && self.pubkey_package.is_some() {\n            info!(\"DKG keys already exist, skipping DKG process\");\n            if let Some(pubkey) = &self.pubkey_package {\n                info!(\"Existing public key: {:?}\", pubkey.verifying_key());\n            }\n            return Ok(());\n        }\n\n        if self.dkg_listeners.len() + 1 != self.max_signers as usize {\n            debug!(\n                \"Not all listeners have subscribed to the DKG topic, not starting DKG process. Listeners: {:?}\",\n                self.dkg_listeners.len()\n            );\n            return Ok(());\n        }\n\n        self.dkg_started = true;\n\n        // Run the DKG initialization code\n        let participant_identifier = peer_id_to_identifier(&self.peer_id);\n\n        let (round1_secret_package, round1_package) = frost::keys::dkg::part1(\n            participant_identifier,\n            self.max_signers,\n            self.min_signers,\n            self.rng,\n        )\n        .expect(\"Failed to generate round1 package\");\n\n        self.r1_secret_package = Some(round1_secret_package);\n\n        let round1_package_bytes = round1_package\n            .serialize()\n            .expect(\"Failed to serialize round1 package\");\n\n        // Broadcast START_DKG message to the network,\n        let start_message = format!(\"START_DKG:{}\", self.peer_id);\n\n        match network_handle.send_broadcast(\n            self.start_dkg_topic.clone(),\n            start_message.as_bytes().to_vec(),\n        ) {\n            Ok(_) => (),\n            Err(e) => {\n                return Err(NodeError::Error(format!(\n                    \"Failed to send broadcast: {:?}\",\n                    e\n                )));\n            }\n        }\n\n        match network_handle.send_broadcast(self.round1_topic.clone(), round1_package_bytes) {\n            Ok(_) => (),\n            Err(e) => {\n                return Err(NodeError::Error(format!(\n                    \"Failed to send broadcast: {:?}\",\n                    e\n                )));\n            }\n        }\n\n        match self.try_enter_round2(network_handle) {\n            Ok(_) => {\n                info!(\n                    \"Generated and published round1 package in response to DKG start signal from {}\",\n                    &self.peer_id\n                );\n                Ok(())\n            }\n            Err(e) => Err(NodeError::Error(format!(\"Failed to enter round2: {}\", e))),\n        }\n    }\n\n    pub fn handle_round1_payload(\n        &mut self,\n        network_handle: &impl Network,\n        sender_peer_id: PeerId,\n        package: Vec<u8>,\n    ) -> Result<(), NodeError> {\n        let identifier = peer_id_to_identifier(&sender_peer_id);\n        let package = match frost::keys::dkg::round1::Package::deserialize(&package) {\n            Ok(package) => package,\n            Err(e) => {\n                return Err(NodeError::Error(format!(\n                    \"Failed to deserialize round1 package: {}\",\n                    e\n                )));\n            }\n        };\n        // Add package to peer packages\n        self.round1_peer_packages.insert(identifier, package);\n\n        debug!(\n            \"Received round1 package from {} ({}/{})\",\n            sender_peer_id,\n            self.round1_peer_packages.len(),\n            self.max_signers - 1\n        );\n\n        self.try_enter_round2(network_handle)?;\n\n        Ok(())\n    }\n\n    pub fn try_enter_round2(&mut self, network_handle: &impl Network) -> Result<(), NodeError> {\n        if let Some(r1_secret_package) = self.r1_secret_package.as_ref() {\n            if self.round1_peer_packages.len() + 1 == self.max_signers as usize {\n                info!(\"Received all round1 packages, entering part2\");\n                // all packages received\n                let part2_result =\n                    frost::keys::dkg::part2(r1_secret_package.clone(), &self.round1_peer_packages);\n                match part2_result {\n                    Ok((round2_secret_package, round2_packages)) => {\n                        info!(\"-------------------- ENTERING ROUND 2 ---------------------\");\n                        self.r1_secret_package = None;\n                        self.r2_secret_package = Some(round2_secret_package);\n\n                        for peer_to_send_to in self.peers.iter() {\n                            let identifier = peer_id_to_identifier(peer_to_send_to);\n                            let package_to_send = match round2_packages.get(&identifier) {\n                                Some(package) => package,\n                                None => {\n                                    warn!(\"Round2 package not found for {}\", peer_to_send_to);\n                                    return Err(NodeError::Error(format!(\n                                        \"Round2 package not found for {}\",\n                                        peer_to_send_to\n                                    )));\n                                }\n                            };\n\n                            let request = PrivateRequest::Round2Package(package_to_send.clone());\n\n                            match network_handle.send_private_request(*peer_to_send_to, request) {\n                                Ok(_) => (),\n                                Err(e) => {\n                                    error!(\"Round2 package not found for {}\", peer_to_send_to);\n                                    return Err(NodeError::Error(format!(\n                                        \"Failed to send private request: {:?}\",\n                                        e\n                                    )));\n                                }\n                            }\n\n                            debug!(\"Sent round2 package to {}\", peer_to_send_to);\n                        }\n                    }\n                    Err(e) => {\n                        return Err(NodeError::Error(format!(\"DKG round2 failed: {}\", e)));\n                    }\n                }\n            }\n        }\n\n        Ok(())\n    }\n\n    pub fn handle_round2_payload(\n        &mut self,\n        network_handle: &impl Network,\n        sender_peer_id: PeerId,\n        package: round2::Package,\n        response_channel: libp2p::request_response::ResponseChannel<PrivateResponse>,\n    ) -> Result<(), NodeError> {\n        let identifier = peer_id_to_identifier(&sender_peer_id);\n\n        match network_handle.send_private_response(response_channel, PrivateResponse::Pong) {\n            Ok(_) => (),\n            Err(e) => {\n                return Err(NodeError::Error(format!(\n                    \"Failed to send private response: {:?}\",\n                    e\n                )));\n            }\n        }\n\n        // Add package to peer packages\n        self.round2_peer_packages.insert(identifier, package);\n\n        debug!(\n            \"Received round2 package from {} ({}/{})\",\n            sender_peer_id,\n            self.round2_peer_packages.len(),\n            self.max_signers - 1\n        );\n\n        if let Some(r2_secret_package) = self.r2_secret_package.as_ref() {\n            if self.round2_peer_packages.len() + 1 == self.max_signers as usize {\n                info!(\"Received all round2 packages, entering part3\");\n                let part3_result = frost::keys::dkg::part3(\n                    &r2_secret_package.clone(),\n                    &self.round1_peer_packages,\n                    &self.round2_peer_packages,\n                );\n\n                match part3_result {\n                    Ok((private_key_package, pubkey_package)) => {\n                        info!(\n                            \"🎉 DKG finished successfully. Public key: {:?}\",\n                            pubkey_package.verifying_key()\n                        );\n\n                        self.private_key_package = Some(private_key_package);\n                        self.pubkey_package = Some(pubkey_package);\n\n                        if let Err(e) = self.save_dkg_keys(network_handle) {\n                            error!(\"Failed to save DKG keys: {}\", e);\n                        } else {\n                            info!(\"DKG keys saved to config file\");\n                        }\n\n                        self.dkg_started = false;\n                    }\n                    Err(e) => {\n                        error!(\"DKG failed during part3 aggregation: {}\", e);\n                        // Reset state so that a fresh DKG can be attempted again later\n                        self.reset_dkg_state();\n                    }\n                }\n            }\n        }\n\n        Ok(())\n    }\n\n    /// Reset DKG state after a failed run so that a new DKG round can be initiated.\n    fn reset_dkg_state(&mut self) {\n        self.dkg_started = false;\n        self.r1_secret_package = None;\n        self.r2_secret_package = None;\n        self.round1_peer_packages.clear();\n        self.round2_peer_packages.clear();\n    }\n}\n","traces":[{"line":44,"address":[12412176,12415235,12415831],"length":1,"stats":{"Line":0}},{"line":45,"address":[9560567],"length":1,"stats":{"Line":0}},{"line":46,"address":[12417914,12417739,12412291],"length":1,"stats":{"Line":0}},{"line":47,"address":[9566232],"length":1,"stats":{"Line":0}},{"line":51,"address":[9560608,9560707],"length":1,"stats":{"Line":0}},{"line":52,"address":[12416499,12416705,12412390],"length":1,"stats":{"Line":0}},{"line":53,"address":[9585072,9585496],"length":1,"stats":{"Line":0}},{"line":54,"address":[12417088,12417139],"length":1,"stats":{"Line":0}},{"line":56,"address":[9585537],"length":1,"stats":{"Line":0}},{"line":59,"address":[9580854,9580747],"length":1,"stats":{"Line":0}},{"line":60,"address":[12415863,12416038,12416190,12412995],"length":1,"stats":{"Line":0}},{"line":64,"address":[12416020],"length":1,"stats":{"Line":0}},{"line":67,"address":[8517675],"length":1,"stats":{"Line":0}},{"line":70,"address":[9580900],"length":1,"stats":{"Line":0}},{"line":80,"address":[12412780,12413035],"length":1,"stats":{"Line":0}},{"line":82,"address":[12413170,12413241],"length":1,"stats":{"Line":0}},{"line":87,"address":[8518473,8518540],"length":1,"stats":{"Line":0}},{"line":89,"address":[9561989,9562040],"length":1,"stats":{"Line":0}},{"line":90,"address":[12413545,12413478],"length":1,"stats":{"Line":0}},{"line":91,"address":[9581977,9582042],"length":1,"stats":{"Line":0}},{"line":94,"address":[9562077],"length":1,"stats":{"Line":0}},{"line":95,"address":[12415533,12413773],"length":1,"stats":{"Line":0}},{"line":102,"address":[9582227],"length":1,"stats":{"Line":0}},{"line":104,"address":[9562290],"length":1,"stats":{"Line":0}},{"line":105,"address":[8519152,8520403],"length":1,"stats":{"Line":0}},{"line":112,"address":[9582448],"length":1,"stats":{"Line":0}},{"line":114,"address":[9582844,9583027,9582566],"length":1,"stats":{"Line":0}},{"line":118,"address":[9582826],"length":1,"stats":{"Line":0}},{"line":120,"address":[8519230,8520056],"length":1,"stats":{"Line":0}},{"line":124,"address":[8525323,8523376,8525121],"length":1,"stats":{"Line":0}},{"line":130,"address":[9566706],"length":1,"stats":{"Line":0}},{"line":131,"address":[9586865],"length":1,"stats":{"Line":0}},{"line":132,"address":[9587085],"length":1,"stats":{"Line":0}},{"line":133,"address":[12418548],"length":1,"stats":{"Line":0}},{"line":134,"address":[9568415,9566932],"length":1,"stats":{"Line":0}},{"line":141,"address":[12418732,12418889],"length":1,"stats":{"Line":0}},{"line":143,"address":[12419465,12419530],"length":1,"stats":{"Line":0}},{"line":150,"address":[9568172,9567512,9568361],"length":1,"stats":{"Line":0}},{"line":152,"address":[9568318],"length":1,"stats":{"Line":0}},{"line":155,"address":[12426301,12426307,12420288],"length":1,"stats":{"Line":0}},{"line":156,"address":[9588770],"length":1,"stats":{"Line":0}},{"line":157,"address":[9568853,9568779],"length":1,"stats":{"Line":0}},{"line":158,"address":[9569161,9568880],"length":1,"stats":{"Line":0}},{"line":160,"address":[9569064],"length":1,"stats":{"Line":0}},{"line":162,"address":[9589195],"length":1,"stats":{"Line":0}},{"line":163,"address":[12421453],"length":1,"stats":{"Line":0}},{"line":164,"address":[9590005,9590084,9590393],"length":1,"stats":{"Line":0}},{"line":165,"address":[9590367,9590816],"length":1,"stats":{"Line":0}},{"line":166,"address":[9591177,9590951],"length":1,"stats":{"Line":0}},{"line":168,"address":[9571247],"length":1,"stats":{"Line":0}},{"line":169,"address":[12423080],"length":1,"stats":{"Line":0}},{"line":170,"address":[9571557],"length":1,"stats":{"Line":0}},{"line":171,"address":[9591719],"length":1,"stats":{"Line":0}},{"line":173,"address":[9571677,9572007],"length":1,"stats":{"Line":0}},{"line":174,"address":[8529165,8528673],"length":1,"stats":{"Line":0}},{"line":181,"address":[12423319,12424358],"length":1,"stats":{"Line":0}},{"line":183,"address":[9592840],"length":1,"stats":{"Line":0}},{"line":185,"address":[12424563],"length":1,"stats":{"Line":0}},{"line":186,"address":[8530641,8529619,8530392],"length":1,"stats":{"Line":0}},{"line":187,"address":[9573935,9574405],"length":1,"stats":{"Line":0}},{"line":194,"address":[12424626],"length":1,"stats":{"Line":0}},{"line":197,"address":[8526254],"length":1,"stats":{"Line":0}},{"line":198,"address":[9569567],"length":1,"stats":{"Line":0}},{"line":204,"address":[8525538],"length":1,"stats":{"Line":0}},{"line":207,"address":[8537891,8531360,8536204],"length":1,"stats":{"Line":0}},{"line":214,"address":[12426473],"length":1,"stats":{"Line":0}},{"line":216,"address":[8531561],"length":1,"stats":{"Line":0}},{"line":218,"address":[9595081],"length":1,"stats":{"Line":0}},{"line":219,"address":[12426697,12432814],"length":1,"stats":{"Line":0}},{"line":227,"address":[8531723],"length":1,"stats":{"Line":0}},{"line":229,"address":[9595779],"length":1,"stats":{"Line":0}},{"line":236,"address":[12427828,12427117],"length":1,"stats":{"Line":0}},{"line":237,"address":[12432713,12427959,12427899],"length":1,"stats":{"Line":0}},{"line":238,"address":[8532999,8533325],"length":1,"stats":{"Line":0}},{"line":240,"address":[9576671],"length":1,"stats":{"Line":0}},{"line":241,"address":[8533744],"length":1,"stats":{"Line":0}},{"line":242,"address":[12428790],"length":1,"stats":{"Line":0}},{"line":245,"address":[8533907],"length":1,"stats":{"Line":0}},{"line":246,"address":[9577429],"length":1,"stats":{"Line":0}},{"line":247,"address":[8534648,8534885,8534098,8534174],"length":1,"stats":{"Line":0}},{"line":252,"address":[8534491],"length":1,"stats":{"Line":0}},{"line":253,"address":[9577922,9578549],"length":1,"stats":{"Line":0}},{"line":255,"address":[9578654],"length":1,"stats":{"Line":0}},{"line":256,"address":[9598822,9598923,9599210],"length":1,"stats":{"Line":0}},{"line":258,"address":[12431294],"length":1,"stats":{"Line":0}},{"line":261,"address":[9599684],"length":1,"stats":{"Line":0}},{"line":263,"address":[8533934],"length":1,"stats":{"Line":0}},{"line":264,"address":[12432258,12429026,12432013],"length":1,"stats":{"Line":0}},{"line":266,"address":[9580580,9581036],"length":1,"stats":{"Line":0}},{"line":272,"address":[9576269],"length":1,"stats":{"Line":0}},{"line":276,"address":[7741424,7741735],"length":1,"stats":{"Line":0}},{"line":277,"address":[7119331],"length":1,"stats":{"Line":0}},{"line":278,"address":[10261612,10261588],"length":1,"stats":{"Line":0}},{"line":279,"address":[7119492,7119519],"length":1,"stats":{"Line":0}},{"line":280,"address":[7119595],"length":1,"stats":{"Line":0}},{"line":281,"address":[7119612],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":96},{"path":["/","home","vidyootsenthil","TheValut-nameTBD","node","src","dkg","utils.rs"],"content":"use std::{\n    collections::{BTreeMap, HashSet},\n    fs,\n    path::Path,\n};\n\nuse aes_gcm::{Aes256Gcm, Key, KeyInit, Nonce, aead::Aead};\nuse argon2::{Argon2, password_hash::SaltString};\nuse base64::{Engine as _, engine::general_purpose::STANDARD as BASE64};\nuse frost_secp256k1::{self as frost};\nuse libp2p::{PeerId, gossipsub};\n\nuse crate::{\n    Config, DkgKeys, EncryptionParams, KeyData, NodeError, PeerData,\n    dkg::DkgState,\n    protocol::block::{ChainConfig, GenesisBlock, ValidatorInfo},\n    swarm_manager::{Network, PrivateRequest},\n};\n\nfn derive_key_from_password(\n    password: &str,\n    salt_str: &str,\n) -> Result<Vec<u8>, Box<dyn std::error::Error>> {\n    let argon2 = Argon2::default();\n    let password_bytes = password.as_bytes();\n    let salt =\n        SaltString::from_b64(salt_str).map_err(|e| format!(\"Salt decoding failed: {}\", e))?;\n\n    let mut key = vec![0u8; 32];\n    argon2\n        .hash_password_into(password_bytes, salt.as_str().as_bytes(), &mut key)\n        .map_err(|e| format!(\"Argon2 key derivation failed: {}\", e))?;\n    Ok(key)\n}\n\nfn encrypt_dkg_private_key(\n    private_key_data: &[u8],\n    password: &str,\n    salt_b64: &str,\n) -> Result<(String, String), Box<dyn std::error::Error>> {\n    let key_bytes = derive_key_from_password(password, salt_b64)?;\n\n    // Generate random IV\n    let mut iv = [0u8; 12];\n    use frost::rand_core::RngCore;\n    frost::rand_core::OsRng.fill_bytes(&mut iv);\n    let nonce = Nonce::from_slice(&iv);\n\n    let cipher = Aes256Gcm::new(Key::<Aes256Gcm>::from_slice(&key_bytes));\n    let ciphertext = cipher\n        .encrypt(nonce, private_key_data)\n        .map_err(|e| format!(\"AES encryption failed: {}\", e))?;\n\n    let encrypted_b64 = BASE64.encode(ciphertext);\n    let iv_b64 = BASE64.encode(iv);\n\n    Ok((encrypted_b64, iv_b64))\n}\n\nfn decrypt_dkg_private_key(\n    encrypted_private_key_b64: &str,\n    password: &str,\n    params: &EncryptionParams,\n) -> Result<Vec<u8>, Box<dyn std::error::Error>> {\n    let key_bytes = derive_key_from_password(password, &params.salt_b64)?;\n\n    let iv_bytes = BASE64.decode(&params.iv_b64)?;\n    let nonce = Nonce::from_slice(&iv_bytes);\n\n    let ciphertext = BASE64.decode(encrypted_private_key_b64)?;\n\n    let cipher = Aes256Gcm::new(Key::<Aes256Gcm>::from_slice(&key_bytes));\n    let decrypted_private_key = cipher\n        .decrypt(nonce, ciphertext.as_ref())\n        .map_err(|e| format!(\"AES decryption failed: {}\", e))?;\n\n    Ok(decrypted_private_key)\n}\n\nfn get_password_for_dkg() -> Result<String, Box<dyn std::error::Error>> {\n    match std::env::var(\"KEY_PASSWORD\") {\n        Ok(pw) => Ok(pw),\n        Err(_) => {\n            use std::io::{self, Write};\n            print!(\"Enter password to encrypt/decrypt DKG keys: \");\n            io::stdout().flush()?;\n            let password = rpassword::read_password()?;\n            Ok(password)\n        }\n    }\n}\n\nimpl DkgState {\n    pub fn get_public_key(&self) -> Option<frost::keys::PublicKeyPackage> {\n        self.pubkey_package.clone()\n    }\n\n    pub fn get_private_key(&self) -> Option<frost::keys::KeyPackage> {\n        self.private_key_package.clone()\n    }\n}\n\nimpl DkgState {\n    pub fn new(\n        min_signers: u16,\n        max_signers: u16,\n        peer_id: PeerId,\n        peers_to_names: BTreeMap<PeerId, String>,\n        config_file: String,\n    ) -> Result<Self, NodeError> {\n        let mut dkg_state = DkgState {\n            min_signers,\n            max_signers,\n            rng: frost::rand_core::OsRng,\n            peer_id,\n            peers_to_names,\n            dkg_listeners: HashSet::new(),\n            config_file,\n            start_dkg_topic: gossipsub::IdentTopic::new(\"start-dkg\"),\n            round1_topic: gossipsub::IdentTopic::new(\"round1_topic\"),\n            round1_peer_packages: BTreeMap::new(),\n            round2_peer_packages: BTreeMap::new(),\n            r1_secret_package: None,\n            r2_secret_package: None,\n            pubkey_package: None,\n            private_key_package: None,\n            peers: HashSet::new(),\n            dkg_started: false,\n        };\n\n        let keys = DkgState::load_dkg_keys(&dkg_state.config_file)\n            .map_err(|e| NodeError::Error(format!(\"Failed to load DKG keys: {}\", e)))?;\n\n        if let Some((private_key, pubkey)) = keys {\n            dkg_state.private_key_package = Some(private_key);\n            dkg_state.pubkey_package = Some(pubkey);\n        }\n\n        Ok(dkg_state)\n    }\n\n    pub fn save_dkg_keys(&self, network_handle: &impl Network) -> Result<(), NodeError> {\n        // Load existing config or create new one\n        let mut config = if Path::new(&self.config_file).exists() {\n            let config_str = fs::read_to_string(&self.config_file)\n                .map_err(|e| NodeError::Error(format!(\"Failed to read config: {}\", e)))?;\n            serde_json::from_str::<Config>(&config_str)\n                .map_err(|e| NodeError::Error(format!(\"Failed to deserialize config: {}\", e)))?\n        } else {\n            // For new configs, we need to create a dummy key_data\n            // This is not ideal but maintains compatibility with the structure\n            Config {\n                allowed_peers: self\n                    .peers_to_names\n                    .iter()\n                    .map(|(peer_id, name)| PeerData {\n                        name: name.clone(),\n                        public_key: peer_id.to_string(),\n                    })\n                    .collect(),\n                key_data: KeyData {\n                    public_key_b58: self.peer_id.to_string(),\n                    encrypted_private_key_b64: String::new(),\n                    encryption_params: EncryptionParams {\n                        kdf: String::new(),\n                        salt_b64: String::new(),\n                        iv_b64: String::new(),\n                    },\n                },\n                dkg_keys: None,\n                log_file_path: None,\n            }\n        };\n\n        // Update DKG keys if they exist\n        if let (Some(private_key), Some(pubkey)) = (&self.private_key_package, &self.pubkey_package)\n        {\n            let password = get_password_for_dkg()\n                .map_err(|e| NodeError::Error(format!(\"Failed to get password for DKG: {}\", e)))?;\n\n            // Serialize private key to bytes\n            let private_key_bytes = private_key\n                .serialize()\n                .map_err(|e| NodeError::Error(format!(\"Failed to serialize private key: {}\", e)))?;\n\n            // Use existing salt from key_data, or generate a new one if empty\n            let salt_b64 = if config.key_data.encryption_params.salt_b64.is_empty() {\n                // Generate a new salt\n                use frost::rand_core::RngCore;\n                let mut salt = [0u8; 16];\n                frost::rand_core::OsRng.fill_bytes(&mut salt);\n                BASE64.encode(salt)\n            } else {\n                config.key_data.encryption_params.salt_b64.clone()\n            };\n\n            // Encrypt the private key package\n            let (encrypted_private_key_b64, iv_b64) =\n                encrypt_dkg_private_key(&private_key_bytes, &password, &salt_b64).map_err(|e| {\n                    NodeError::Error(format!(\"Failed to encrypt private key: {}\", e))\n                })?;\n\n            // Serialize and base64 encode the public key package\n            let pubkey_bytes = pubkey\n                .serialize()\n                .map_err(|e| NodeError::Error(format!(\"Failed to serialize public key: {}\", e)))?;\n            let pubkey_package_b64 = BASE64.encode(pubkey_bytes);\n\n            config.dkg_keys = Some(DkgKeys {\n                encrypted_private_key_package_b64: encrypted_private_key_b64,\n                dkg_encryption_params: EncryptionParams {\n                    kdf: \"argon2id\".to_string(),\n                    salt_b64,\n                    iv_b64,\n                },\n                pubkey_package_b64,\n            });\n            let validators = self\n                .peers\n                .iter()\n                .map(|peer_id| ValidatorInfo {\n                    pub_key: peer_id.to_bytes(),\n                    stake: 100,\n                })\n                .collect();\n\n            let chain_config = ChainConfig {\n                block_time_seconds: 10,\n                min_signers: self.min_signers,\n                max_signers: self.max_signers,\n                min_stake: 100,\n                max_block_size: 1000,\n            };\n\n            let genesis_block = GenesisBlock::new(\n                validators,\n                chain_config,\n                pubkey.serialize().map_err(|e| {\n                    NodeError::Error(format!(\"Failed to serialize public key: {}\", e))\n                })?,\n            );\n            network_handle\n                .send_self_request(\n                    PrivateRequest::InsertBlock {\n                        block: genesis_block.to_block(),\n                    },\n                    false,\n                )\n                .map_err(|e| NodeError::Error(format!(\"Failed to send genesis block: {:?}\", e)))?;\n        }\n\n        // Save config\n        let config_str = serde_json::to_string_pretty(&config)\n            .map_err(|e| NodeError::Error(format!(\"Failed to serialize config: {}\", e)))?;\n        fs::write(&self.config_file, config_str)\n            .map_err(|e| NodeError::Error(format!(\"Failed to write config: {}\", e)))?;\n        Ok(())\n    }\n\n    pub fn load_dkg_keys(\n        config_path: &str,\n    ) -> Result<\n        Option<(frost::keys::KeyPackage, frost::keys::PublicKeyPackage)>,\n        Box<dyn std::error::Error>,\n    > {\n        if !Path::new(config_path).exists() {\n            return Ok(None);\n        }\n\n        let config_str = fs::read_to_string(config_path)?;\n        let config: Config = serde_json::from_str(&config_str)?;\n\n        if let Some(dkg_keys) = config.dkg_keys {\n            let password = get_password_for_dkg()?;\n\n            // Decrypt the private key package\n            let private_key_bytes = decrypt_dkg_private_key(\n                &dkg_keys.encrypted_private_key_package_b64,\n                &password,\n                &dkg_keys.dkg_encryption_params,\n            )?;\n\n            // Deserialize the private key from decrypted bytes\n            let private_key = frost::keys::KeyPackage::deserialize(&private_key_bytes)?;\n\n            // Deserialize the public key from base64\n            let pubkey_bytes = BASE64.decode(&dkg_keys.pubkey_package_b64)?;\n            let pubkey = frost::keys::PublicKeyPackage::deserialize(&pubkey_bytes)?;\n\n            Ok(Some((private_key, pubkey)))\n        } else {\n            Ok(None)\n        }\n    }\n}\n","traces":[{"line":20,"address":[6757529,6756560,6757523],"length":1,"stats":{"Line":0}},{"line":24,"address":[6770760],"length":1,"stats":{"Line":0}},{"line":25,"address":[6770784],"length":1,"stats":{"Line":0}},{"line":26,"address":[6756709],"length":1,"stats":{"Line":0}},{"line":29,"address":[6771150],"length":1,"stats":{"Line":0}},{"line":30,"address":[6771363,6771519],"length":1,"stats":{"Line":0}},{"line":31,"address":[6600013,6600096],"length":1,"stats":{"Line":0}},{"line":32,"address":[8935847,8935824],"length":1,"stats":{"Line":0}},{"line":33,"address":[9742622],"length":1,"stats":{"Line":0}},{"line":36,"address":[9742768,9744072,9744004],"length":1,"stats":{"Line":0}},{"line":41,"address":[6600658],"length":1,"stats":{"Line":0}},{"line":44,"address":[6600851],"length":1,"stats":{"Line":0}},{"line":46,"address":[9743114],"length":1,"stats":{"Line":0}},{"line":47,"address":[6757982],"length":1,"stats":{"Line":0}},{"line":49,"address":[6758007],"length":1,"stats":{"Line":0}},{"line":50,"address":[6772319,6772424,6772248],"length":1,"stats":{"Line":0}},{"line":52,"address":[6601224],"length":1,"stats":{"Line":0}},{"line":54,"address":[6601357],"length":1,"stats":{"Line":0}},{"line":55,"address":[6758462],"length":1,"stats":{"Line":0}},{"line":57,"address":[6772750],"length":1,"stats":{"Line":0}},{"line":60,"address":[6758832,6760236,6760262],"length":1,"stats":{"Line":0}},{"line":65,"address":[6601946],"length":1,"stats":{"Line":0}},{"line":67,"address":[6602167,6603342,6602241],"length":1,"stats":{"Line":0}},{"line":68,"address":[9744742,9744659],"length":1,"stats":{"Line":0}},{"line":70,"address":[6774492,6773709],"length":1,"stats":{"Line":0}},{"line":72,"address":[6602828,6602745],"length":1,"stats":{"Line":0}},{"line":73,"address":[6774124,6774256],"length":1,"stats":{"Line":0}},{"line":74,"address":[6774036],"length":1,"stats":{"Line":0}},{"line":75,"address":[9745296],"length":1,"stats":{"Line":0}},{"line":77,"address":[6774322],"length":1,"stats":{"Line":0}},{"line":80,"address":[6774528,6775167,6775196],"length":1,"stats":{"Line":0}},{"line":81,"address":[6774545],"length":1,"stats":{"Line":0}},{"line":82,"address":[6760367],"length":1,"stats":{"Line":0}},{"line":85,"address":[9745651,9745794],"length":1,"stats":{"Line":0}},{"line":86,"address":[9745810,9746224],"length":1,"stats":{"Line":0}},{"line":87,"address":[6760885,6760654],"length":1,"stats":{"Line":0}},{"line":88,"address":[6775073],"length":1,"stats":{"Line":0}},{"line":94,"address":[10255504],"length":1,"stats":{"Line":0}},{"line":95,"address":[7735601],"length":1,"stats":{"Line":0}},{"line":98,"address":[10255552],"length":1,"stats":{"Line":0}},{"line":99,"address":[10255569],"length":1,"stats":{"Line":0}},{"line":104,"address":[10258222,10257651,10255600],"length":1,"stats":{"Line":0}},{"line":117,"address":[7284666],"length":1,"stats":{"Line":0}},{"line":119,"address":[7735913],"length":1,"stats":{"Line":0}},{"line":120,"address":[7113672],"length":1,"stats":{"Line":0}},{"line":121,"address":[7284912],"length":1,"stats":{"Line":0}},{"line":122,"address":[7284972],"length":1,"stats":{"Line":0}},{"line":127,"address":[7736198],"length":1,"stats":{"Line":0}},{"line":131,"address":[7114628,7114696,7114833],"length":1,"stats":{"Line":0}},{"line":132,"address":[5907642,5907616],"length":1,"stats":{"Line":0}},{"line":134,"address":[10257162,10257610],"length":1,"stats":{"Line":0}},{"line":135,"address":[7286238],"length":1,"stats":{"Line":0}},{"line":136,"address":[7286288,7286500,7286410],"length":1,"stats":{"Line":0}},{"line":139,"address":[7115144],"length":1,"stats":{"Line":0}},{"line":142,"address":[8512378,8511200,8512372],"length":1,"stats":{"Line":0}},{"line":144,"address":[9554177],"length":1,"stats":{"Line":0}},{"line":145,"address":[12406065,12407037],"length":1,"stats":{"Line":0}},{"line":146,"address":[9575405],"length":1,"stats":{"Line":0}},{"line":147,"address":[9555704,9555471,9555554],"length":1,"stats":{"Line":0}},{"line":148,"address":[12407336],"length":1,"stats":{"Line":0}},{"line":153,"address":[9554266],"length":1,"stats":{"Line":0}},{"line":161,"address":[9554894],"length":1,"stats":{"Line":0}},{"line":176,"address":[9575303,9575884,9575948],"length":1,"stats":{"Line":0}},{"line":178,"address":[9555910,9556081,9559905,9555973],"length":1,"stats":{"Line":0}},{"line":179,"address":[5908634,5908608],"length":1,"stats":{"Line":0}},{"line":182,"address":[9556242,9556350,9559884,9556179],"length":1,"stats":{"Line":0}},{"line":184,"address":[9556318],"length":1,"stats":{"Line":0}},{"line":187,"address":[9576523,9576761,9576590],"length":1,"stats":{"Line":0}},{"line":190,"address":[9576623],"length":1,"stats":{"Line":0}},{"line":191,"address":[12408218],"length":1,"stats":{"Line":0}},{"line":192,"address":[8513640],"length":1,"stats":{"Line":0}},{"line":194,"address":[9556516,9556586],"length":1,"stats":{"Line":0}},{"line":198,"address":[5909260,5909254,5909024],"length":1,"stats":{"Line":0}},{"line":200,"address":[5909050,5909115],"length":1,"stats":{"Line":0}},{"line":204,"address":[9559635,9557162,9557222,9557330],"length":1,"stats":{"Line":0}},{"line":206,"address":[12408962],"length":1,"stats":{"Line":0}},{"line":207,"address":[9557546,9557431],"length":1,"stats":{"Line":0}},{"line":209,"address":[8514862,8515149],"length":1,"stats":{"Line":0}},{"line":210,"address":[9557554],"length":1,"stats":{"Line":0}},{"line":211,"address":[9557749],"length":1,"stats":{"Line":0}},{"line":212,"address":[12409258],"length":1,"stats":{"Line":0}},{"line":213,"address":[9557669],"length":1,"stats":{"Line":0}},{"line":214,"address":[9577789],"length":1,"stats":{"Line":0}},{"line":216,"address":[12409509],"length":1,"stats":{"Line":0}},{"line":218,"address":[8515345,8515428],"length":1,"stats":{"Line":0}},{"line":221,"address":[8975463,8975376],"length":1,"stats":{"Line":0}},{"line":222,"address":[8938078],"length":1,"stats":{"Line":0}},{"line":229,"address":[9558506],"length":1,"stats":{"Line":0}},{"line":230,"address":[8515478],"length":1,"stats":{"Line":0}},{"line":236,"address":[12410236],"length":1,"stats":{"Line":0}},{"line":238,"address":[8938176],"length":1,"stats":{"Line":0}},{"line":239,"address":[8975536],"length":1,"stats":{"Line":0}},{"line":242,"address":[12410959,12410799],"length":1,"stats":{"Line":0}},{"line":244,"address":[12410687],"length":1,"stats":{"Line":0}},{"line":245,"address":[12410608],"length":1,"stats":{"Line":0}},{"line":249,"address":[8938336,8938358],"length":1,"stats":{"Line":0}},{"line":253,"address":[9580559,9575918,9579987,9580095],"length":1,"stats":{"Line":0}},{"line":254,"address":[9559983],"length":1,"stats":{"Line":0}},{"line":255,"address":[12411898,12411788,12412021,12412106],"length":1,"stats":{"Line":0}},{"line":256,"address":[12411989],"length":1,"stats":{"Line":0}},{"line":257,"address":[9560391],"length":1,"stats":{"Line":0}},{"line":260,"address":[7738240,7740797,7741396],"length":1,"stats":{"Line":0}},{"line":266,"address":[7116108],"length":1,"stats":{"Line":0}},{"line":267,"address":[7738369],"length":1,"stats":{"Line":0}},{"line":270,"address":[7287456,7287357],"length":1,"stats":{"Line":0}},{"line":271,"address":[7116391,7119290,7116474],"length":1,"stats":{"Line":0}},{"line":273,"address":[7288060,7287830],"length":1,"stats":{"Line":0}},{"line":274,"address":[10259079,10260946,10259181],"length":1,"stats":{"Line":0}},{"line":278,"address":[7739331],"length":1,"stats":{"Line":0}},{"line":279,"address":[7739426],"length":1,"stats":{"Line":0}},{"line":280,"address":[10259510],"length":1,"stats":{"Line":0}},{"line":284,"address":[7288650,7288733,7289832],"length":1,"stats":{"Line":0}},{"line":287,"address":[7289830,7288973],"length":1,"stats":{"Line":0}},{"line":288,"address":[7118020,7118103],"length":1,"stats":{"Line":0}},{"line":290,"address":[7118389],"length":1,"stats":{"Line":0}},{"line":292,"address":[7116866],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":116},{"path":["/","home","vidyootsenthil","TheValut-nameTBD","node","src","errors.rs"],"content":"use std::error::Error;\n\nuse derive_more::Display;\nuse tokio::sync::mpsc::error::SendError;\n\nuse crate::swarm_manager::NetworkMessage;\n\n#[derive(Debug, Display)]\npub enum NodeError {\n    Error(String),\n}\n\n#[derive(Debug)]\npub enum NetworkError {\n    SendError(String),\n    RecvError,\n}\n\nimpl From<SendError<NetworkMessage>> for NetworkError {\n    fn from(e: SendError<NetworkMessage>) -> Self {\n        NetworkError::SendError(e.to_string())\n    }\n}\n\nimpl From<rocksdb::Error> for NodeError {\n    fn from(e: rocksdb::Error) -> Self {\n        NodeError::Error(e.to_string())\n    }\n}\n\nimpl Error for NodeError {}\n","traces":[{"line":20,"address":[7123223,7123104],"length":1,"stats":{"Line":0}},{"line":21,"address":[7123181,7123123],"length":1,"stats":{"Line":0}},{"line":26,"address":[7123248,7123367],"length":1,"stats":{"Line":0}},{"line":27,"address":[7123267,7123325],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":4},{"path":["/","home","vidyootsenthil","TheValut-nameTBD","node","src","grpc","grpc_handler.rs"],"content":"use crate::swarm_manager::NetworkHandle;\nuse tonic::{Request, Response, Status};\n\nuse crate::grpc::grpc_operator;\n\n// Include the generated proto code\npub mod node_proto {\n    tonic::include_proto!(\"node\");\n}\n\nuse node_proto::{\n    node_control_server::{NodeControl, NodeControlServer},\n    *,\n};\n\npub struct NodeControlService {\n    network: NetworkHandle,\n}\n\nimpl NodeControlService {\n    pub fn new(network: NetworkHandle) -> Self {\n        Self { network }\n    }\n\n    pub fn into_server(self) -> NodeControlServer<Self> {\n        NodeControlServer::new(self)\n    }\n}\n\n#[tonic::async_trait]\nimpl NodeControl for NodeControlService {\n    async fn start_dkg(\n        &self,\n        _request: Request<StartDkgRequest>,\n    ) -> Result<Response<StartDkgResponse>, Status> {\n        grpc_operator::start_dkg(&self.network, _request).await\n    }\n\n    async fn spend_funds(\n        &self,\n        request: Request<SpendFundsRequest>,\n    ) -> Result<Response<SpendFundsResponse>, Status> {\n        grpc_operator::spend_funds(&self.network, request).await\n    }\n\n    async fn start_signing(\n        &self,\n        request: Request<StartSigningRequest>,\n    ) -> Result<Response<StartSigningResponse>, Status> {\n        grpc_operator::start_signing(&self.network, request).await\n    }\n\n    async fn send_direct_message(\n        &self,\n        request: Request<SendDirectMessageRequest>,\n    ) -> Result<Response<SendDirectMessageResponse>, Status> {\n        grpc_operator::send_direct_message(&self.network, request).await\n    }\n\n    async fn create_deposit_intent(\n        &self,\n        request: Request<CreateDepositIntentRequest>,\n    ) -> Result<Response<CreateDepositIntentResponse>, Status> {\n        grpc_operator::create_deposit_intent(&self.network, request).await\n    }\n}\n","traces":[{"line":21,"address":[7262304],"length":1,"stats":{"Line":0}},{"line":25,"address":[7091168],"length":1,"stats":{"Line":0}},{"line":26,"address":[7262344],"length":1,"stats":{"Line":0}},{"line":36,"address":[5637151,5637652,5637520],"length":1,"stats":{"Line":0}},{"line":43,"address":[8357224,8356847,8357328],"length":1,"stats":{"Line":0}},{"line":50,"address":[8402209],"length":1,"stats":{"Line":0}},{"line":57,"address":[8658511,8658971,8658842],"length":1,"stats":{"Line":0}},{"line":64,"address":[5407009],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":8},{"path":["/","home","vidyootsenthil","TheValut-nameTBD","node","src","grpc","grpc_operator.rs"],"content":"use crate::grpc::grpc_handler::node_proto::{\n    CreateDepositIntentRequest, CreateDepositIntentResponse, SendDirectMessageRequest,\n    SendDirectMessageResponse, SpendFundsRequest, SpendFundsResponse, StartDkgRequest,\n    StartDkgResponse, StartSigningRequest, StartSigningResponse,\n};\nuse crate::swarm_manager::{Network, NetworkHandle, PingBody, PrivateRequest, PrivateResponse};\nuse libp2p::PeerId;\nuse libp2p::gossipsub::IdentTopic;\nuse tonic::{Request, Response, Status};\nuse tracing::{debug, info};\n\nuse bitcoin::script::Builder;\nuse std::str::FromStr;\nuse uuid::Uuid;\n\npub async fn start_dkg(\n    network: &NetworkHandle,\n    _request: Request<StartDkgRequest>,\n) -> Result<Response<StartDkgResponse>, Status> {\n    // Create start-dkg topic\n    let start_dkg_topic = IdentTopic::new(\"start-dkg\");\n\n    // Send a message to start DKG\n    let start_message = \"START_DKG\".to_string();\n\n    match network.send_broadcast(start_dkg_topic.clone(), start_message.as_bytes().to_vec()) {\n        Ok(_) => Ok(Response::new(StartDkgResponse {\n            success: true,\n            message: \"DKG process started\".to_string(),\n        })),\n        Err(e) => Err(Status::internal(format!(\"Network error: {:?}\", e))),\n    }\n}\n\npub async fn spend_funds(\n    network: &NetworkHandle,\n    request: Request<SpendFundsRequest>,\n) -> Result<Response<SpendFundsResponse>, Status> {\n    let amount_sat = request.into_inner().amount_satoshis;\n\n    debug!(\"Received request to spend {} satoshis\", amount_sat);\n    let response = network\n        .send_self_request(PrivateRequest::Spend { amount_sat }, true)\n        .map_err(|e| Status::internal(format!(\"Network error: {:?}\", e)))?\n        .ok_or(Status::internal(\"No response from node\"))?\n        .await\n        .map_err(|e| Status::internal(format!(\"Network error: {:?}\", e)))?;\n\n    let PrivateResponse::SpendRequestSent { sighash } = response else {\n        return Err(Status::internal(\"Invalid response from node\"));\n    };\n\n    Ok(Response::new(SpendFundsResponse {\n        success: true,\n        message: format!(\"Spending {} satoshis\", amount_sat),\n        sighash: sighash.to_string(),\n    }))\n}\n\npub async fn start_signing(\n    network: &NetworkHandle,\n    request: Request<StartSigningRequest>,\n) -> Result<Response<StartSigningResponse>, Status> {\n    let hex_msg = request.into_inner().hex_message;\n\n    let network_request = PrivateRequest::StartSigningSession {\n        hex_message: hex_msg.clone(),\n    };\n\n    let response = network\n        .send_self_request(network_request, true)\n        .map_err(|e| Status::internal(format!(\"Network error: {:?}\", e)))?\n        .ok_or(Status::internal(\"No response from node\"))?\n        .await\n        .map_err(|e| Status::internal(format!(\"Network error: {:?}\", e)))?;\n\n    let PrivateResponse::StartSigningSession { sign_id } = response else {\n        return Err(Status::internal(format!(\n            \"Invalid response from node {:?}\",\n            response\n        )));\n    };\n\n    Ok(Response::new(StartSigningResponse {\n        success: true,\n        message: \"Signing session started\".to_string(),\n        sign_id,\n    }))\n}\n\npub async fn send_direct_message(\n    network: &NetworkHandle,\n    request: Request<SendDirectMessageRequest>,\n) -> Result<Response<SendDirectMessageResponse>, Status> {\n    let req = request.into_inner();\n\n    let target_peer_id = req\n        .peer_id\n        .parse::<PeerId>()\n        .map_err(|e| Status::invalid_argument(format!(\"Invalid peer ID: {}\", e)))?;\n\n    let direct_message = format!(\"From: {}\", req.message);\n\n    match network.send_private_request(\n        target_peer_id,\n        PrivateRequest::Ping(PingBody {\n            message: direct_message,\n        }),\n    ) {\n        Ok(_) => Ok(Response::new(SendDirectMessageResponse {\n            success: true,\n            message: format!(\"Message sent to {}\", target_peer_id),\n        })),\n        Err(e) => Err(Status::internal(format!(\"Network error: {:?}\", e))),\n    }\n}\n\npub async fn create_deposit_intent(\n    network: &NetworkHandle,\n    request: Request<CreateDepositIntentRequest>,\n) -> Result<Response<CreateDepositIntentResponse>, Status> {\n    let req = request.into_inner();\n\n    let user_id = req\n        .user_id\n        .parse::<PeerId>()\n        .map_err(|e| Status::invalid_argument(format!(\"Invalid peer ID: {}\", e)))?;\n\n    let amount_sat = if req.amount_satoshis > 0 {\n        req.amount_satoshis\n    } else {\n        return Err(Status::invalid_argument(\n            \"Amount to deposit must be greater than 0\",\n        ));\n    };\n\n    let deposit_tracking_id = Uuid::new_v4().to_string();\n\n    let frost_pubkey_hex = network\n        .send_self_request(PrivateRequest::GetFrostPublicKey, true)\n        .map_err(|e| Status::internal(format!(\"Network error: {:?}\", e)))?\n        .ok_or(Status::internal(\"No response from node\"))?\n        .await\n        .map_err(|e| Status::internal(format!(\"Network error: {:?}\", e)))?;\n\n    let PrivateResponse::GetFrostPublicKey { public_key } = frost_pubkey_hex else {\n        return Err(Status::internal(\n            \"Invalid response from node. No public key found.\",\n        ));\n    };\n\n    let public_key = bitcoin::PublicKey::from_str(&public_key)\n        .map_err(|e| Status::internal(format!(\"Failed to parse public key: {}\", e)))?;\n\n    let witness_script = Builder::new()\n        .push_key(&public_key)\n        .push_opcode(bitcoin::opcodes::all::OP_CHECKSIG)\n        .into_script();\n\n    let deposit_address = bitcoin::Address::p2wsh(&witness_script, bitcoin::Network::Testnet);\n\n    info!(\n        \"Received request to create deposit intent for user {} with amount {}. Tracking ID: {}. Deposit Address: {}\",\n        user_id,\n        amount_sat,\n        deposit_tracking_id.clone(),\n        deposit_address\n    );\n\n    Ok(Response::new(CreateDepositIntentResponse {\n        success: true,\n        message: format!(\"Deposit intent created for user {}\", user_id),\n        deposit_tracking_id,\n        deposit_address: deposit_address.to_string(),\n    }))\n}\n","traces":[{"line":16,"address":[8379696],"length":1,"stats":{"Line":0}},{"line":21,"address":[5813633],"length":1,"stats":{"Line":0}},{"line":24,"address":[5813727],"length":1,"stats":{"Line":0}},{"line":26,"address":[5238282,5237458,5237451,5237526],"length":1,"stats":{"Line":0}},{"line":27,"address":[8838018],"length":1,"stats":{"Line":0}},{"line":29,"address":[5981591],"length":1,"stats":{"Line":0}},{"line":31,"address":[5814057,5814325],"length":1,"stats":{"Line":0}},{"line":35,"address":[11499264],"length":1,"stats":{"Line":0}},{"line":39,"address":[8838932,8838804],"length":1,"stats":{"Line":0}},{"line":41,"address":[5815450,5815120],"length":1,"stats":{"Line":0}},{"line":42,"address":[5816592,5816860,5815931,5816296,5816237,5816074,5817888,5816441,5816536,5816934,5817054,5816362,5815415],"length":1,"stats":{"Line":0}},{"line":43,"address":[5982849],"length":1,"stats":{"Line":0}},{"line":44,"address":[5985376,5985398,5983499],"length":1,"stats":{"Line":0}},{"line":45,"address":[5239484,5239772,5239860,5239965,5240163,5240219,5239741],"length":1,"stats":{"Line":0}},{"line":46,"address":[5651972],"length":1,"stats":{"Line":0}},{"line":47,"address":[8841990,8840872,8841968],"length":1,"stats":{"Line":0}},{"line":49,"address":[5817147],"length":1,"stats":{"Line":0}},{"line":50,"address":[8841629,8841053],"length":1,"stats":{"Line":0}},{"line":53,"address":[5241006],"length":1,"stats":{"Line":0}},{"line":55,"address":[5817198,5817307],"length":1,"stats":{"Line":0}},{"line":56,"address":[8841231],"length":1,"stats":{"Line":0}},{"line":60,"address":[8551024],"length":1,"stats":{"Line":0}},{"line":64,"address":[5818718,5818607],"length":1,"stats":{"Line":0}},{"line":67,"address":[5986225],"length":1,"stats":{"Line":0}},{"line":70,"address":[5987368,5987490,5988101,5986779,5986426,5986886,5986359,5986720,5986560,5986978,5987028,5987297],"length":1,"stats":{"Line":0}},{"line":72,"address":[5988112,5988134,5986516],"length":1,"stats":{"Line":0}},{"line":73,"address":[8843408,8843000,8843031,8842743,8843123,8843194,8843468],"length":1,"stats":{"Line":0}},{"line":74,"address":[5819475,5818658,5819873,5819525,5819680],"length":1,"stats":{"Line":0}},{"line":75,"address":[5492124,5492070,5492254],"length":1,"stats":{"Line":0}},{"line":77,"address":[5820103],"length":1,"stats":{"Line":0}},{"line":78,"address":[5820165,5820450],"length":1,"stats":{"Line":0}},{"line":84,"address":[8844067],"length":1,"stats":{"Line":0}},{"line":86,"address":[5820134],"length":1,"stats":{"Line":0}},{"line":91,"address":[8551104],"length":1,"stats":{"Line":0}},{"line":95,"address":[5821246],"length":1,"stats":{"Line":0}},{"line":97,"address":[8845373,8845166,8845234],"length":1,"stats":{"Line":0}},{"line":100,"address":[5246144,5244883,5246174],"length":1,"stats":{"Line":0}},{"line":102,"address":[5821738],"length":1,"stats":{"Line":0}},{"line":104,"address":[5822032],"length":1,"stats":{"Line":0}},{"line":105,"address":[5821870],"length":1,"stats":{"Line":0}},{"line":106,"address":[5821950],"length":1,"stats":{"Line":0}},{"line":110,"address":[5245701],"length":1,"stats":{"Line":0}},{"line":112,"address":[8846070],"length":1,"stats":{"Line":0}},{"line":114,"address":[8846008,8846328],"length":1,"stats":{"Line":0}},{"line":118,"address":[11499504],"length":1,"stats":{"Line":0}},{"line":122,"address":[8847131],"length":1,"stats":{"Line":0}},{"line":124,"address":[8848760,8847499,8847250,8847352],"length":1,"stats":{"Line":0}},{"line":127,"address":[5251120,5246941,5251150],"length":1,"stats":{"Line":0}},{"line":129,"address":[5247039],"length":1,"stats":{"Line":0}},{"line":130,"address":[5247084],"length":1,"stats":{"Line":0}},{"line":132,"address":[5823857,5823785],"length":1,"stats":{"Line":0}},{"line":137,"address":[8847662,8847794],"length":1,"stats":{"Line":0}},{"line":139,"address":[5827914,5824424,5824771,5825124,5824112,5824483,5825198,5825320,5824661,5824827,5824573,5824045,5824261],"length":1,"stats":{"Line":0}},{"line":140,"address":[5991509],"length":1,"stats":{"Line":0}},{"line":141,"address":[8852032,8848032,8852054],"length":1,"stats":{"Line":0}},{"line":142,"address":[5824352,5824926,5824383,5824608,5824077,5824475,5824866],"length":1,"stats":{"Line":0}},{"line":143,"address":[8495924],"length":1,"stats":{"Line":0}},{"line":144,"address":[5660417,5660362,5660630],"length":1,"stats":{"Line":0}},{"line":146,"address":[5825413],"length":1,"stats":{"Line":0}},{"line":147,"address":[5248689,5250912],"length":1,"stats":{"Line":0}},{"line":152,"address":[5992944,5993049,5993190],"length":1,"stats":{"Line":0}},{"line":153,"address":[5996160,5996176,5993183],"length":1,"stats":{"Line":0}},{"line":155,"address":[5993383],"length":1,"stats":{"Line":0}},{"line":160,"address":[5993484,5993567],"length":1,"stats":{"Line":0}},{"line":162,"address":[5994153,5993602,5993891],"length":1,"stats":{"Line":0}},{"line":170,"address":[5827321],"length":1,"stats":{"Line":0}},{"line":172,"address":[5827097,5826382],"length":1,"stats":{"Line":0}},{"line":173,"address":[5827197],"length":1,"stats":{"Line":0}},{"line":174,"address":[5827250],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":69},{"path":["/","home","vidyootsenthil","TheValut-nameTBD","node","src","grpc","mod.rs"],"content":"pub mod grpc_handler;\npub mod grpc_operator;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","vidyootsenthil","TheValut-nameTBD","node","src","key_manager.rs"],"content":"use std::{fs, path::PathBuf};\n\nuse crate::{Config, EncryptionParams, errors::NodeError};\nuse aes_gcm::{Aes256Gcm, Key, KeyInit, Nonce, aead::Aead};\nuse argon2::{Argon2, password_hash::SaltString};\nuse base64::{Engine as _, engine::general_purpose::STANDARD as BASE64};\nuse directories::ProjectDirs;\nuse libp2p::identity::Keypair;\nuse tracing::debug;\n\npub fn get_key_file_path() -> Result<PathBuf, NodeError> {\n    let proj_dirs = ProjectDirs::from(\"\", \"\", \"TheVault\")\n        .ok_or_else(|| NodeError::Error(\"Failed to determine project directory\".into()))?;\n\n    let config_dir = proj_dirs.config_dir();\n    fs::create_dir_all(config_dir)\n        .map_err(|e| NodeError::Error(format!(\"Failed to create config directory: {}\", e)))?;\n\n    let path = config_dir.join(\"config.json\");\n    debug!(\"Using key file path: {}\", path.display());\n    Ok(path)\n}\n\npub fn get_config_file_path(file_path_option: Option<String>) -> Result<PathBuf, NodeError> {\n    if let Some(file_path_str) = file_path_option {\n        let mut path = PathBuf::from(file_path_str);\n        if path.is_dir() {\n            path.push(\"config.json\");\n        }\n        println!(\"Using key file path: {}\", path.display());\n        Ok(path)\n    } else {\n        let proj_dirs = ProjectDirs::from(\"\", \"\", \"TheVault\")\n            .ok_or_else(|| NodeError::Error(\"Failed to determine project directory\".into()))?;\n        let config_dir = proj_dirs.config_dir();\n        Ok(config_dir.join(\"config.json\"))\n    }\n}\n\nfn derive_key_from_password(password: &str, salt_str: &str) -> Result<Vec<u8>, NodeError> {\n    let argon2 = Argon2::default();\n    let password_bytes = password.as_bytes();\n    let salt = SaltString::from_b64(salt_str)\n        .map_err(|e| NodeError::Error(format!(\"Salt decoding failed: {}\", e)))?;\n\n    let mut key = vec![0u8; 32];\n    argon2\n        .hash_password_into(password_bytes, salt.as_str().as_bytes(), &mut key)\n        .map_err(|e| NodeError::Error(format!(\"Argon2 key derivation failed: {}\", e)))?;\n    Ok(key)\n}\n\nfn decrypt_private_key(\n    encrypted_private_key_b64: &str,\n    password: &str,\n    params: &EncryptionParams,\n) -> Result<Vec<u8>, NodeError> {\n    let key_bytes = derive_key_from_password(password, &params.salt_b64)?;\n\n    let iv_bytes = BASE64\n        .decode(&params.iv_b64)\n        .map_err(|e| NodeError::Error(format!(\"IV decoding failed: {}\", e)))?;\n    let nonce = Nonce::from_slice(&iv_bytes);\n\n    let ciphertext = BASE64\n        .decode(encrypted_private_key_b64)\n        .map_err(|e| NodeError::Error(format!(\"Ciphertext decoding failed: {}\", e)))?;\n\n    let cipher = Aes256Gcm::new(Key::<Aes256Gcm>::from_slice(&key_bytes));\n\n    let decrypted_private_key = cipher\n        .decrypt(nonce, ciphertext.as_ref())\n        .map_err(|e| NodeError::Error(format!(\"AES decryption failed: {}\", e)))?;\n\n    Ok(decrypted_private_key)\n}\n\nfn get_password_from_prompt() -> Result<String, NodeError> {\n    rpassword::prompt_password(\"Enter password to decrypt identity key: \")\n        .map_err(|e| NodeError::Error(e.to_string()))\n}\n\npub fn get_config(config_filepath: Option<String>) -> Result<Config, NodeError> {\n    let key_file_path = if let Some(config_path) = config_filepath {\n        PathBuf::from(config_path)\n    } else {\n        get_key_file_path()?\n    };\n\n    debug!(\"Using key file path: {}\", key_file_path.display());\n\n    let config_contents = fs::read_to_string(&key_file_path)\n        .map_err(|e| NodeError::Error(format!(\"Failed to read config file: {}\", e)))?;\n\n    debug!(\"Read config file\");\n\n    let config = serde_json::from_str::<Config>(&config_contents)\n        .map_err(|e| NodeError::Error(format!(\"Failed to deserialize config file: {}\", e)))?;\n\n    debug!(\"Deserialized config file\");\n\n    Ok(config)\n}\n\npub fn load_and_decrypt_keypair(config_data: &Config) -> Result<Keypair, NodeError> {\n    let password = match std::env::var(\"KEY_PASSWORD\") {\n        Ok(pw) => pw,\n        Err(_) => get_password_from_prompt()?,\n    };\n\n    let private_key_protobuf = decrypt_private_key(\n        &config_data.key_data.encrypted_private_key_b64,\n        &password,\n        &config_data.key_data.encryption_params,\n    )?;\n\n    Keypair::from_protobuf_encoding(&private_key_protobuf).map_err(|e| {\n        NodeError::Error(format!(\n            \"Failed to reconstruct keypair from protobuf: {}\",\n            e\n        ))\n    })\n}\n","traces":[{"line":11,"address":[10191819,10191841,10190192],"length":1,"stats":{"Line":0}},{"line":12,"address":[7047975,7048157],"length":1,"stats":{"Line":0}},{"line":13,"address":[7048109],"length":1,"stats":{"Line":0}},{"line":15,"address":[7219542,7219455],"length":1,"stats":{"Line":0}},{"line":16,"address":[7219727,7219577],"length":1,"stats":{"Line":0}},{"line":17,"address":[5862832,5862854],"length":1,"stats":{"Line":0}},{"line":19,"address":[10190841],"length":1,"stats":{"Line":0}},{"line":20,"address":[8132024,8131610,8131683],"length":1,"stats":{"Line":0}},{"line":21,"address":[8131914],"length":1,"stats":{"Line":0}},{"line":24,"address":[7050325,7049616,7050817],"length":1,"stats":{"Line":0}},{"line":25,"address":[7049644],"length":1,"stats":{"Line":0}},{"line":26,"address":[7220912],"length":1,"stats":{"Line":0}},{"line":27,"address":[7049880,7049948],"length":1,"stats":{"Line":0}},{"line":28,"address":[10192238],"length":1,"stats":{"Line":0}},{"line":30,"address":[7221149,7221209],"length":1,"stats":{"Line":0}},{"line":31,"address":[10192428],"length":1,"stats":{"Line":0}},{"line":33,"address":[10192702,10192571,10191991],"length":1,"stats":{"Line":0}},{"line":34,"address":[10192670],"length":1,"stats":{"Line":0}},{"line":35,"address":[10192886,10192811],"length":1,"stats":{"Line":0}},{"line":36,"address":[10192902],"length":1,"stats":{"Line":0}},{"line":40,"address":[10193088,10194070,10194076],"length":1,"stats":{"Line":0}},{"line":41,"address":[10193160],"length":1,"stats":{"Line":0}},{"line":42,"address":[10193184],"length":1,"stats":{"Line":0}},{"line":43,"address":[10193237,10193368],"length":1,"stats":{"Line":0}},{"line":44,"address":[10193320],"length":1,"stats":{"Line":0}},{"line":46,"address":[8134267],"length":1,"stats":{"Line":0}},{"line":47,"address":[7051679,7051523],"length":1,"stats":{"Line":0}},{"line":48,"address":[7222592,7222509],"length":1,"stats":{"Line":0}},{"line":49,"address":[5863368,5863344],"length":1,"stats":{"Line":0}},{"line":50,"address":[8134655],"length":1,"stats":{"Line":0}},{"line":53,"address":[10195633,10194096,10195607],"length":1,"stats":{"Line":0}},{"line":58,"address":[7223114],"length":1,"stats":{"Line":0}},{"line":60,"address":[7223340,7223410,7224559,7223515],"length":1,"stats":{"Line":0}},{"line":61,"address":[10194408],"length":1,"stats":{"Line":0}},{"line":62,"address":[10194555],"length":1,"stats":{"Line":0}},{"line":63,"address":[8135449,8135366],"length":1,"stats":{"Line":0}},{"line":65,"address":[7224541,7223861,7223730],"length":1,"stats":{"Line":0}},{"line":67,"address":[5863680,5863696],"length":1,"stats":{"Line":0}},{"line":69,"address":[7052786,7052869],"length":1,"stats":{"Line":0}},{"line":71,"address":[7053129,7052997],"length":1,"stats":{"Line":0}},{"line":72,"address":[7052909],"length":1,"stats":{"Line":0}},{"line":73,"address":[8135987],"length":1,"stats":{"Line":0}},{"line":75,"address":[7224363],"length":1,"stats":{"Line":0}},{"line":78,"address":[7224576],"length":1,"stats":{"Line":0}},{"line":79,"address":[7224589],"length":1,"stats":{"Line":0}},{"line":80,"address":[10137922,10137904],"length":1,"stats":{"Line":0}},{"line":83,"address":[10199226,10199359,10195712],"length":1,"stats":{"Line":0}},{"line":84,"address":[7053503,7053940],"length":1,"stats":{"Line":0}},{"line":85,"address":[10195941,10195846],"length":1,"stats":{"Line":0}},{"line":87,"address":[10195974,10199314,10195853],"length":1,"stats":{"Line":0}},{"line":90,"address":[8136579,8136864,8137155],"length":1,"stats":{"Line":0}},{"line":92,"address":[8137735,8139862,8137145,8137819],"length":1,"stats":{"Line":0}},{"line":93,"address":[7054931],"length":1,"stats":{"Line":0}},{"line":95,"address":[10197674,10197296,10197375],"length":1,"stats":{"Line":0}},{"line":97,"address":[7227029,7227179,7226576],"length":1,"stats":{"Line":0}},{"line":98,"address":[8138819],"length":1,"stats":{"Line":0}},{"line":100,"address":[7056498,7056110,7056183],"length":1,"stats":{"Line":0}},{"line":102,"address":[10198689],"length":1,"stats":{"Line":0}},{"line":105,"address":[10200347,10199392,10200328],"length":1,"stats":{"Line":0}},{"line":106,"address":[8140014],"length":1,"stats":{"Line":0}},{"line":107,"address":[10199474],"length":1,"stats":{"Line":0}},{"line":108,"address":[7057380,7057224],"length":1,"stats":{"Line":0}},{"line":112,"address":[7057600],"length":1,"stats":{"Line":0}},{"line":113,"address":[7057687],"length":1,"stats":{"Line":0}},{"line":114,"address":[10199969],"length":1,"stats":{"Line":0}},{"line":117,"address":[10138560,10138782],"length":1,"stats":{"Line":0}},{"line":118,"address":[6996342,6996402],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":67},{"path":["/","home","vidyootsenthil","TheValut-nameTBD","node","src","lib.rs"],"content":"use crate::{db::Db, dkg::DkgState, errors::NodeError};\nuse frost_secp256k1::{self as frost, Identifier};\nuse libp2p::PeerId;\nuse serde::{Deserialize, Serialize};\nuse std::{\n    collections::{BTreeMap, HashSet},\n    path::PathBuf,\n};\nuse swarm_manager::{Network, NetworkEvent};\nuse tokio::sync::mpsc::UnboundedReceiver;\nuse tracing::error;\n\npub mod db;\npub mod dkg;\npub mod grpc;\npub mod main_loop;\npub mod protocol;\npub mod signing;\npub mod start_node;\npub mod swarm_manager;\npub mod wallet;\n\npub mod errors;\npub mod key_manager;\n\n#[derive(Clone, Serialize, Deserialize, PartialEq)]\npub struct PeerData {\n    pub name: String,\n    pub public_key: String,\n}\n\n#[derive(Serialize, Deserialize)]\npub struct DkgKeys {\n    pub encrypted_private_key_package_b64: String,\n    pub dkg_encryption_params: EncryptionParams,\n    pub pubkey_package_b64: String,\n}\n\n#[derive(Serialize, Deserialize)]\npub struct EncryptionParams {\n    pub kdf: String,\n    pub salt_b64: String,\n    pub iv_b64: String,\n}\n\n#[derive(Serialize, Deserialize)]\npub struct KeyData {\n    pub public_key_b58: String,\n    pub encrypted_private_key_b64: String,\n    pub encryption_params: EncryptionParams,\n}\n\n#[derive(Serialize, Deserialize)]\npub struct Config {\n    pub allowed_peers: Vec<PeerData>,\n    pub key_data: KeyData,\n    pub dkg_keys: Option<DkgKeys>,\n    pub log_file_path: Option<PathBuf>,\n}\n\npub struct NodeState<N: Network> {\n    pub allowed_peers: Vec<PeerId>,\n    pub peers_to_names: BTreeMap<PeerId, String>,\n\n    // DKG\n    pub dkg_state: DkgState,\n    pub db: Db,\n\n    pub peer_id: PeerId,\n    pub peers: HashSet<PeerId>,\n\n    pub min_signers: u16,\n    pub max_signers: u16,\n    pub rng: frost::rand_core::OsRng,\n\n    // FROST signing\n    pub active_signing: Option<ActiveSigning>,\n    pub wallet: crate::wallet::SimpleWallet,\n    pub pending_spends: std::collections::BTreeMap<u64, crate::wallet::PendingSpend>,\n\n    // Config management\n    pub config_file: String,\n\n    pub network_handle: N,\n\n    pub network_events_stream: UnboundedReceiver<NetworkEvent>,\n}\n\nimpl<N: Network> NodeState<N> {\n    pub fn peer_name(&self, peer_id: &PeerId) -> String {\n        self.peers_to_names\n            .get(peer_id)\n            .unwrap_or(&peer_id.to_string())\n            .clone()\n    }\n\n    pub fn new_from_config(\n        network_handle: N,\n        peer_data: Vec<PeerData>,\n        min_signers: u16,\n        max_signers: u16,\n        config_file: String,\n        network_events_emitter: UnboundedReceiver<NetworkEvent>,\n    ) -> Result<Self, NodeError> {\n        let allowed_peers: Vec<PeerId> = peer_data\n            .iter()\n            .filter_map(|peer| {\n                peer.public_key\n                    .parse()\n                    .map_err(|e| NodeError::Error(format!(\"Failed to parse peer data: {}\", e)))\n                    .ok()\n            })\n            .collect::<Vec<PeerId>>();\n\n        let peers_to_names: BTreeMap<PeerId, String> = peer_data\n            .iter()\n            .filter_map(|peer| {\n                let peer_id = peer\n                    .public_key\n                    .parse()\n                    .map_err(|e| NodeError::Error(format!(\"Failed to parse peer data: {}\", e)))\n                    .ok()?;\n                Some((peer_id, peer.name.clone()))\n            })\n            .collect::<BTreeMap<PeerId, String>>();\n\n        let dkg_state = DkgState::new(\n            min_signers,\n            max_signers,\n            network_handle.peer_id(),\n            peers_to_names.clone(),\n            config_file.clone(),\n        )?;\n\n        Ok(NodeState {\n            network_handle: network_handle.clone(),\n            allowed_peers: allowed_peers.clone(),\n            network_events_stream: network_events_emitter,\n            peers_to_names: peers_to_names.clone(),\n            peer_id: network_handle.peer_id(),\n            min_signers,\n            max_signers,\n            db: Db::new(\"node_db.db\"),\n            dkg_state,\n            peers: HashSet::new(),\n            rng: frost::rand_core::OsRng,\n            active_signing: None,\n            wallet: crate::wallet::SimpleWallet::new(),\n            pending_spends: BTreeMap::new(),\n            config_file: config_file.clone(),\n        })\n    }\n}\n\npub fn peer_id_to_identifier(peer_id: &PeerId) -> Identifier {\n    let bytes = peer_id.to_bytes();\n    match Identifier::derive(&bytes) {\n        Ok(identifier) => identifier,\n        Err(e) => {\n            error!(\"Failed to derive identifier: {}\", e);\n            panic!(\"Failed to derive identifier\");\n        }\n    }\n}\n\n// Active signing session tracking\npub struct ActiveSigning {\n    pub sign_id: u64,\n    pub message: Vec<u8>,\n    pub selected_peers: Vec<PeerId>,\n    pub nonces: frost::round1::SigningNonces,\n    pub commitments: BTreeMap<Identifier, frost::round1::SigningCommitments>,\n    pub signature_shares: BTreeMap<Identifier, frost::round2::SignatureShare>,\n    pub signing_package: Option<frost::SigningPackage>,\n    pub is_coordinator: bool,\n}\n","traces":[{"line":90,"address":[9055657,9055456,9055651],"length":1,"stats":{"Line":0}},{"line":91,"address":[9496002,9496057,9496115],"length":1,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[9496028],"length":1,"stats":{"Line":0}},{"line":97,"address":[9055680,9058069,9058367],"length":1,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[9498880],"length":1,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[6424366,6424336],"length":1,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":115,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[9058752],"length":1,"stats":{"Line":0}},{"line":118,"address":[9058798],"length":1,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[6424896,6424926],"length":1,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[6424759],"length":1,"stats":{"Line":0}},{"line":128,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[9056241],"length":1,"stats":{"Line":0}},{"line":132,"address":[9056281],"length":1,"stats":{"Line":0}},{"line":135,"address":[9057270],"length":1,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[9056694],"length":1,"stats":{"Line":0}},{"line":138,"address":[9497265],"length":1,"stats":{"Line":0}},{"line":139,"address":[9056793],"length":1,"stats":{"Line":0}},{"line":140,"address":[9056872],"length":1,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[9497428],"length":1,"stats":{"Line":0}},{"line":144,"address":[9521235],"length":1,"stats":{"Line":0}},{"line":145,"address":[9497497],"length":1,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[6422986],"length":1,"stats":{"Line":0}},{"line":148,"address":[9497578],"length":1,"stats":{"Line":0}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":155,"address":[8757786,8757792,8756688],"length":1,"stats":{"Line":0}},{"line":156,"address":[8756713],"length":1,"stats":{"Line":0}},{"line":157,"address":[7517820,7517748],"length":1,"stats":{"Line":0}},{"line":158,"address":[7346777],"length":1,"stats":{"Line":0}},{"line":159,"address":[7346699],"length":1,"stats":{"Line":0}},{"line":160,"address":[7346747,7346852,7347104],"length":1,"stats":{"Line":0}},{"line":161,"address":[7347075,7347542],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":47},{"path":["/","home","vidyootsenthil","TheValut-nameTBD","node","src","main_loop.rs"],"content":"use libp2p::gossipsub;\nuse libp2p::request_response;\nuse tokio::select;\nuse tracing::{debug, error, info};\n\nuse crate::errors::NodeError;\nuse crate::swarm_manager::{NetworkEvent, PrivateRequest, PrivateResponse};\nuse crate::{Network, NodeState};\n\nimpl<N: Network> NodeState<N> {\n    pub async fn start(&mut self) -> Result<(), NodeError> {\n        info!(\"Local peer id: {}\", self.peer_id);\n\n        let round1_topic = gossipsub::IdentTopic::new(\"round1_topic\");\n        let start_dkg_topic = gossipsub::IdentTopic::new(\"start-dkg\");\n        loop {\n            select! {\n                send_message = self.network_events_stream.recv() => match send_message {\n                    Some(NetworkEvent::SelfRequest { request, response_channel }) => {\n                        match request {\n                            PrivateRequest::StartSigningSession { hex_message } => {\n                                match self.start_signing_session(&hex_message) {\n                                    Ok(_) => (),\n                                    Err(e) => {\n                                        return Err(NodeError::Error(format!(\"Failed to start signing session: {}\", e)));\n                                    }\n                                }\n                            },\n                            PrivateRequest::InsertBlock { block } => {\n                                if let Err(e) = self.db.insert_block(block) {\n                                    return Err(NodeError::Error(format!(\"Failed to handle genesis block: {}\", e)));\n                                }\n                            }\n                            PrivateRequest::Spend { amount_sat } => {\n                                let response = self.start_spend_request(amount_sat);\n                                if let Some(response_channel) = response_channel {\n                                    match response_channel.send(PrivateResponse::SpendRequestSent { sighash: response.unwrap_or(\"No sighash\".to_string()) }) {\n                                        Ok(_) => (),\n                                        Err(e) => {\n                                            return Err(NodeError::Error(format!(\"Failed to send response: {}\", e)));\n                                        }\n                                    }\n                                }\n                            }\n                            PrivateRequest::GetFrostPublicKey => {\n                                let response = self.get_frost_public_key();\n                                if let Some(response_channel) = response_channel {\n                                    match response_channel.send(PrivateResponse::GetFrostPublicKey { public_key: response.unwrap_or(\"No public key\".to_string()) }) {\n                                        Ok(_) => (),\n                                        Err(e) => {\n                                            return Err(NodeError::Error(format!(\"Failed to send response: {}\", e)));\n                                        }\n                                    }\n                                }\n                            }\n                            _ => {}\n                        }\n                    }\n                    Some(NetworkEvent::PeersConnected(list)) => {\n                        for (peer_id, _multiaddr) in list {\n                            self.peers.insert(peer_id);\n                            self.dkg_state.peers.insert(peer_id);\n                        }\n                    },\n                    Some(NetworkEvent::GossipsubMessage(message)) => {\n                        match message.topic {\n                            t if t == round1_topic.hash() => {\n                                if let Some(source_peer) = message.source {\n                                    info!(\"Received round1 payload from {}\", self.peer_name(&source_peer));\n                                    match self.dkg_state.handle_round1_payload(&self.network_handle, source_peer, message.data) {\n                                        Ok(_) => (),\n                                        Err(e) => {\n                                            error!(\"❌ Failed to handle round1 payload: {}\", e);\n                                        }\n                                    }\n                                }\n                            }\n                            t if t == start_dkg_topic.hash() => {\n                                match self.dkg_state.handle_dkg_start(&self.network_handle) {\n                                    Ok(_) => (),\n                                    Err(e) => {\n                                        error!(\"❌ Failed to handle DKG start: {}\", e);\n                                    }\n                                }\n                            }\n                            _ => {\n                                debug!(\"Received unhandled broadcast\");\n                            }\n                        }\n                    }\n                    // Handle direct message requests (incoming)\n                    Some(NetworkEvent::MessageEvent(request_response::Event::Message {\n                        peer,\n                        message: request_response::Message::Request { request: PrivateRequest::Round2Package(package), channel, .. }\n                    })) => {\n                        match self.dkg_state.handle_round2_payload(&self.network_handle, peer, package, channel) {\n                            Ok(_) => (),\n                            Err(e) => {\n                                error!(\"❌ Failed to handle round2 payload: {}\", e);\n                            }\n                        }\n\n                    }\n                    // Handle direct message requests (incoming)\n                    Some(NetworkEvent::MessageEvent(request_response::Event::Message {\n                        peer,\n                        message: request_response::Message::Request { request: PrivateRequest::SignRequest { sign_id, message }, channel, .. }\n                    })) => {\n                        match self.handle_sign_request(peer, sign_id, message, channel) {\n                            Ok(_) => (),\n                            Err(e) => {\n                                error!(\"❌ Failed to handle sign request: {}\", e);\n                            }\n                        }\n                    }\n                    // Handle direct message requests (incoming)\n                    Some(NetworkEvent::MessageEvent(request_response::Event::Message {\n                        peer,\n                        message: request_response::Message::Request { request: PrivateRequest::SignPackage { sign_id, package }, channel, .. }\n                    })) => {\n                        match self.handle_sign_package(peer, sign_id, package, channel) {\n                            Ok(_) => (),\n                            Err(e) => {\n                                error!(\"❌ Failed to handle sign package: {}\", e);\n                            }\n                        }\n                    }\n                    // Handle direct message requests (incoming)\n                    Some(NetworkEvent::MessageEvent(request_response::Event::Message {\n                        peer,\n                        message: request_response::Message::Response { response: PrivateResponse::Commitments { sign_id, commitments }, .. }\n                    })) => {\n                        match self.handle_commitments_response(peer, sign_id, commitments) {\n                            Ok(_) => (),\n                            Err(e) => {\n                                error!(\"❌ Failed to handle commitments response: {}\", e);\n                            }\n                        }\n                    }\n                    // Handle direct message requests (incoming)\n                    Some(NetworkEvent::MessageEvent(request_response::Event::Message {\n                        peer,\n                        message: request_response::Message::Response { response: PrivateResponse::SignatureShare { sign_id, signature_share }, .. }\n                    })) => {\n                        match self.handle_signature_share(peer, sign_id, signature_share) {\n                            Ok(_) => (),\n                            Err(e) => {\n                                error!(\"❌ Failed to handle signature share: {}\", e);\n                            }\n                        }\n                    }\n                    _ => {}\n                }\n            }\n        }\n    }\n}\n","traces":[{"line":11,"address":[9460240,9460248],"length":1,"stats":{"Line":0}},{"line":12,"address":[8233391,8232963,8233088],"length":1,"stats":{"Line":0}},{"line":14,"address":[8233353],"length":1,"stats":{"Line":0}},{"line":15,"address":[8405036,8405119],"length":1,"stats":{"Line":0}},{"line":16,"address":[8251121],"length":1,"stats":{"Line":0}},{"line":17,"address":[11371279],"length":1,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[],"length":0,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":0}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}},{"line":67,"address":[],"length":0,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":70,"address":[],"length":0,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[],"length":0,"stats":{"Line":0}},{"line":73,"address":[],"length":0,"stats":{"Line":0}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[],"length":0,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[],"length":0,"stats":{"Line":0}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":0}},{"line":96,"address":[],"length":0,"stats":{"Line":0}},{"line":97,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":106,"address":[],"length":0,"stats":{"Line":0}},{"line":107,"address":[],"length":0,"stats":{"Line":0}},{"line":108,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[],"length":0,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":117,"address":[],"length":0,"stats":{"Line":0}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[],"length":0,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[],"length":0,"stats":{"Line":0}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[],"length":0,"stats":{"Line":0}},{"line":148,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":93},{"path":["/","home","vidyootsenthil","TheValut-nameTBD","node","src","protocol","block.rs"],"content":"use std::time::{SystemTime, UNIX_EPOCH};\n\nuse bincode::{Decode, Encode};\nuse serde::{Deserialize, Serialize};\nuse sha2::{Digest, Sha256};\n\nuse crate::{errors::NodeError, protocol::transaction::Transaction};\n\npub type BlockHash = [u8; 32];\npub type StateRoot = [u8; 32];\n\n/// Block header containing all metadata\n#[derive(Debug, Clone, Encode, Decode, Serialize, Deserialize, PartialEq)]\npub struct BlockHeader {\n    /// Version of the block structure\n    pub version: u32,\n\n    /// Hash of the previous block\n    pub previous_block_hash: BlockHash,\n\n    /// Unix timestamp when block was created\n    pub timestamp: u64,\n\n    /// Block height/number in the chain\n    pub height: u64,\n\n    /// Proposer of this block (for PoS/PoA)\n    pub proposer: Vec<u8>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize, Encode, Decode)]\npub struct GenesisBlock {\n    pub version: u32,\n    pub timestamp: u64,\n    pub initial_state: GenesisState,\n    pub extra_data: Vec<u8>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize, Encode, Decode)]\npub struct GenesisState {\n    pub validators: Vec<ValidatorInfo>,\n    pub vault_pub_key: Vec<u8>,\n    pub initial_balances: Vec<(String, u64)>,\n    pub chain_config: ChainConfig,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize, Encode, Decode)]\npub struct ValidatorInfo {\n    pub pub_key: Vec<u8>,\n    pub stake: u64,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize, Encode, Decode)]\npub struct ChainConfig {\n    pub min_signers: u16,\n    pub max_signers: u16,\n    pub min_stake: u64,\n    pub block_time_seconds: u64,\n    pub max_block_size: u64,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize, Encode, Decode)]\npub struct Block {\n    pub header: BlockHeader,\n    pub body: BlockBody,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize, Encode, Decode)]\npub struct BlockBody {\n    pub transactions: Vec<Transaction>,\n}\n\nimpl BlockHeader {\n    pub fn calculate_hash(&self) -> BlockHash {\n        let mut hasher = Sha256::new();\n\n        hasher.update(self.version.to_le_bytes());\n        hasher.update(self.previous_block_hash);\n        hasher.update(self.timestamp.to_le_bytes());\n        hasher.update(self.height.to_le_bytes());\n        hasher.update(&self.proposer);\n\n        let result = hasher.finalize();\n        let mut hash = [0u8; 32];\n        hash.copy_from_slice(&result);\n        hash\n    }\n}\n\nimpl Block {\n    /// Create a new block\n    pub fn new(\n        previous_block_hash: BlockHash,\n        height: u64,\n        transactions: Vec<Transaction>,\n        proposer: Vec<u8>,\n    ) -> Self {\n        let header = BlockHeader {\n            version: 1,\n            previous_block_hash,\n            timestamp: SystemTime::now()\n                .duration_since(UNIX_EPOCH)\n                .unwrap()\n                .as_secs(),\n            height,\n            proposer,\n        };\n\n        Block {\n            header,\n            body: BlockBody { transactions },\n        }\n    }\n\n    pub fn hash(&self) -> BlockHash {\n        self.header.calculate_hash()\n    }\n\n    pub fn serialize(&self) -> Result<Vec<u8>, NodeError> {\n        bincode::encode_to_vec(self, bincode::config::standard())\n            .map_err(|e| NodeError::Error(format!(\"Failed to serialize block: {}\", e)))\n    }\n\n    pub fn deserialize(data: &[u8]) -> Result<Self, NodeError> {\n        let (block, _): (Self, _) =\n            bincode::decode_from_slice(data, bincode::config::standard())\n                .map_err(|e| NodeError::Error(format!(\"Failed to deserialize block: {}\", e)))?;\n        Ok(block)\n    }\n}\n\nimpl GenesisBlock {\n    /// Create a new genesis block\n    pub fn new(\n        validators: Vec<ValidatorInfo>,\n        chain_config: ChainConfig,\n        vault_pub_key: Vec<u8>,\n    ) -> Self {\n        GenesisBlock {\n            version: 1,\n            timestamp: SystemTime::now()\n                .duration_since(UNIX_EPOCH)\n                .unwrap()\n                .as_secs(),\n            initial_state: GenesisState {\n                validators,\n                vault_pub_key,\n                initial_balances: vec![],\n                chain_config,\n            },\n            extra_data: b\"Genesis Block\".to_vec(),\n        }\n    }\n\n    pub fn to_block(&self) -> Block {\n        let mut hasher = Sha256::new();\n        hasher.update(b\"GENESIS\");\n        hasher.update(self.timestamp.to_le_bytes());\n        let state_bytes =\n            bincode::encode_to_vec(&self.initial_state, bincode::config::standard()).unwrap();\n        hasher.update(&state_bytes);\n        let result = hasher.finalize();\n        let mut state_root = [0u8; 32];\n        state_root.copy_from_slice(&result);\n\n        Block::new(\n            [0u8; 32], // No previous block\n            0,         // Height 0\n            vec![],    // No transactions in genesis\n            self.initial_state\n                .validators\n                .first()\n                .map(|v| v.pub_key.clone())\n                .unwrap_or_default(),\n        )\n    }\n\n    /// Get hash of genesis block\n    pub fn hash(&self) -> BlockHash {\n        self.to_block().hash()\n    }\n}\n","traces":[{"line":74,"address":[8200512],"length":1,"stats":{"Line":1}},{"line":75,"address":[10795965],"length":1,"stats":{"Line":1}},{"line":77,"address":[8200556],"length":1,"stats":{"Line":1}},{"line":78,"address":[7646701],"length":1,"stats":{"Line":1}},{"line":79,"address":[10796116],"length":1,"stats":{"Line":1}},{"line":80,"address":[7818012],"length":1,"stats":{"Line":1}},{"line":81,"address":[7818084],"length":1,"stats":{"Line":1}},{"line":83,"address":[7646927],"length":1,"stats":{"Line":1}},{"line":84,"address":[10796316],"length":1,"stats":{"Line":1}},{"line":85,"address":[7646992],"length":1,"stats":{"Line":1}},{"line":86,"address":[10796399],"length":1,"stats":{"Line":1}},{"line":92,"address":[7647120,7647687,7647709],"length":1,"stats":{"Line":1}},{"line":101,"address":[7647165,7647235],"length":1,"stats":{"Line":2}},{"line":111,"address":[7818703],"length":1,"stats":{"Line":1}},{"line":115,"address":[7818896],"length":1,"stats":{"Line":1}},{"line":116,"address":[10797089],"length":1,"stats":{"Line":1}},{"line":119,"address":[7647776],"length":1,"stats":{"Line":0}},{"line":120,"address":[7818968],"length":1,"stats":{"Line":0}},{"line":121,"address":[8330960,8330982],"length":1,"stats":{"Line":0}},{"line":124,"address":[10797200],"length":1,"stats":{"Line":0}},{"line":125,"address":[7819231,7819067],"length":1,"stats":{"Line":0}},{"line":127,"address":[8331216,8331238],"length":1,"stats":{"Line":0}},{"line":128,"address":[10797484],"length":1,"stats":{"Line":0}},{"line":134,"address":[7648176,7648909,7648853],"length":1,"stats":{"Line":0}},{"line":141,"address":[7648310,7648208],"length":1,"stats":{"Line":0}},{"line":145,"address":[7648560],"length":1,"stats":{"Line":0}},{"line":151,"address":[10798023],"length":1,"stats":{"Line":0}},{"line":155,"address":[7649763,7648944,7649757],"length":1,"stats":{"Line":0}},{"line":156,"address":[7648974],"length":1,"stats":{"Line":0}},{"line":157,"address":[7649006],"length":1,"stats":{"Line":0}},{"line":158,"address":[10798371],"length":1,"stats":{"Line":0}},{"line":159,"address":[8202981],"length":1,"stats":{"Line":0}},{"line":161,"address":[7820349],"length":1,"stats":{"Line":0}},{"line":162,"address":[7649236],"length":1,"stats":{"Line":0}},{"line":163,"address":[7820537],"length":1,"stats":{"Line":0}},{"line":164,"address":[7649388],"length":1,"stats":{"Line":0}},{"line":167,"address":[7649458],"length":1,"stats":{"Line":0}},{"line":169,"address":[10798821],"length":1,"stats":{"Line":0}},{"line":170,"address":[7820749,7820669],"length":1,"stats":{"Line":0}},{"line":173,"address":[11450976,11450960],"length":1,"stats":{"Line":0}},{"line":179,"address":[7649901,7649907,7649776],"length":1,"stats":{"Line":0}},{"line":180,"address":[7649800],"length":1,"stats":{"Line":0}}],"covered":16,"coverable":42},{"path":["/","home","vidyootsenthil","TheValut-nameTBD","node","src","protocol","chain_state.rs"],"content":"use std::collections::HashMap;\n\nuse bincode::{Decode, Encode};\nuse serde::{Deserialize, Serialize};\n\nuse crate::errors::NodeError;\n\n#[derive(Debug, Clone, Serialize, Deserialize, Encode, Decode)]\npub struct Account {\n    pub address: String,\n    pub balance: u64,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize, Encode, Decode)]\npub struct ChainState {\n    // address -> account\n    accounts: HashMap<String, Account>,\n    block_height: u64,\n}\n\nimpl Default for ChainState {\n    fn default() -> Self {\n        Self::new()\n    }\n}\n\n// TODO: implement periodic flushing of chain state to rocksdb\nimpl ChainState {\n    pub fn new() -> Self {\n        Self {\n            accounts: HashMap::new(),\n            block_height: 0,\n        }\n    }\n\n    pub fn new_with_accounts(accounts: HashMap<String, Account>, block_height: u64) -> Self {\n        Self {\n            accounts,\n            block_height,\n        }\n    }\n\n    pub fn get_account(&self, address: &str) -> Option<&Account> {\n        self.accounts.get(address)\n    }\n\n    pub fn get_account_mut(&mut self, address: &str) -> Option<&mut Account> {\n        self.accounts.get_mut(address)\n    }\n\n    pub fn get_block_height(&self) -> u64 {\n        self.block_height\n    }\n\n    pub fn serialize(&self) -> Result<Vec<u8>, NodeError> {\n        bincode::encode_to_vec(self, bincode::config::standard())\n            .map_err(|e| NodeError::Error(e.to_string()))\n    }\n\n    pub fn deserialize(data: &[u8]) -> Result<Self, NodeError> {\n        let (chain_state, _): (Self, _) =\n            bincode::decode_from_slice(data, bincode::config::standard())\n                .map_err(|e| NodeError::Error(e.to_string()))?;\n        Ok(chain_state)\n    }\n}\n","traces":[{"line":22,"address":[10292640],"length":1,"stats":{"Line":0}},{"line":23,"address":[7150408],"length":1,"stats":{"Line":0}},{"line":29,"address":[7150432],"length":1,"stats":{"Line":1}},{"line":31,"address":[7150446],"length":1,"stats":{"Line":1}},{"line":36,"address":[8732768],"length":1,"stats":{"Line":1}},{"line":43,"address":[7321744],"length":1,"stats":{"Line":1}},{"line":44,"address":[7321762],"length":1,"stats":{"Line":1}},{"line":47,"address":[10292848],"length":1,"stats":{"Line":1}},{"line":48,"address":[10292866],"length":1,"stats":{"Line":1}},{"line":51,"address":[8732896],"length":1,"stats":{"Line":0}},{"line":52,"address":[10292885],"length":1,"stats":{"Line":0}},{"line":55,"address":[7321824],"length":1,"stats":{"Line":0}},{"line":56,"address":[10292920],"length":1,"stats":{"Line":0}},{"line":57,"address":[8308626,8308608],"length":1,"stats":{"Line":0}},{"line":60,"address":[7150736],"length":1,"stats":{"Line":0}},{"line":61,"address":[10293162,10293019],"length":1,"stats":{"Line":0}},{"line":63,"address":[7322051],"length":1,"stats":{"Line":0}},{"line":64,"address":[7150996],"length":1,"stats":{"Line":0}}],"covered":7,"coverable":18},{"path":["/","home","vidyootsenthil","TheValut-nameTBD","node","src","protocol","executor.rs"],"content":"use crate::{\n    errors::NodeError,\n    protocol::{\n        chain_state::ChainState,\n        transaction::{Operation, Transaction},\n    },\n};\n\npub struct TransactionExecutor;\n\nimpl TransactionExecutor {\n    pub fn execute_transaction(\n        transaction: Transaction,\n        chain_state: ChainState,\n    ) -> Result<ChainState, NodeError> {\n        let mut addresses = Vec::new();\n        let mut amounts = Vec::new();\n        let mut new_chain_state = chain_state.clone();\n        for operation in transaction.operations {\n            match operation {\n                Operation::OpPushAddress { address } => {\n                    addresses.push(address);\n                }\n                Operation::OpPushAmount { amount } => {\n                    amounts.push(amount);\n                }\n                Operation::OpIncrementBalance => {\n                    let address = addresses\n                        .pop()\n                        .ok_or(NodeError::Error(\"Invalid transaction\".to_string()))?;\n                    let amount = amounts\n                        .pop()\n                        .ok_or(NodeError::Error(\"Invalid transaction\".to_string()))?;\n                    let account = new_chain_state\n                        .get_account_mut(&address)\n                        .ok_or(NodeError::Error(\"Account not found\".to_string()))?;\n                    let new_balance = account.balance + amount;\n                    account.balance = new_balance;\n                }\n            }\n        }\n        Ok(new_chain_state)\n    }\n}\n","traces":[{"line":12,"address":[7567079,7564976,7567182],"length":1,"stats":{"Line":1}},{"line":16,"address":[7565003],"length":1,"stats":{"Line":1}},{"line":17,"address":[7565084],"length":1,"stats":{"Line":1}},{"line":18,"address":[7565154],"length":1,"stats":{"Line":1}},{"line":19,"address":[7565207,7565441,7565306],"length":1,"stats":{"Line":3}},{"line":20,"address":[6097538],"length":1,"stats":{"Line":1}},{"line":21,"address":[10715181],"length":1,"stats":{"Line":1}},{"line":22,"address":[7565966,7565869],"length":1,"stats":{"Line":2}},{"line":24,"address":[10715244],"length":1,"stats":{"Line":1}},{"line":25,"address":[6097936,6097987],"length":1,"stats":{"Line":2}},{"line":28,"address":[6097975,6098104,6099057,6098167,6098225],"length":1,"stats":{"Line":5}},{"line":30,"address":[10715328,10715529,10716504,10715475],"length":1,"stats":{"Line":3}},{"line":31,"address":[7566310,7566476,7566604,7567058],"length":1,"stats":{"Line":4}},{"line":33,"address":[7566403,7566572],"length":1,"stats":{"Line":2}},{"line":34,"address":[7737949,7738077,7737857,7738205],"length":1,"stats":{"Line":4}},{"line":35,"address":[10716006],"length":1,"stats":{"Line":1}},{"line":36,"address":[7566877,7566713],"length":1,"stats":{"Line":2}},{"line":37,"address":[10716304,10716361],"length":1,"stats":{"Line":1}},{"line":38,"address":[7566991],"length":1,"stats":{"Line":1}},{"line":42,"address":[7565619],"length":1,"stats":{"Line":1}}],"covered":20,"coverable":20},{"path":["/","home","vidyootsenthil","TheValut-nameTBD","node","src","protocol","mod.rs"],"content":"pub mod block;\npub mod chain_state;\npub mod executor;\npub mod transaction;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","vidyootsenthil","TheValut-nameTBD","node","src","protocol","transaction.rs"],"content":"use bincode::{Decode, Encode};\nuse serde::{Deserialize, Serialize};\nuse sha2::{Digest, Sha256};\n\npub type TransactionId = [u8; 32];\n\n#[derive(Debug, Clone, Serialize, Deserialize, Encode, Decode, PartialEq)]\npub struct Transaction {\n    pub version: u32,\n    pub timestamp: u64,\n    pub r#type: TransactionType,\n    pub operations: Vec<Operation>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize, Encode, Decode, PartialEq)]\npub enum TransactionType {\n    Deposit,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize, Encode, Decode, PartialEq)]\npub enum Operation {\n    OpPushAddress { address: String },\n    OpPushAmount { amount: u64 },\n    OpIncrementBalance,\n}\n\nimpl Transaction {\n    pub fn new(r#type: TransactionType, operations: Vec<Operation>) -> Self {\n        Transaction {\n            version: 1,\n            timestamp: std::time::SystemTime::now()\n                .duration_since(std::time::UNIX_EPOCH)\n                .unwrap()\n                .as_secs(),\n            r#type,\n            operations,\n        }\n    }\n\n    pub fn id(&self) -> TransactionId {\n        let mut hasher = Sha256::new();\n        hasher.update(self.version.to_le_bytes());\n        hasher.update(self.timestamp.to_le_bytes());\n\n        for op in &self.operations {\n            let op_bytes = bincode::encode_to_vec(op, bincode::config::standard()).unwrap();\n            hasher.update(&op_bytes);\n        }\n\n        let result = hasher.finalize();\n        let mut id = [0u8; 32];\n        id.copy_from_slice(&result);\n        id\n    }\n}\n","traces":[{"line":28,"address":[8829138,8828848],"length":1,"stats":{"Line":1}},{"line":31,"address":[8398092,8398022],"length":1,"stats":{"Line":2}},{"line":40,"address":[8398938,8398320,8398944],"length":1,"stats":{"Line":0}},{"line":41,"address":[8398350],"length":1,"stats":{"Line":0}},{"line":42,"address":[5345390],"length":1,"stats":{"Line":0}},{"line":43,"address":[5345456],"length":1,"stats":{"Line":0}},{"line":45,"address":[8398527,8398505],"length":1,"stats":{"Line":0}},{"line":46,"address":[8398601],"length":1,"stats":{"Line":0}},{"line":47,"address":[11515012],"length":1,"stats":{"Line":0}},{"line":50,"address":[8398695],"length":1,"stats":{"Line":0}},{"line":51,"address":[8398740],"length":1,"stats":{"Line":0}},{"line":52,"address":[8398760],"length":1,"stats":{"Line":0}},{"line":53,"address":[8398823],"length":1,"stats":{"Line":0}}],"covered":2,"coverable":13},{"path":["/","home","vidyootsenthil","TheValut-nameTBD","node","src","signing.rs"],"content":"use rand::seq::SliceRandom;\nuse std::collections::BTreeMap;\n\nuse frost_secp256k1::rand_core::RngCore;\nuse frost_secp256k1::{self as frost};\nuse hex;\nuse libp2p::{PeerId, request_response};\nuse tracing::{debug, error, info, warn};\n\nuse crate::errors::NodeError;\nuse crate::swarm_manager::{Network, PrivateRequest, PrivateResponse};\nuse crate::{ActiveSigning, NodeState, peer_id_to_identifier};\n\nimpl<N: Network> NodeState<N> {\n    /// Coordinator entrypoint. Start a threshold signing session across the network.\n    /// `message_hex` must be hex-encoded 32-byte sighash.\n    pub fn start_signing_session(&mut self, message_hex: &str) -> Result<Option<u64>, NodeError> {\n        if self.dkg_state.get_private_key().is_none() || self.dkg_state.get_public_key().is_none() {\n            error!(\"❌ DKG not completed – cannot start signing\");\n            return Err(NodeError::Error(\"DKG not completed\".to_string()));\n        }\n\n        let Ok(message) = hex::decode(message_hex.trim()) else {\n            error!(\"❌ Invalid hex message\");\n            return Err(NodeError::Error(\"Invalid hex message\".to_string()));\n        };\n        if message.len() != 32 {\n            error!(\n                \"❌ Message must be 32-byte (sighash) – got {} bytes\",\n                message.len()\n            );\n            return Err(NodeError::Error(\n                \"Message must be 32-byte (sighash)\".to_string(),\n            ));\n        }\n\n        info!(\"Starting signing session for message: {}\", message_hex);\n\n        if self.active_signing.is_some() {\n            error!(\"❌ A signing session is already active\");\n            return Err(NodeError::Error(\n                \"A signing session is already active\".to_string(),\n            ));\n        }\n\n        let sign_id = self.rng.next_u64();\n        let self_identifier = peer_id_to_identifier(&self.peer_id);\n\n        // Select participants: self + first (min_signers -1) peers\n        let required = (self.min_signers - 1) as usize;\n        if self.peers.len() < required {\n            error!(\"❌ Not enough peers – need at least {} others\", required);\n            return Err(NodeError::Error(\"Not enough peers\".to_string()));\n        }\n        // Randomly shuffle peers and pick required number\n        let mut rng_rand = rand::rng();\n        let mut peer_pool = self.peers.clone().into_iter().collect::<Vec<_>>();\n        peer_pool.shuffle(&mut rng_rand);\n\n        let selected_peers: Vec<PeerId> = peer_pool.into_iter().take(required).collect();\n\n        let mut participants: Vec<_> = Vec::new();\n        participants.push(self_identifier);\n        for peer in &selected_peers {\n            participants.push(peer_id_to_identifier(peer));\n        }\n\n        // Generate nonces & commitments for self\n        let key_pkg = match self.dkg_state.get_private_key().as_ref() {\n            Some(key_pkg) => key_pkg.clone(),\n            None => {\n                return Err(NodeError::Error(\"No private key found\".to_string()));\n            }\n        };\n        let (nonces, commitments) = frost::round1::commit(key_pkg.signing_share(), &mut self.rng);\n\n        let mut commitments_map = BTreeMap::new();\n        commitments_map.insert(self_identifier, commitments);\n\n        // Save active session\n        self.active_signing = Some(ActiveSigning {\n            sign_id,\n            message: message.clone(),\n            selected_peers: selected_peers.clone(),\n            nonces,\n            commitments: commitments_map,\n            signature_shares: BTreeMap::new(),\n            signing_package: None,\n            is_coordinator: true,\n        });\n\n        // Broadcast SignRequest to chosen peers (skip self)\n        for peer in &selected_peers {\n            let req = PrivateRequest::SignRequest {\n                sign_id,\n                message: message.clone(),\n            };\n            self.network_handle\n                .send_private_request(*peer, req)\n                .map_err(|e| {\n                    NodeError::Error(format!(\"Failed to send private request: {:?}\", e))\n                })?;\n        }\n\n        Ok(Some(sign_id))\n    }\n\n    /// Handle incoming SignRequest (participant side)\n    pub fn handle_sign_request(\n        &mut self,\n        peer: PeerId,\n        sign_id: u64,\n        message: Vec<u8>,\n        channel: request_response::ResponseChannel<PrivateResponse>,\n    ) -> Result<(), NodeError> {\n        if self.dkg_state.get_private_key().is_none() {\n            let _ = self.network_handle.send_private_response(\n                channel,\n                PrivateResponse::Commitments {\n                    sign_id,\n                    commitments: Vec::new(),\n                },\n            );\n            return Ok(());\n        }\n\n        let key_pkg = match self.dkg_state.get_private_key().as_ref() {\n            Some(key_pkg) => key_pkg.clone(),\n            None => {\n                return Err(NodeError::Error(\"No private key found\".to_string()));\n            }\n        };\n        let (nonces, commitments) = frost::round1::commit(key_pkg.signing_share(), &mut self.rng);\n\n        // Save session (one at a time for simplicity)\n        self.active_signing = Some(ActiveSigning {\n            sign_id,\n            message: message.clone(),\n            selected_peers: Vec::new(),\n            nonces,\n            commitments: BTreeMap::new(), // not used for participant\n            signature_shares: BTreeMap::new(),\n            signing_package: None,\n            is_coordinator: false,\n        });\n\n        let Ok(commit_bytes) = commitments.serialize() else {\n            return Err(NodeError::Error(\n                \"Failed to serialize commitments\".to_string(),\n            ));\n        };\n\n        let resp = PrivateResponse::Commitments {\n            sign_id,\n            commitments: commit_bytes,\n        };\n        let _ = self.network_handle.send_private_response(channel, resp);\n\n        debug!(\n            \"🔐 Provided commitments for sign_id {} to {}\",\n            sign_id, peer\n        );\n\n        Ok(())\n    }\n\n    /// Coordinator receives commitments responses\n    pub fn handle_commitments_response(\n        &mut self,\n        peer: PeerId,\n        sign_id: u64,\n        commitments_bytes: Vec<u8>,\n    ) -> Result<(), NodeError> {\n        let Some(active) = self.active_signing.as_mut() else {\n            return Err(NodeError::Error(\"No active session\".to_string()));\n        };\n        if !active.is_coordinator || active.sign_id != sign_id {\n            return Err(NodeError::Error(\"Session id mismatch\".to_string()));\n        }\n\n        let Ok(commitments) = frost::round1::SigningCommitments::deserialize(&commitments_bytes)\n        else {\n            warn!(\"Failed to deserialize commitments from {}\", peer);\n            return Err(NodeError::Error(\n                \"Failed to deserialize commitments\".to_string(),\n            ));\n        };\n        let identifier = peer_id_to_identifier(&peer);\n        active.commitments.insert(identifier, commitments);\n        debug!(\n            \"📩 Received commitments from {} (total {}/{})\",\n            peer,\n            active.commitments.len(),\n            self.min_signers\n        );\n\n        if active.commitments.len() == self.min_signers as usize {\n            // Build signing package\n            let signing_package =\n                frost::SigningPackage::new(active.commitments.clone(), &active.message);\n            active.signing_package = Some(signing_package.clone());\n            let Ok(pkg_bytes) = signing_package.serialize() else {\n                warn!(\"Failed to serialize signing package\");\n                return Err(NodeError::Error(\n                    \"Failed to serialize signing package\".to_string(),\n                ));\n            };\n\n            // Send package to participants (excluding self)\n            for peer in &active.selected_peers {\n                let req = PrivateRequest::SignPackage {\n                    sign_id,\n                    package: pkg_bytes.clone(),\n                };\n                let _ = self.network_handle.send_private_request(*peer, req);\n            }\n\n            // Generate our signature share\n            let sig_share = frost::round2::sign(\n                &signing_package,\n                &active.nonces,\n                match self.dkg_state.get_private_key().as_ref() {\n                    Some(key_pkg) => key_pkg,\n                    None => {\n                        return Err(NodeError::Error(\"No private key found\".to_string()));\n                    }\n                },\n            );\n            match sig_share {\n                Ok(sig_share) => {\n                    active\n                        .signature_shares\n                        .insert(peer_id_to_identifier(&self.peer_id), sig_share);\n                }\n                Err(e) => {\n                    return Err(NodeError::Error(format!(\"Failed to sign: {}\", e)));\n                }\n            }\n\n            debug!(\"📦 Distributed signing package for session {}\", sign_id);\n        }\n\n        Ok(())\n    }\n\n    /// Participant handles SignPackage request\n    pub fn handle_sign_package(\n        &mut self,\n        peer: PeerId,\n        sign_id: u64,\n        package_bytes: Vec<u8>,\n        channel: request_response::ResponseChannel<PrivateResponse>,\n    ) -> Result<(), NodeError> {\n        let Some(active) = self.active_signing.as_ref() else {\n            warn!(\"No active session to sign\");\n            return Err(NodeError::Error(\"No active session\".to_string()));\n        };\n        if active.sign_id != sign_id {\n            warn!(\"Session id mismatch\");\n            return Err(NodeError::Error(\"Session id mismatch\".to_string()));\n        }\n\n        let Ok(signing_package) = frost::SigningPackage::deserialize(&package_bytes) else {\n            warn!(\"Failed to deserialize signing package\");\n            return Err(NodeError::Error(\n                \"Failed to deserialize signing package\".to_string(),\n            ));\n        };\n\n        let sig_share = frost::round2::sign(\n            &signing_package,\n            &active.nonces,\n            match self.dkg_state.get_private_key().as_ref() {\n                Some(key_pkg) => key_pkg,\n                None => {\n                    return Err(NodeError::Error(\"No private key found\".to_string()));\n                }\n            },\n        );\n        match sig_share {\n            Ok(sig_share) => {\n                let sig_bytes = sig_share.serialize();\n                let resp = PrivateResponse::SignatureShare {\n                    sign_id,\n                    signature_share: sig_bytes,\n                };\n                let _ = self.network_handle.send_private_response(channel, resp);\n            }\n            Err(e) => {\n                return Err(NodeError::Error(format!(\"Failed to sign: {}\", e)));\n            }\n        }\n\n        debug!(\n            \"✍️  Sent signature share for session {} to {}\",\n            sign_id, peer\n        );\n\n        Ok(())\n    }\n\n    /// Coordinator handles incoming signature share\n    pub fn handle_signature_share(\n        &mut self,\n        peer: PeerId,\n        sign_id: u64,\n        sig_bytes: Vec<u8>,\n    ) -> Result<(), NodeError> {\n        let Some(active) = self.active_signing.as_mut() else {\n            return Err(NodeError::Error(\"No active session\".to_string()));\n        };\n        if !active.is_coordinator || active.sign_id != sign_id {\n            return Err(NodeError::Error(\"Session id mismatch\".to_string()));\n        }\n\n        let Ok(sig_share) = frost::round2::SignatureShare::deserialize(&sig_bytes) else {\n            warn!(\"Failed to deserialize signature share from {}\", peer);\n            return Err(NodeError::Error(\n                \"Failed to deserialize signature share\".to_string(),\n            ));\n        };\n        let identifier = peer_id_to_identifier(&peer);\n        active.signature_shares.insert(identifier, sig_share);\n        debug!(\n            \"✅ Received signature share from {} (total {}/{})\",\n            peer,\n            active.signature_shares.len(),\n            self.min_signers\n        );\n\n        if active.signature_shares.len() == self.min_signers as usize {\n            let signing_package = match active.signing_package.clone() {\n                Some(signing_package) => signing_package,\n                None => {\n                    return Err(NodeError::Error(\"No signing package found\".to_string()));\n                }\n            };\n            let group_sig = frost::aggregate(\n                &signing_package,\n                &active.signature_shares,\n                match self.dkg_state.get_public_key().as_ref() {\n                    Some(public_key) => public_key,\n                    None => {\n                        return Err(NodeError::Error(\"No public key found\".to_string()));\n                    }\n                },\n            )\n            .expect(\"Aggregate\");\n            let sig_hex = hex::encode(group_sig.serialize().expect(\"serialize group sig\"));\n            debug!(\n                \"🎉 Final FROST signature for session {}: {}\",\n                sign_id, sig_hex\n            );\n\n            // If this signing session corresponds to a pending spend, finalise the transaction.\n            if let Some(pending) = self.pending_spends.remove(&sign_id) {\n                match Self::frost_signature_to_bitcoin(&group_sig) {\n                    Ok(bitcoin_sig) => {\n                        let mut tx = pending.tx;\n                        let mut witness = bitcoin::witness::Witness::new();\n                        witness.push(bitcoin_sig.as_ref());\n                        if let Some(input) = tx.input.first_mut() {\n                            input.witness = witness;\n                        }\n                        let raw_tx = bitcoin::consensus::encode::serialize(&tx);\n                        debug!(\"📤 Signed transaction (hex): {}\", hex::encode(raw_tx));\n                    }\n                    Err(e) => debug!(\"❌ Failed to convert signature: {}\", e),\n                }\n            }\n            // Reset\n            self.active_signing = None;\n        }\n\n        Ok(())\n    }\n}\n","traces":[{"line":17,"address":[9464749,9467354,9460272],"length":1,"stats":{"Line":0}},{"line":18,"address":[6386685,6386406,6386551],"length":1,"stats":{"Line":0}},{"line":19,"address":[6386511,6393930,6394205],"length":1,"stats":{"Line":0}},{"line":20,"address":[6394083],"length":1,"stats":{"Line":0}},{"line":23,"address":[9020206,9020064],"length":1,"stats":{"Line":0}},{"line":24,"address":[9460670,9467367,9467642],"length":1,"stats":{"Line":0}},{"line":25,"address":[9027024],"length":1,"stats":{"Line":0}},{"line":27,"address":[9020317,9020238],"length":1,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[9026770],"length":1,"stats":{"Line":0}},{"line":33,"address":[9490521],"length":1,"stats":{"Line":0}},{"line":37,"address":[9484962,9484661,9484595],"length":1,"stats":{"Line":0}},{"line":39,"address":[9461158,9461659],"length":1,"stats":{"Line":0}},{"line":40,"address":[9489804,9485475,9489511],"length":1,"stats":{"Line":0}},{"line":41,"address":[6392350],"length":1,"stats":{"Line":0}},{"line":42,"address":[9025498],"length":1,"stats":{"Line":0}},{"line":46,"address":[9461746,9461673],"length":1,"stats":{"Line":0}},{"line":47,"address":[9021258],"length":1,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[9021347,9021401],"length":1,"stats":{"Line":0}},{"line":52,"address":[9488643,9488942,9485702],"length":1,"stats":{"Line":0}},{"line":53,"address":[6391567,6391063],"length":1,"stats":{"Line":0}},{"line":56,"address":[9485749,9485683],"length":1,"stats":{"Line":0}},{"line":57,"address":[6388015,6388101],"length":1,"stats":{"Line":0}},{"line":58,"address":[9021709,9021617],"length":1,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":62,"address":[6388371],"length":1,"stats":{"Line":0}},{"line":63,"address":[9486192],"length":1,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":0}},{"line":65,"address":[9464799,9462683],"length":1,"stats":{"Line":0}},{"line":69,"address":[9022217],"length":1,"stats":{"Line":0}},{"line":70,"address":[9486586],"length":1,"stats":{"Line":0}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":72,"address":[6388827],"length":1,"stats":{"Line":0}},{"line":75,"address":[6388971],"length":1,"stats":{"Line":0}},{"line":77,"address":[6389113],"length":1,"stats":{"Line":0}},{"line":78,"address":[6389120],"length":1,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":83,"address":[9487087],"length":1,"stats":{"Line":0}},{"line":84,"address":[],"length":0,"stats":{"Line":0}},{"line":85,"address":[],"length":0,"stats":{"Line":0}},{"line":86,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[6389431],"length":1,"stats":{"Line":0}},{"line":88,"address":[9023045],"length":1,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[6389912],"length":1,"stats":{"Line":0}},{"line":96,"address":[9464114],"length":1,"stats":{"Line":0}},{"line":98,"address":[9488421,9488185,9488251],"length":1,"stats":{"Line":0}},{"line":99,"address":[],"length":0,"stats":{"Line":0}},{"line":100,"address":[8581248,8581470],"length":1,"stats":{"Line":0}},{"line":101,"address":[8581270,8581330],"length":1,"stats":{"Line":0}},{"line":105,"address":[],"length":0,"stats":{"Line":0}},{"line":109,"address":[9471143,9468656,9471606],"length":1,"stats":{"Line":0}},{"line":116,"address":[9028246,9028342],"length":1,"stats":{"Line":0}},{"line":117,"address":[6397250,6394818],"length":1,"stats":{"Line":0}},{"line":118,"address":[9468921],"length":1,"stats":{"Line":0}},{"line":119,"address":[9030834],"length":1,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[9492729],"length":1,"stats":{"Line":0}},{"line":124,"address":[9495244],"length":1,"stats":{"Line":0}},{"line":127,"address":[9028383,9028479],"length":1,"stats":{"Line":0}},{"line":128,"address":[9492819],"length":1,"stats":{"Line":0}},{"line":129,"address":[],"length":0,"stats":{"Line":0}},{"line":130,"address":[9028585],"length":1,"stats":{"Line":0}},{"line":133,"address":[9492998],"length":1,"stats":{"Line":0}},{"line":136,"address":[],"length":0,"stats":{"Line":0}},{"line":137,"address":[],"length":0,"stats":{"Line":0}},{"line":138,"address":[6395252],"length":1,"stats":{"Line":0}},{"line":139,"address":[9028886],"length":1,"stats":{"Line":0}},{"line":140,"address":[],"length":0,"stats":{"Line":0}},{"line":141,"address":[9028949],"length":1,"stats":{"Line":0}},{"line":142,"address":[9493281],"length":1,"stats":{"Line":0}},{"line":143,"address":[6395459],"length":1,"stats":{"Line":0}},{"line":144,"address":[],"length":0,"stats":{"Line":0}},{"line":147,"address":[9029574,9029489],"length":1,"stats":{"Line":0}},{"line":148,"address":[9494972],"length":1,"stats":{"Line":0}},{"line":149,"address":[9471157],"length":1,"stats":{"Line":0}},{"line":157,"address":[9470210,9470301],"length":1,"stats":{"Line":0}},{"line":159,"address":[6396484,6396184],"length":1,"stats":{"Line":0}},{"line":160,"address":[],"length":0,"stats":{"Line":0}},{"line":161,"address":[],"length":0,"stats":{"Line":0}},{"line":164,"address":[9030092],"length":1,"stats":{"Line":0}},{"line":168,"address":[9037304,9031136,9035478],"length":1,"stats":{"Line":0}},{"line":174,"address":[9471807,9471721],"length":1,"stats":{"Line":0}},{"line":175,"address":[9471881,9477712],"length":1,"stats":{"Line":0}},{"line":177,"address":[9471870,9471957],"length":1,"stats":{"Line":0}},{"line":178,"address":[9477616,9471915],"length":1,"stats":{"Line":0}},{"line":181,"address":[9472130,9471982],"length":1,"stats":{"Line":0}},{"line":182,"address":[],"length":0,"stats":{"Line":0}},{"line":183,"address":[9036317,9036574,9031575],"length":1,"stats":{"Line":0}},{"line":184,"address":[],"length":0,"stats":{"Line":0}},{"line":185,"address":[9477036],"length":1,"stats":{"Line":0}},{"line":188,"address":[9495916],"length":1,"stats":{"Line":0}},{"line":189,"address":[9031671],"length":1,"stats":{"Line":0}},{"line":190,"address":[9472848],"length":1,"stats":{"Line":0}},{"line":191,"address":[],"length":0,"stats":{"Line":0}},{"line":192,"address":[],"length":0,"stats":{"Line":0}},{"line":193,"address":[],"length":0,"stats":{"Line":0}},{"line":194,"address":[],"length":0,"stats":{"Line":0}},{"line":197,"address":[9472602,9473256],"length":1,"stats":{"Line":0}},{"line":199,"address":[9473316,9476784],"length":1,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":0}},{"line":201,"address":[6399313,6399372],"length":1,"stats":{"Line":0}},{"line":202,"address":[],"length":0,"stats":{"Line":0}},{"line":203,"address":[9035782,9035484],"length":1,"stats":{"Line":0}},{"line":204,"address":[9036181],"length":1,"stats":{"Line":0}},{"line":205,"address":[6402004],"length":1,"stats":{"Line":0}},{"line":210,"address":[9497649,9497740],"length":1,"stats":{"Line":0}},{"line":213,"address":[],"length":0,"stats":{"Line":0}},{"line":215,"address":[],"length":0,"stats":{"Line":0}},{"line":220,"address":[],"length":0,"stats":{"Line":0}},{"line":221,"address":[9497907],"length":1,"stats":{"Line":0}},{"line":222,"address":[],"length":0,"stats":{"Line":0}},{"line":223,"address":[9033752],"length":1,"stats":{"Line":0}},{"line":224,"address":[],"length":0,"stats":{"Line":0}},{"line":225,"address":[],"length":0,"stats":{"Line":0}},{"line":229,"address":[],"length":0,"stats":{"Line":0}},{"line":230,"address":[9498322],"length":1,"stats":{"Line":0}},{"line":231,"address":[9474594,9474642],"length":1,"stats":{"Line":0}},{"line":232,"address":[],"length":0,"stats":{"Line":0}},{"line":233,"address":[9034112],"length":1,"stats":{"Line":0}},{"line":235,"address":[9498228],"length":1,"stats":{"Line":0}},{"line":236,"address":[],"length":0,"stats":{"Line":0}},{"line":240,"address":[9475047,9474725],"length":1,"stats":{"Line":0}},{"line":243,"address":[6399104],"length":1,"stats":{"Line":0}},{"line":247,"address":[9039609,9037328,9042039],"length":1,"stats":{"Line":0}},{"line":254,"address":[9037501,9037410],"length":1,"stats":{"Line":0}},{"line":255,"address":[9478079,9481714,9481971],"length":1,"stats":{"Line":0}},{"line":256,"address":[6407629,6408056],"length":1,"stats":{"Line":0}},{"line":258,"address":[],"length":0,"stats":{"Line":0}},{"line":259,"address":[9504996,9504739,9501921],"length":1,"stats":{"Line":0}},{"line":260,"address":[6407311,6406882],"length":1,"stats":{"Line":0}},{"line":263,"address":[6403940,6404018,6403858],"length":1,"stats":{"Line":0}},{"line":264,"address":[9480445,9480111],"length":1,"stats":{"Line":0}},{"line":265,"address":[9504644],"length":1,"stats":{"Line":0}},{"line":266,"address":[6406111],"length":1,"stats":{"Line":0}},{"line":271,"address":[],"length":0,"stats":{"Line":0}},{"line":272,"address":[9478350],"length":1,"stats":{"Line":0}},{"line":273,"address":[9478429,9478362],"length":1,"stats":{"Line":0}},{"line":274,"address":[9038015],"length":1,"stats":{"Line":0}},{"line":275,"address":[],"length":0,"stats":{"Line":0}},{"line":276,"address":[9502333],"length":1,"stats":{"Line":0}},{"line":280,"address":[9038205],"length":1,"stats":{"Line":0}},{"line":281,"address":[],"length":0,"stats":{"Line":0}},{"line":282,"address":[9502617],"length":1,"stats":{"Line":0}},{"line":287,"address":[9038440],"length":1,"stats":{"Line":0}},{"line":289,"address":[6404439],"length":1,"stats":{"Line":0}},{"line":290,"address":[9038267,9039391],"length":1,"stats":{"Line":0}},{"line":294,"address":[9503124,9502781],"length":1,"stats":{"Line":0}},{"line":295,"address":[],"length":0,"stats":{"Line":0}},{"line":296,"address":[],"length":0,"stats":{"Line":0}},{"line":299,"address":[6405031],"length":1,"stats":{"Line":0}},{"line":303,"address":[9490064,9488027,9482560],"length":1,"stats":{"Line":0}},{"line":309,"address":[9482649,9482751],"length":1,"stats":{"Line":0}},{"line":310,"address":[9513752,9506601],"length":1,"stats":{"Line":0}},{"line":312,"address":[],"length":0,"stats":{"Line":0}},{"line":313,"address":[9042363,9049384],"length":1,"stats":{"Line":0}},{"line":316,"address":[9483041,9482926],"length":1,"stats":{"Line":0}},{"line":317,"address":[6408674,6414657,6414914],"length":1,"stats":{"Line":0}},{"line":318,"address":[],"length":0,"stats":{"Line":0}},{"line":319,"address":[9513076],"length":1,"stats":{"Line":0}},{"line":322,"address":[6408769],"length":1,"stats":{"Line":0}},{"line":323,"address":[6408784],"length":1,"stats":{"Line":0}},{"line":324,"address":[],"length":0,"stats":{"Line":0}},{"line":325,"address":[],"length":0,"stats":{"Line":0}},{"line":326,"address":[],"length":0,"stats":{"Line":0}},{"line":327,"address":[],"length":0,"stats":{"Line":0}},{"line":328,"address":[],"length":0,"stats":{"Line":0}},{"line":331,"address":[6409210,6409860],"length":1,"stats":{"Line":0}},{"line":332,"address":[],"length":0,"stats":{"Line":0}},{"line":333,"address":[6409996],"length":1,"stats":{"Line":0}},{"line":334,"address":[],"length":0,"stats":{"Line":0}},{"line":335,"address":[9508284],"length":1,"stats":{"Line":0}},{"line":339,"address":[],"length":0,"stats":{"Line":0}},{"line":340,"address":[9508244],"length":1,"stats":{"Line":0}},{"line":341,"address":[6410353,6410138,6410413],"length":1,"stats":{"Line":0}},{"line":342,"address":[6410460],"length":1,"stats":{"Line":0}},{"line":343,"address":[],"length":0,"stats":{"Line":0}},{"line":344,"address":[9508638],"length":1,"stats":{"Line":0}},{"line":349,"address":[9044566],"length":1,"stats":{"Line":0}},{"line":350,"address":[9044745,9044666,9045055],"length":1,"stats":{"Line":0}},{"line":351,"address":[],"length":0,"stats":{"Line":0}},{"line":352,"address":[],"length":0,"stats":{"Line":0}},{"line":356,"address":[9509836,9512605,9509290],"length":1,"stats":{"Line":0}},{"line":357,"address":[],"length":0,"stats":{"Line":0}},{"line":358,"address":[9045846],"length":1,"stats":{"Line":0}},{"line":359,"address":[9045910],"length":1,"stats":{"Line":0}},{"line":360,"address":[6412090],"length":1,"stats":{"Line":0}},{"line":361,"address":[9510313,9510390],"length":1,"stats":{"Line":0}},{"line":362,"address":[],"length":0,"stats":{"Line":0}},{"line":363,"address":[9046278,9046384],"length":1,"stats":{"Line":0}},{"line":365,"address":[6412557,6412441],"length":1,"stats":{"Line":0}},{"line":366,"address":[9046549,9046833,9046473],"length":1,"stats":{"Line":0}},{"line":368,"address":[6411883,6413665],"length":1,"stats":{"Line":0}},{"line":372,"address":[],"length":0,"stats":{"Line":0}},{"line":375,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":199},{"path":["/","home","vidyootsenthil","TheValut-nameTBD","node","src","start_node.rs"],"content":"use crate::{\n    NodeState,\n    errors::NodeError,\n    grpc::grpc_handler::NodeControlService,\n    key_manager::{get_config, get_key_file_path, load_and_decrypt_keypair},\n    swarm_manager::build_swarm,\n};\nuse std::path::{Path, PathBuf};\nuse tonic::transport::Server;\nuse tracing::{error, info};\nuse tracing_appender::rolling::{RollingFileAppender, Rotation};\nuse tracing_subscriber::{EnvFilter, fmt, prelude::*};\n\npub async fn start_node(\n    max_signers: Option<u16>,\n    min_signers: Option<u16>,\n    config_filepath: Option<String>,\n    grpc_port: Option<u16>,\n    log_file: Option<PathBuf>,\n) -> Result<(), NodeError> {\n    // Initialize logging\n    let env_filter = EnvFilter::try_from_default_env().unwrap_or_else(|_| EnvFilter::new(\"info\"));\n\n    let registry = tracing_subscriber::registry().with(env_filter);\n\n    let config = match get_config(config_filepath.clone()) {\n        Ok(config) => config,\n        Err(e) => {\n            error!(\"Failed to get config: {}\", e);\n            return Err(e);\n        }\n    };\n\n    if let Some(log_path) = config.log_file_path.clone().or(log_file) {\n        // File logging\n        let log_dir = Path::new(&log_path);\n\n        if !log_dir.exists() {\n            info!(\"Creating log directory: {:?}\", log_dir);\n            if let Err(e) = std::fs::create_dir_all(log_dir) {\n                error!(\n                    \"Failed to create log directory {}: {}\",\n                    log_dir.display(),\n                    e\n                );\n                return Err(NodeError::Error(e.to_string()));\n            }\n        }\n\n        let file_appender = RollingFileAppender::new(Rotation::DAILY, log_dir, \"node.log\");\n\n        let file_layer = fmt::layer()\n            .with_writer(file_appender)\n            .with_ansi(false)\n            .with_target(true)\n            .with_thread_ids(true)\n            .with_thread_names(true);\n\n        let console_layer = fmt::layer()\n            .with_writer(std::io::stdout)\n            .with_ansi(true)\n            .with_target(false);\n\n        registry.with(file_layer).with(console_layer).init();\n        info!(\n            \"Logging initialized with file output: {}\",\n            log_path.display()\n        );\n    } else {\n        // Console-only logging\n        let console_layer = fmt::layer()\n            .with_writer(std::io::stdout)\n            .with_ansi(true)\n            .with_target(false);\n\n        registry.with(console_layer).init();\n        info!(\"Logging initialized with console output only\");\n    }\n\n    let config_file_path = if let Some(path) = config_filepath.clone() {\n        path\n    } else {\n        match get_key_file_path() {\n            Ok(path) => path.to_string_lossy().to_string(),\n            Err(e) => {\n                error!(\"Failed to get config file path: {}\", e);\n                std::process::exit(1);\n            }\n        }\n    };\n\n    let keypair = match load_and_decrypt_keypair(&config) {\n        Ok(kp) => kp,\n        Err(e) => {\n            error!(\"Failed to decrypt key: {}\", e);\n            return Err(e);\n        }\n    };\n\n    let max_signers = max_signers.unwrap_or(5);\n    let min_signers = min_signers.unwrap_or(3);\n\n    let allowed_peers = config.allowed_peers;\n\n    let (network_handle, mut swarm, network_events_stream) =\n        build_swarm(keypair.clone(), allowed_peers.clone()).expect(\"Failed to build swarm\");\n\n    let mut node_state = NodeState::new_from_config(\n        network_handle,\n        allowed_peers,\n        min_signers,\n        max_signers,\n        config_file_path,\n        network_events_stream,\n    )\n    .expect(\"Failed to create node\");\n\n    let network_handle = node_state.network_handle.clone();\n\n    let swarm_handle = tokio::spawn(async move {\n        swarm.start().await;\n    });\n\n    let grpc_handle = tokio::spawn(async move {\n        let addr = format!(\"0.0.0.0:{}\", grpc_port.unwrap_or(50051))\n            .parse()\n            .unwrap();\n\n        let node_control_service = NodeControlService::new(network_handle);\n\n        info!(\"gRPC server listening on {}\", addr);\n\n        Server::builder()\n            .add_service(node_control_service.into_server())\n            .serve(addr)\n            .await\n            .expect(\"gRPC server failed\");\n    });\n\n    let main_loop_handle = tokio::spawn(async move { node_state.start().await });\n\n    // Wait for either task to complete (they should run indefinitely)\n    tokio::select! {\n        result = grpc_handle => {\n            match result {\n                Ok(_) => info!(\"gRPC server stopped\"),\n                Err(e) => error!(\"gRPC server error: {}\", e),\n            }\n        }\n        result = swarm_handle => {\n            match result {\n                Ok(_) => info!(\"Swarm stopped\"),\n                Err(e) => error!(\"Swarm error: {}\", e),\n            }\n        }\n        result = main_loop_handle => {\n            match result {\n                Ok(Ok(_)) => info!(\"Main loop stopped\"),\n                Ok(Err(e)) => error!(\"Main loop error: {}\", e),\n                Err(e) => error!(\"Main loop task error: {}\", e),\n            }\n        }\n    }\n\n    Ok(())\n}\n","traces":[{"line":14,"address":[9656864],"length":1,"stats":{"Line":0}},{"line":22,"address":[8760280,8780080,8780064,8760405],"length":1,"stats":{"Line":0}},{"line":24,"address":[8760536,8760454],"length":1,"stats":{"Line":0}},{"line":26,"address":[8920351,8920445],"length":1,"stats":{"Line":0}},{"line":27,"address":[8760912],"length":1,"stats":{"Line":0}},{"line":28,"address":[7339713],"length":1,"stats":{"Line":0}},{"line":29,"address":[8920541,8931469,8931103],"length":1,"stats":{"Line":0}},{"line":30,"address":[8931368],"length":1,"stats":{"Line":0}},{"line":34,"address":[8761049,8760967],"length":1,"stats":{"Line":0}},{"line":36,"address":[7340225,7340120],"length":1,"stats":{"Line":0}},{"line":38,"address":[8761333],"length":1,"stats":{"Line":0}},{"line":39,"address":[8921482,8921088,8921179],"length":1,"stats":{"Line":0}},{"line":40,"address":[8762244,8761732],"length":1,"stats":{"Line":0}},{"line":41,"address":[8238381],"length":1,"stats":{"Line":0}},{"line":46,"address":[8238779,8238169],"length":1,"stats":{"Line":0}},{"line":50,"address":[8921116,8923156],"length":1,"stats":{"Line":0}},{"line":52,"address":[8763452,8763571],"length":1,"stats":{"Line":0}},{"line":53,"address":[7342401],"length":1,"stats":{"Line":0}},{"line":59,"address":[7342603,7342667],"length":1,"stats":{"Line":0}},{"line":64,"address":[7342727],"length":1,"stats":{"Line":0}},{"line":65,"address":[8924316],"length":1,"stats":{"Line":0}},{"line":71,"address":[8924772],"length":1,"stats":{"Line":0}},{"line":76,"address":[7343979],"length":1,"stats":{"Line":0}},{"line":77,"address":[8240778],"length":1,"stats":{"Line":0}},{"line":80,"address":[8925743,8924694,8925891],"length":1,"stats":{"Line":0}},{"line":81,"address":[8766116],"length":1,"stats":{"Line":0}},{"line":83,"address":[7345038],"length":1,"stats":{"Line":0}},{"line":84,"address":[8766330],"length":1,"stats":{"Line":0}},{"line":85,"address":[8241771],"length":1,"stats":{"Line":0}},{"line":86,"address":[8766299,8770588,8770872],"length":1,"stats":{"Line":0}},{"line":87,"address":[8246357],"length":1,"stats":{"Line":0}},{"line":92,"address":[8242144,8241704],"length":1,"stats":{"Line":0}},{"line":93,"address":[8926429],"length":1,"stats":{"Line":0}},{"line":94,"address":[8926366],"length":1,"stats":{"Line":0}},{"line":95,"address":[8929371,8929722,8926398],"length":1,"stats":{"Line":0}},{"line":96,"address":[7348648],"length":1,"stats":{"Line":0}},{"line":100,"address":[8242332,8242437],"length":1,"stats":{"Line":0}},{"line":101,"address":[8242445],"length":1,"stats":{"Line":0}},{"line":103,"address":[8766987],"length":1,"stats":{"Line":0}},{"line":105,"address":[8927056],"length":1,"stats":{"Line":0}},{"line":109,"address":[8927259],"length":1,"stats":{"Line":0}},{"line":110,"address":[8243162],"length":1,"stats":{"Line":0}},{"line":113,"address":[8767711],"length":1,"stats":{"Line":0}},{"line":114,"address":[8927470],"length":1,"stats":{"Line":0}},{"line":118,"address":[8927773,8927680],"length":1,"stats":{"Line":0}},{"line":120,"address":[8780618,8780176,8780696,8768076,8768258,8780201,8780429,8780275],"length":1,"stats":{"Line":0}},{"line":121,"address":[7358999,7358915,7358814,7358858],"length":1,"stats":{"Line":0}},{"line":124,"address":[7361452,7347285,7359232,7359275,7347049,7359418,7361099],"length":1,"stats":{"Line":0}},{"line":125,"address":[8940515,8940695,8940909],"length":1,"stats":{"Line":0}},{"line":127,"address":[7359671,7359778],"length":1,"stats":{"Line":0}},{"line":129,"address":[8781273,8781436],"length":1,"stats":{"Line":0}},{"line":131,"address":[8257278,8257029,8256955],"length":1,"stats":{"Line":0}},{"line":133,"address":[8257252,8258350,8257927,8257724,8258048,8258292,8257986],"length":1,"stats":{"Line":0}},{"line":134,"address":[7360756],"length":1,"stats":{"Line":0}},{"line":135,"address":[8257954],"length":1,"stats":{"Line":0}},{"line":136,"address":[8362657],"length":1,"stats":{"Line":0}},{"line":137,"address":[8362710,8362745],"length":1,"stats":{"Line":0}},{"line":140,"address":[8259070,8244048,8258544,8244221,8258579,8258693,8258839],"length":1,"stats":{"Line":0}},{"line":143,"address":[8773219,8774315],"length":1,"stats":{"Line":0}},{"line":165,"address":[8773728],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":60},{"path":["/","home","vidyootsenthil","TheValut-nameTBD","node","src","swarm_manager.rs"],"content":"use futures::StreamExt;\nuse libp2p::{Multiaddr, PeerId, request_response::ResponseChannel, swarm::SwarmEvent};\nuse std::{\n    collections::{BTreeMap, HashSet, hash_map::DefaultHasher},\n    fmt::Debug,\n    future::Future,\n    hash::{Hash, Hasher},\n    pin::Pin,\n    time::Duration,\n};\nuse tracing::info;\n\nuse frost_secp256k1::keys::dkg::round2;\nuse libp2p::{\n    StreamProtocol, Swarm, gossipsub, mdns, noise, request_response, swarm::NetworkBehaviour, tcp,\n    yamux,\n};\nuse libp2p::{identity::Keypair, request_response::cbor};\nuse tokio::{\n    io,\n    sync::mpsc::{self, UnboundedReceiver, unbounded_channel},\n};\n\nuse crate::{\n    PeerData,\n    errors::{NetworkError, NodeError},\n    protocol::block::Block,\n};\n\n#[derive(Clone, Debug, serde::Serialize, serde::Deserialize)]\npub struct PingBody {\n    pub message: String,\n}\n\n#[derive(Clone, Debug, serde::Serialize, serde::Deserialize)]\npub enum PrivateRequest {\n    Ping(PingBody),\n    Round2Package(round2::Package),\n    SignRequest { sign_id: u64, message: Vec<u8> },\n    SignPackage { sign_id: u64, package: Vec<u8> },\n    InsertBlock { block: Block },\n    StartSigningSession { hex_message: String },\n    Spend { amount_sat: u64 },\n    GetFrostPublicKey,\n}\n\n#[derive(Clone, Debug, serde::Serialize, serde::Deserialize)]\npub enum PrivateResponse {\n    Pong,\n    Commitments {\n        sign_id: u64,\n        commitments: Vec<u8>,\n    },\n    SignatureShare {\n        sign_id: u64,\n        signature_share: Vec<u8>,\n    },\n\n    StartSigningSession {\n        sign_id: u64,\n    },\n    SpendRequestSent {\n        sighash: String,\n    },\n    GetFrostPublicKey {\n        public_key: String,\n    },\n}\n\n#[derive(NetworkBehaviour)]\npub struct MyBehaviour {\n    pub gossipsub: gossipsub::Behaviour,\n    pub mdns: mdns::tokio::Behaviour,\n    pub request_response: cbor::Behaviour<PrivateRequest, PrivateResponse>,\n}\n\npub enum NetworkMessage {\n    SendBroadcast {\n        topic: gossipsub::IdentTopic,\n        message: Vec<u8>,\n    },\n    SendPrivateRequest(PeerId, PrivateRequest),\n    SendPrivateResponse(ResponseChannel<PrivateResponse>, PrivateResponse),\n    SendSelfRequest {\n        request: PrivateRequest,\n        response_channel: Option<mpsc::UnboundedSender<PrivateResponse>>,\n    },\n}\n\ntype NetworkResponseFuture =\n    Pin<Box<dyn Future<Output = Result<PrivateResponse, NetworkError>> + Send>>;\n\n#[derive(Debug, Clone)]\npub struct NetworkHandle {\n    peer_id: PeerId,\n    tx: mpsc::UnboundedSender<NetworkMessage>,\n}\n\npub trait Network: Clone + Debug {\n    fn peer_id(&self) -> PeerId;\n    fn send_broadcast(\n        &self,\n        topic: gossipsub::IdentTopic,\n        message: Vec<u8>,\n    ) -> Result<(), NetworkError>;\n    fn send_private_request(\n        &self,\n        peer_id: PeerId,\n        request: PrivateRequest,\n    ) -> Result<(), NetworkError>;\n    fn send_private_response(\n        &self,\n        channel: ResponseChannel<PrivateResponse>,\n        response: PrivateResponse,\n    ) -> Result<(), NetworkError>;\n    fn send_self_request(\n        &self,\n        request: PrivateRequest,\n        sync: bool,\n    ) -> Result<Option<NetworkResponseFuture>, NetworkError>;\n}\n\nimpl Network for NetworkHandle {\n    fn peer_id(&self) -> PeerId {\n        self.peer_id\n    }\n\n    fn send_broadcast(\n        &self,\n        topic: gossipsub::IdentTopic,\n        message: Vec<u8>,\n    ) -> Result<(), NetworkError> {\n        let network_message = NetworkMessage::SendBroadcast { topic, message };\n        self.tx\n            .send(network_message)\n            .map_err(|e| NetworkError::SendError(e.to_string()))\n    }\n\n    fn send_private_request(\n        &self,\n        peer_id: PeerId,\n        request: PrivateRequest,\n    ) -> Result<(), NetworkError> {\n        let network_message = NetworkMessage::SendPrivateRequest(peer_id, request);\n        self.tx\n            .send(network_message)\n            .map_err(|e| NetworkError::SendError(e.to_string()))\n    }\n\n    fn send_private_response(\n        &self,\n        channel: ResponseChannel<PrivateResponse>,\n        response: PrivateResponse,\n    ) -> Result<(), NetworkError> {\n        let network_message = NetworkMessage::SendPrivateResponse(channel, response);\n        self.tx\n            .send(network_message)\n            .map_err(|e| NetworkError::SendError(e.to_string()))\n    }\n\n    fn send_self_request(\n        &self,\n        request: PrivateRequest,\n        sync: bool,\n    ) -> Result<Option<NetworkResponseFuture>, NetworkError> {\n        if sync {\n            let (tx, mut rx) = unbounded_channel::<PrivateResponse>();\n\n            let network_message = NetworkMessage::SendSelfRequest {\n                request,\n                response_channel: Some(tx),\n            };\n\n            self.tx\n                .send(network_message)\n                .map_err(|e| NetworkError::SendError(e.to_string()))?;\n\n            Ok(Some(Box::pin(async move {\n                rx.recv().await.ok_or(NetworkError::RecvError)\n            })))\n        } else {\n            let network_message = NetworkMessage::SendSelfRequest {\n                request,\n                response_channel: None,\n            };\n\n            self.tx\n                .send(network_message)\n                .map_err(|e| NetworkError::SendError(e.to_string()))?;\n\n            Ok(None)\n        }\n    }\n}\n\npub enum NetworkEvent {\n    // SwarmEvent(SwarmEvent<MyBehaviourEvent>),\n    // NetworkMessage(NetworkMessage),\n    SelfRequest {\n        request: PrivateRequest,\n        response_channel: Option<mpsc::UnboundedSender<PrivateResponse>>,\n    },\n\n    GossipsubMessage(gossipsub::Message),\n    MessageEvent(request_response::Event<PrivateRequest, PrivateResponse>),\n\n    PeersConnected(Vec<(PeerId, Multiaddr)>),\n    PeersDisconnected(Vec<(PeerId, Multiaddr)>),\n}\n\npub struct SwarmManager {\n    pub inner: Swarm<MyBehaviour>,\n\n    pub network_manager_rx: mpsc::UnboundedReceiver<NetworkMessage>,\n    pub network_events: mpsc::UnboundedSender<NetworkEvent>,\n\n    pub allowed_peers: Vec<PeerId>,\n    pub peers_to_names: BTreeMap<PeerId, String>,\n\n    pub live_peers: HashSet<PeerId>,\n\n    pub round1_topic: gossipsub::IdentTopic,\n    pub start_dkg_topic: gossipsub::IdentTopic,\n}\n\nimpl SwarmManager {\n    pub fn new(\n        mut swarm: Swarm<MyBehaviour>,\n        peer_data: Vec<PeerData>,\n    ) -> Result<(Self, NetworkHandle, UnboundedReceiver<NetworkEvent>), NodeError> {\n        let (send_commands, receiving_commands) = unbounded_channel::<NetworkMessage>();\n\n        let (network_events_emitter, network_events_stream) = unbounded_channel::<NetworkEvent>();\n\n        let network_handle = NetworkHandle {\n            peer_id: *swarm.local_peer_id(),\n            tx: send_commands,\n        };\n\n        // Read full lines from stdin\n        let round1_topic = gossipsub::IdentTopic::new(\"round1_topic\");\n        swarm\n            .behaviour_mut()\n            .gossipsub\n            .subscribe(&round1_topic)\n            .map_err(|e| NodeError::Error(e.to_string()))?;\n\n        let allowed_peers: Vec<PeerId> = peer_data\n            .iter()\n            .map(|peer| peer.public_key.parse().unwrap())\n            .collect();\n\n        let peers_to_names: BTreeMap<PeerId, String> = peer_data\n            .iter()\n            .map(|peer| (peer.public_key.parse().unwrap(), peer.name.clone()))\n            .collect();\n\n        let start_dkg_topic = gossipsub::IdentTopic::new(\"start-dkg\");\n        swarm\n            .behaviour_mut()\n            .gossipsub\n            .subscribe(&start_dkg_topic)\n            .map_err(|e| NodeError::Error(e.to_string()))?;\n\n        Ok((\n            Self {\n                round1_topic,\n                live_peers: HashSet::new(),\n                start_dkg_topic,\n                inner: swarm,\n                network_manager_rx: receiving_commands,\n                network_events: network_events_emitter,\n                allowed_peers,\n                peers_to_names,\n            },\n            network_handle,\n            network_events_stream,\n        ))\n    }\n\n    pub fn peer_name(&self, peer_id: &PeerId) -> String {\n        self.peers_to_names\n            .get(peer_id)\n            .unwrap_or(&peer_id.to_string())\n            .clone()\n    }\n\n    pub async fn start(&mut self) {\n        info!(\"Starting swarm manager\");\n        loop {\n            tokio::select! {\n                send_message = self.network_manager_rx.recv() => match send_message {\n                    Some(NetworkMessage::SendBroadcast { topic, message }) => {\n                        let _ = self.inner\n                            .behaviour_mut()\n                            .gossipsub\n                            .publish(topic, message);\n                    }\n                    Some(NetworkMessage::SendPrivateRequest(peer_id, request)) => {\n                        self.inner\n                            .behaviour_mut()\n                            .request_response\n                            .send_request(&peer_id, request);\n                    }\n                    Some(NetworkMessage::SendPrivateResponse(channel, response)) => {\n                        let _ = self.inner\n                            .behaviour_mut()\n                            .request_response\n                            .send_response(channel, response);\n                    }\n                    Some(NetworkMessage::SendSelfRequest { request, response_channel }) => {\n                        self.network_events.send(NetworkEvent::SelfRequest { request, response_channel } ).unwrap();\n                    }\n                    _ => {\n                    }\n                },\n                event = self.inner.select_next_some() => {\n                    match event {\n                        SwarmEvent::Behaviour(MyBehaviourEvent::Mdns(mdns::Event::Discovered(list))) => {\n                            let mut peers_connected = vec![];\n                            for (peer_id, multiaddr) in list {\n                                if self.allowed_peers.contains(&peer_id) {\n                                    info!(\"Discovered peer: {}\", self.peer_name(&peer_id));\n                                    peers_connected.push((peer_id, multiaddr));\n                                    self.live_peers.insert(peer_id);\n                                    self.inner.behaviour_mut().gossipsub.add_explicit_peer(&peer_id);\n                                }\n                            }\n                            self.network_events.send(NetworkEvent::PeersConnected(peers_connected)).unwrap();\n                        },\n                        SwarmEvent::Behaviour(MyBehaviourEvent::Mdns(mdns::Event::Expired(list))) => {\n                            for (peer_id, _multiaddr) in list.clone() {\n                                if self.allowed_peers.contains(&peer_id) {\n                                    info!(\"Peer expired: {}\", self.peer_name(&peer_id));\n                                    self.live_peers.retain(|p| p != &peer_id);\n                                    self.inner.behaviour_mut().gossipsub.remove_explicit_peer(&peer_id);\n                                }\n                            }\n                            self.network_events.send(NetworkEvent::PeersDisconnected(list)).unwrap();\n                        },\n                        SwarmEvent::Behaviour(MyBehaviourEvent::Gossipsub(gossipsub::Event::Message {\n                            message,\n                            ..\n                        })) => {\n                            self.network_events.send(NetworkEvent::GossipsubMessage(message.clone())).unwrap();\n                        },\n                        SwarmEvent::Behaviour(MyBehaviourEvent::RequestResponse(message) ) => {\n                            self.network_events.send(NetworkEvent::MessageEvent(message)).unwrap();\n                        },\n                        _ => {\n                            // self.network_events.send(NetworkEvent::SwarmEvent(event)).unwrap();\n                        }\n                    }\n                }\n\n            }\n        }\n    }\n}\n\npub fn build_swarm(\n    keypair: Keypair,\n    peer_data: Vec<PeerData>,\n) -> Result<(NetworkHandle, SwarmManager, UnboundedReceiver<NetworkEvent>), NodeError> {\n    let mut swarm = libp2p::SwarmBuilder::with_existing_identity(keypair)\n        .with_tokio()\n        .with_tcp(\n            tcp::Config::default(),\n            noise::Config::new,\n            yamux::Config::default,\n        )\n        .map_err(|e| NodeError::Error(format!(\"Failed to add tcp {}\", e)))?\n        .with_quic()\n        .with_behaviour(|key| {\n            // To content-address message, we can take the hash of message and use it as an ID.\n            let message_id_fn = |message: &gossipsub::Message| {\n                let mut s = DefaultHasher::new();\n                message.data.hash(&mut s);\n                gossipsub::MessageId::from(s.finish().to_string())\n            };\n\n            let gossipsub_config = gossipsub::ConfigBuilder::default()\n                .heartbeat_interval(Duration::from_secs(10)) // This is set to aid debugging by not cluttering the log space\n                .validation_mode(gossipsub::ValidationMode::Strict) // This sets the kind of message validation. The default is Strict (enforce message signing)\n                .message_id_fn(message_id_fn) // content-address messages. No two messages of the same content will be propagated.\n                .mesh_n_low(1) // Minimum number of peers in mesh network (default is 4)\n                .mesh_n_high(12) // Maximum number of peers in mesh network\n                .mesh_n(3) // Target number of peers in mesh network (default is 6)\n                .mesh_outbound_min(1) // Minimum outbound connections (default is 2)\n                .gossip_lazy(3) // Number of peers to gossip to (default is 6)\n                .flood_publish(true) // Always flood publish messages to all peers, regardless of mesh\n                .build()\n                .map_err(io::Error::other)?; // Temporary hack because `build` does not return a proper `std::error::Error`.\n\n            let gossipsub = gossipsub::Behaviour::new(\n                gossipsub::MessageAuthenticity::Signed(key.clone()),\n                gossipsub_config,\n            )?;\n\n            let mdns =\n                mdns::tokio::Behaviour::new(mdns::Config::default(), key.public().to_peer_id())?;\n\n            let request_response = cbor::Behaviour::new(\n                [(\n                    StreamProtocol::new(\"/direct-message/1.0.0\"),\n                    request_response::ProtocolSupport::Full,\n                )],\n                request_response::Config::default(),\n            );\n\n            Ok(MyBehaviour {\n                gossipsub,\n                mdns,\n                request_response,\n            })\n        })\n        .map_err(|e| NodeError::Error(format!(\"Failed to add behaviour {}\", e)))?\n        .with_swarm_config(|c| c.with_idle_connection_timeout(Duration::from_secs(60)))\n        .build();\n\n    swarm\n        .listen_on(\n            \"/ip4/0.0.0.0/udp/0/quic-v1\"\n                .parse()\n                .expect(\"Failed to deserialize message\"),\n        )\n        .map_err(|e| NodeError::Error(format!(\"Failed to listen on quic {}\", e)))?;\n\n    swarm\n        .listen_on(\n            \"/ip4/0.0.0.0/tcp/0\"\n                .parse()\n                .expect(\"Failed to deserialize message\"),\n        )\n        .map_err(|e| NodeError::Error(format!(\"Failed to listen on tcp {}\", e)))?;\n\n    let (swarm_manager, network, network_events_stream) = SwarmManager::new(swarm, peer_data)\n        .map_err(|e| NodeError::Error(format!(\"Failed to create swarm manager: {}\", e)))?;\n\n    Ok((network, swarm_manager, network_events_stream))\n}\n","traces":[{"line":124,"address":[7836240],"length":1,"stats":{"Line":0}},{"line":125,"address":[7350481],"length":1,"stats":{"Line":0}},{"line":128,"address":[10328688],"length":1,"stats":{"Line":0}},{"line":133,"address":[7179368],"length":1,"stats":{"Line":0}},{"line":134,"address":[10328779],"length":1,"stats":{"Line":0}},{"line":136,"address":[9593618,9593600],"length":1,"stats":{"Line":0}},{"line":139,"address":[7179488],"length":1,"stats":{"Line":0}},{"line":144,"address":[10328880],"length":1,"stats":{"Line":0}},{"line":145,"address":[7179580],"length":1,"stats":{"Line":0}},{"line":147,"address":[6622690,6622672],"length":1,"stats":{"Line":0}},{"line":150,"address":[10328976],"length":1,"stats":{"Line":0}},{"line":155,"address":[7350851],"length":1,"stats":{"Line":0}},{"line":156,"address":[7350895],"length":1,"stats":{"Line":0}},{"line":158,"address":[6663904,6663927],"length":1,"stats":{"Line":0}},{"line":161,"address":[7352394,7350960,7352369],"length":1,"stats":{"Line":0}},{"line":166,"address":[7352274,7351009],"length":1,"stats":{"Line":0}},{"line":167,"address":[10329511,10329819],"length":1,"stats":{"Line":0}},{"line":171,"address":[7180592],"length":1,"stats":{"Line":0}},{"line":174,"address":[10330284,10330091,10330156],"length":1,"stats":{"Line":0}},{"line":176,"address":[10330252],"length":1,"stats":{"Line":0}},{"line":178,"address":[7837861],"length":1,"stats":{"Line":0}},{"line":179,"address":[6623237,6623392,6623189,6623288],"length":1,"stats":{"Line":0}},{"line":187,"address":[7351528,7351400,7351308,7351621],"length":1,"stats":{"Line":0}},{"line":189,"address":[7180328],"length":1,"stats":{"Line":0}},{"line":191,"address":[10329735],"length":1,"stats":{"Line":0}},{"line":227,"address":[7181264,7184080,7183741],"length":1,"stats":{"Line":0}},{"line":231,"address":[7181482,7181363],"length":1,"stats":{"Line":0}},{"line":233,"address":[10330945,10330850],"length":1,"stats":{"Line":0}},{"line":236,"address":[7181688,7181617],"length":1,"stats":{"Line":0}},{"line":241,"address":[7181851],"length":1,"stats":{"Line":0}},{"line":242,"address":[7838981,7838851,7838766,7840551],"length":1,"stats":{"Line":0}},{"line":246,"address":[7838949],"length":1,"stats":{"Line":0}},{"line":248,"address":[10331560],"length":1,"stats":{"Line":0}},{"line":250,"address":[6624048,6624091],"length":1,"stats":{"Line":0}},{"line":253,"address":[7182366,7182441],"length":1,"stats":{"Line":0}},{"line":255,"address":[9595276,9595232],"length":1,"stats":{"Line":0}},{"line":258,"address":[7182522],"length":1,"stats":{"Line":0}},{"line":259,"address":[10331949,10332011,10332169],"length":1,"stats":{"Line":0}},{"line":263,"address":[10332137],"length":1,"stats":{"Line":0}},{"line":265,"address":[7183513],"length":1,"stats":{"Line":0}},{"line":266,"address":[7354340],"length":1,"stats":{"Line":0}},{"line":267,"address":[7182868],"length":1,"stats":{"Line":0}},{"line":268,"address":[10332252],"length":1,"stats":{"Line":0}},{"line":269,"address":[7182979],"length":1,"stats":{"Line":0}},{"line":270,"address":[10332355],"length":1,"stats":{"Line":0}},{"line":271,"address":[7354237],"length":1,"stats":{"Line":0}},{"line":272,"address":[7354250],"length":1,"stats":{"Line":0}},{"line":273,"address":[10332439],"length":1,"stats":{"Line":0}},{"line":274,"address":[10332471],"length":1,"stats":{"Line":0}},{"line":276,"address":[7354554],"length":1,"stats":{"Line":0}},{"line":277,"address":[7183482],"length":1,"stats":{"Line":0}},{"line":281,"address":[10333456,10333651,10333657],"length":1,"stats":{"Line":0}},{"line":282,"address":[10333619,10333506,10333561],"length":1,"stats":{"Line":0}},{"line":284,"address":[7355356],"length":1,"stats":{"Line":0}},{"line":288,"address":[6665518,6666619,6665852,6668487,6665472,6665820],"length":1,"stats":{"Line":0}},{"line":289,"address":[9595888,9596002,9596304],"length":1,"stats":{"Line":0}},{"line":290,"address":[6669768],"length":1,"stats":{"Line":0}},{"line":291,"address":[5654607,5654596,5654653],"length":1,"stats":{"Line":0}},{"line":361,"address":[10335694,10333712,10335739],"length":1,"stats":{"Line":0}},{"line":365,"address":[10333856,10333764,10333999,10334392,10335700,10334118,10333948],"length":1,"stats":{"Line":0}},{"line":368,"address":[7841235],"length":1,"stats":{"Line":0}},{"line":372,"address":[10334086],"length":1,"stats":{"Line":0}},{"line":374,"address":[6677808,6675872,6677775],"length":1,"stats":{"Line":0}},{"line":376,"address":[6464160,6466064],"length":1,"stats":{"Line":0}},{"line":377,"address":[6466102],"length":1,"stats":{"Line":0}},{"line":378,"address":[6466117],"length":1,"stats":{"Line":0}},{"line":379,"address":[6677924],"length":1,"stats":{"Line":0}},{"line":382,"address":[6464176,6464671,6464322,6464279],"length":1,"stats":{"Line":0}},{"line":383,"address":[6464198],"length":1,"stats":{"Line":0}},{"line":384,"address":[6464314],"length":1,"stats":{"Line":0}},{"line":393,"address":[6677840,6676076,6676499,6676610],"length":1,"stats":{"Line":0}},{"line":395,"address":[6677806,6676802,6676900],"length":1,"stats":{"Line":0}},{"line":396,"address":[6636014],"length":1,"stats":{"Line":0}},{"line":397,"address":[6636073],"length":1,"stats":{"Line":0}},{"line":401,"address":[9607399,9607470],"length":1,"stats":{"Line":0}},{"line":403,"address":[6677516],"length":1,"stats":{"Line":0}},{"line":405,"address":[6636647],"length":1,"stats":{"Line":0}},{"line":406,"address":[6465554],"length":1,"stats":{"Line":0}},{"line":408,"address":[9607888],"length":1,"stats":{"Line":0}},{"line":411,"address":[6636979],"length":1,"stats":{"Line":0}},{"line":412,"address":[9607999],"length":1,"stats":{"Line":0}},{"line":413,"address":[9608025],"length":1,"stats":{"Line":0}},{"line":417,"address":[7185016],"length":1,"stats":{"Line":0}},{"line":418,"address":[6637645,6637632],"length":1,"stats":{"Line":0}},{"line":421,"address":[10334672,10334824,10335637],"length":1,"stats":{"Line":0}},{"line":423,"address":[7841924,7841852],"length":1,"stats":{"Line":0}},{"line":427,"address":[6466656,6466682],"length":1,"stats":{"Line":0}},{"line":429,"address":[10334948,10335100,10335635],"length":1,"stats":{"Line":0}},{"line":431,"address":[10334869],"length":1,"stats":{"Line":0}},{"line":435,"address":[9609152,9609178],"length":1,"stats":{"Line":0}},{"line":437,"address":[10335621,10335145,10335372],"length":1,"stats":{"Line":0}},{"line":438,"address":[7357164],"length":1,"stats":{"Line":0}},{"line":440,"address":[7186162],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":93},{"path":["/","home","vidyootsenthil","TheValut-nameTBD","node","src","wallet.rs"],"content":"use bitcoin::absolute::LockTime;\nuse bitcoin::consensus::encode::serialize;\nuse bitcoin::hashes::Hash;\nuse bitcoin::transaction::{OutPoint, Version};\nuse bitcoin::witness::Witness;\nuse bitcoin::{Amount, ScriptBuf, Transaction, TxIn, TxOut, hashes::sha256};\nuse hex;\nuse tracing::{error, info};\n\nuse crate::{Network, NodeState};\nuse frost_secp256k1::{self as frost};\n\n/// Very simple demonstration UTXO representation (key-path Taproot assumed)\n#[derive(Debug, Clone)]\npub struct Utxo {\n    pub outpoint: OutPoint,\n    pub value: Amount,\n    pub script_pubkey: ScriptBuf,\n}\n\n/// Wallet that only tracks a list of local UTXOs and is able to construct a\n/// single-input spending transaction that possibly creates a change output. No\n/// fee calculation is performed – this is purely for demonstration purposes.\n#[derive(Debug)]\npub struct SimpleWallet {\n    pub utxos: Vec<Utxo>,\n}\n\nimpl Default for SimpleWallet {\n    fn default() -> Self {\n        Self::new()\n    }\n}\n\nimpl SimpleWallet {\n    pub fn new() -> Self {\n        Self {\n            utxos: vec![\n                Utxo {\n                    outpoint: OutPoint {\n                        txid: bitcoin::Txid::from_slice(&[0u8; 32]).expect(\"Failed to create UTXO\"),\n                        vout: 0,\n                    },\n                    value: Amount::from_sat(100_000),\n                    script_pubkey: ScriptBuf::new(),\n                },\n                Utxo {\n                    outpoint: OutPoint {\n                        txid: bitcoin::Txid::from_slice(&[1u8; 32]).expect(\"Failed to create UTXO\"),\n                        vout: 0,\n                    },\n                    value: Amount::from_sat(50_000),\n                    script_pubkey: ScriptBuf::new(),\n                },\n                Utxo {\n                    outpoint: OutPoint {\n                        txid: bitcoin::Txid::from_slice(&[2u8; 32]).expect(\"Failed to create UTXO\"),\n                        vout: 0,\n                    },\n                    value: Amount::from_sat(20_000),\n                    script_pubkey: ScriptBuf::new(),\n                },\n            ],\n        }\n    }\n\n    pub fn create_spend(&mut self, amount_sat: u64) -> Result<(Transaction, [u8; 32]), String> {\n        let pos = self\n            .utxos\n            .iter()\n            .position(|u| u.value.to_sat() >= amount_sat)\n            .ok_or_else(|| {\n                \"No single UTXO large enough – coin selection not implemented\".to_string()\n            })?;\n\n        let utxo = self.utxos.remove(pos);\n        let change_sat = utxo.value.to_sat() - amount_sat;\n\n        let input = TxIn {\n            previous_output: utxo.outpoint,\n            script_sig: ScriptBuf::new(),\n            sequence: bitcoin::Sequence::ZERO,\n            witness: Witness::new(),\n        };\n\n        let recipient_output = TxOut {\n            value: Amount::from_sat(amount_sat),\n            script_pubkey: ScriptBuf::new(),\n        };\n\n        let mut outputs = vec![recipient_output];\n\n        // Add change output if needed\n        if change_sat > 0 {\n            outputs.push(TxOut {\n                value: Amount::from_sat(change_sat),\n                script_pubkey: ScriptBuf::new(),\n            });\n        }\n\n        let tx = Transaction {\n            version: Version::TWO,\n            lock_time: LockTime::ZERO,\n            input: vec![input],\n            output: outputs,\n        };\n\n        let sighash = sha256::Hash::hash(&serialize(&tx));\n        Ok((tx, sighash.to_byte_array()))\n    }\n}\n\n#[derive(Debug)]\npub struct PendingSpend {\n    pub tx: Transaction,\n}\n\nimpl<N: Network> NodeState<N> {\n    pub fn get_frost_public_key(&self) -> Option<String> {\n        self.dkg_state.pubkey_package.as_ref().map(|p| {\n            format!(\"{:?}\", p.verifying_key())\n                .replace(\"VerifyingKey(\", \"\")\n                .replace(\")\", \"\")\n                .replace(\"\\\\\", \"\")\n                .replace(\"\\\"\", \"\")\n        })\n    }\n\n    pub fn frost_signature_to_bitcoin(\n        frost_sig: &frost::Signature,\n    ) -> Result<bitcoin::secp256k1::schnorr::Signature, String> {\n        let sig_bytes = frost_sig\n            .serialize()\n            .map_err(|e| format!(\"Serialize frost sig: {}\", e))?;\n\n        let schnorr_bytes = match sig_bytes.len() {\n            64 => sig_bytes,\n            65 => sig_bytes[..64].to_vec(),\n            _ => return Err(format!(\"Unsupported signature len {}\", sig_bytes.len())),\n        };\n\n        bitcoin::secp256k1::schnorr::Signature::from_slice(&schnorr_bytes)\n            .map_err(|e| format!(\"Parse schnorr sig: {}\", e))\n    }\n\n    pub fn start_spend_request(&mut self, amount_sat: u64) -> Option<String> {\n        info!(\"🚀 Creating spend request for {} sat\", amount_sat);\n        match self.wallet.create_spend(amount_sat) {\n            Ok((tx, sighash)) => {\n                let sighash_hex = hex::encode(sighash);\n                match self.start_signing_session(&sighash_hex) {\n                    Ok(_) => (),\n                    Err(e) => {\n                        error!(\"❌ Failed to start signing session: {}\", e);\n                        return None;\n                    }\n                }\n\n                if let Some(active) = &self.active_signing {\n                    self.pending_spends\n                        .insert(active.sign_id, crate::wallet::PendingSpend { tx });\n                    info!(\"🚀 Spend request prepared (session id {})\", active.sign_id);\n\n                    Some(hex::encode(sighash))\n                } else {\n                    error!(\"❌ Failed to start signing session\");\n                    None\n                }\n            }\n            Err(e) => {\n                error!(\"❌ Failed to create spend transaction: {}\", e);\n                None\n            }\n        }\n    }\n}\n","traces":[{"line":30,"address":[11136896],"length":1,"stats":{"Line":0}},{"line":31,"address":[11136904],"length":1,"stats":{"Line":0}},{"line":36,"address":[11138025,11138031,11136928],"length":1,"stats":{"Line":0}},{"line":38,"address":[11136955,11138012,11137808,11137264,11137548,11136992],"length":1,"stats":{"Line":0}},{"line":67,"address":[7990987,7988704,7990893],"length":1,"stats":{"Line":0}},{"line":68,"address":[11138091,11138284],"length":1,"stats":{"Line":0}},{"line":71,"address":[6432048,6432066],"length":1,"stats":{"Line":0}},{"line":72,"address":[9574336],"length":1,"stats":{"Line":0}},{"line":73,"address":[6603276],"length":1,"stats":{"Line":0}},{"line":76,"address":[8160152],"length":1,"stats":{"Line":0}},{"line":77,"address":[11138425,11138352,11138520],"length":1,"stats":{"Line":0}},{"line":80,"address":[8160283],"length":1,"stats":{"Line":0}},{"line":81,"address":[8160337],"length":1,"stats":{"Line":0}},{"line":83,"address":[11138548],"length":1,"stats":{"Line":0}},{"line":87,"address":[7989400],"length":1,"stats":{"Line":0}},{"line":88,"address":[11138814],"length":1,"stats":{"Line":0}},{"line":91,"address":[8160708,8160766],"length":1,"stats":{"Line":0}},{"line":94,"address":[7989803],"length":1,"stats":{"Line":0}},{"line":95,"address":[11139260],"length":1,"stats":{"Line":0}},{"line":96,"address":[8161007],"length":1,"stats":{"Line":0}},{"line":97,"address":[8161072],"length":1,"stats":{"Line":0}},{"line":104,"address":[8160987,8161163],"length":1,"stats":{"Line":0}},{"line":108,"address":[11139774,11139706],"length":1,"stats":{"Line":0}},{"line":109,"address":[11139890],"length":1,"stats":{"Line":0}},{"line":119,"address":[9513856],"length":1,"stats":{"Line":0}},{"line":120,"address":[6604060,6604066,6603312],"length":1,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[8806771,8806678,8806436,8806560,8806309],"length":1,"stats":{"Line":0}},{"line":129,"address":[6416380,6416594,6415744],"length":1,"stats":{"Line":0}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":134,"address":[9049768],"length":1,"stats":{"Line":0}},{"line":136,"address":[9049893,9049960],"length":1,"stats":{"Line":0}},{"line":137,"address":[9490501],"length":1,"stats":{"Line":0}},{"line":138,"address":[9514326,9514402],"length":1,"stats":{"Line":0}},{"line":139,"address":[9049981,9050319],"length":1,"stats":{"Line":0}},{"line":142,"address":[9050092,9050212],"length":1,"stats":{"Line":0}},{"line":143,"address":[6433064,6433040],"length":1,"stats":{"Line":0}},{"line":146,"address":[9491056,9495154,9495160],"length":1,"stats":{"Line":0}},{"line":147,"address":[9491103,9491370],"length":1,"stats":{"Line":0}},{"line":148,"address":[6416863],"length":1,"stats":{"Line":0}},{"line":149,"address":[9515647],"length":1,"stats":{"Line":0}},{"line":150,"address":[9515751],"length":1,"stats":{"Line":0}},{"line":151,"address":[6417741,6417645],"length":1,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[9516003],"length":1,"stats":{"Line":0}},{"line":154,"address":[6420148,6419886,6417817],"length":1,"stats":{"Line":0}},{"line":155,"address":[9494593],"length":1,"stats":{"Line":0}},{"line":159,"address":[],"length":0,"stats":{"Line":0}},{"line":160,"address":[9516155,9516305],"length":1,"stats":{"Line":0}},{"line":161,"address":[9516162,9516363],"length":1,"stats":{"Line":0}},{"line":162,"address":[9052110,9052472],"length":1,"stats":{"Line":0}},{"line":164,"address":[9492906,9493449],"length":1,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":167,"address":[9053290],"length":1,"stats":{"Line":0}},{"line":170,"address":[6417374],"length":1,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":172,"address":[],"length":0,"stats":{"Line":0}}],"covered":0,"coverable":60},{"path":["/","home","vidyootsenthil","TheValut-nameTBD","node","tests","config.rs"],"content":"#[cfg(test)]\nmod config_test {\n    use node::Config;\n\n    #[test]\n    fn test_config_deserialization() {\n        let json_str = r#\"{\n            \"allowed_peers\": [\n                {\n                    \"public_key\": \"12D3KooWRdtE2nFybk8eMyp3D9B4NvunUYqpN6JDvBcVPTcrDsbF\",\n                    \"name\": \"node-four\"\n                }\n            ],\n            \"key_data\": {\n                \"public_key_b58\": \"12D3KooWQDHzW448RmDoUz1KbMfuD4XqeojRJDsxqUZSEYo7FSUz\",\n                \"encrypted_private_key_b64\": \"EnCF8bEe3tVyMV0EUIK29bOMNjH7gT7mx4ATyBr4WSdphw5ETfm1YdQHDAg+CzBBjt7K2FSbwv8Qkj1y3N4jTU/FkGHggfkwDDl5XkDc5rXi2BW/\",\n                \"encryption_params\": {\n                    \"kdf\": \"argon2id\",\n                    \"salt_b64\": \"TnErEFlx9F1BeU8mJcFzKQ\",\n                    \"iv_b64\": \"hybTge0qoPaxNUhP\"\n                }\n            }\n        }\"#;\n\n        let config: Config = serde_json::from_str(json_str).expect(\"Failed to deserialize\");\n        assert_eq!(config.allowed_peers.len(), 1);\n        assert_eq!(\n            config.key_data.public_key_b58,\n            \"12D3KooWQDHzW448RmDoUz1KbMfuD4XqeojRJDsxqUZSEYo7FSUz\"\n        );\n        assert!(config.dkg_keys.is_none());\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","vidyootsenthil","TheValut-nameTBD","node","tests","mod.rs"],"content":"pub mod protocol;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","vidyootsenthil","TheValut-nameTBD","node","tests","protocol","block.rs"],"content":"#[cfg(test)]\nmod block_test {\n    use node::protocol::block::Block;\n\n    #[test]\n    fn test_block_creation_and_hashing() {\n        let block = Block::new([0u8; 32], 1, vec![], vec![1, 2, 3]);\n\n        let hash1 = block.hash();\n        let hash2 = block.hash();\n        assert_eq!(hash1, hash2); // Hash should be deterministic\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","vidyootsenthil","TheValut-nameTBD","node","tests","protocol","deposits.rs"],"content":"#[cfg(test)]\nmod deposit_test {\n    use std::collections::HashMap;\n\n    use node::protocol::{\n        chain_state::{Account, ChainState},\n        executor::TransactionExecutor,\n        transaction::{Operation, Transaction, TransactionType},\n    };\n\n    fn get_test_chain_state() -> ChainState {\n        let accounts = HashMap::from([\n            (\n                \"1\".to_string(),\n                Account {\n                    balance: 0,\n                    address: \"1\".to_string(),\n                },\n            ),\n            (\n                \"2\".to_string(),\n                Account {\n                    balance: 100,\n                    address: \"2\".to_string(),\n                },\n            ),\n            (\n                \"3\".to_string(),\n                Account {\n                    balance: 200,\n                    address: \"3\".to_string(),\n                },\n            ),\n        ]);\n        ChainState::new_with_accounts(accounts, 0)\n    }\n\n    #[test]\n    fn test_execute_deposit_transaction() {\n        let accounts = HashMap::from([(\n            \"1\".to_string(),\n            Account {\n                balance: 0,\n                address: \"1\".to_string(),\n            },\n        )]);\n        let chain_state = ChainState::new_with_accounts(accounts, 0);\n        let transaction = Transaction::new(\n            TransactionType::Deposit,\n            vec![\n                Operation::OpPushAddress {\n                    address: \"1\".to_string(),\n                },\n                Operation::OpPushAmount { amount: 100 },\n                Operation::OpIncrementBalance,\n            ],\n        );\n        let result_state =\n            TransactionExecutor::execute_transaction(transaction, chain_state).unwrap();\n        assert_eq!(result_state.get_account(\"1\").unwrap().balance, 100);\n    }\n\n    #[test]\n    fn test_execute_deposit_transaction_with_multiple_operations() {\n        let chain_state = get_test_chain_state();\n        let transaction = Transaction::new(\n            TransactionType::Deposit,\n            vec![\n                Operation::OpPushAddress {\n                    address: \"1\".to_string(),\n                },\n                Operation::OpPushAmount { amount: 100 },\n                Operation::OpIncrementBalance,\n                Operation::OpPushAddress {\n                    address: \"2\".to_string(),\n                },\n                Operation::OpPushAmount { amount: 200 },\n                Operation::OpIncrementBalance,\n                Operation::OpPushAddress {\n                    address: \"1\".to_string(),\n                },\n                Operation::OpPushAmount { amount: 100 },\n                Operation::OpIncrementBalance,\n                Operation::OpPushAddress {\n                    address: \"3\".to_string(),\n                },\n                Operation::OpPushAmount { amount: 300 },\n                Operation::OpIncrementBalance,\n            ],\n        );\n        let result_state =\n            TransactionExecutor::execute_transaction(transaction, chain_state).unwrap();\n        assert_eq!(result_state.get_account(\"1\").unwrap().balance, 200);\n        assert_eq!(result_state.get_account(\"2\").unwrap().balance, 300);\n        assert_eq!(result_state.get_account(\"3\").unwrap().balance, 500);\n    }\n\n    #[test]\n    fn test_execute_deposit_transaction_with_zero_amount() {\n        let chain_state = get_test_chain_state();\n        let transaction = Transaction::new(\n            TransactionType::Deposit,\n            vec![\n                Operation::OpPushAddress {\n                    address: \"1\".to_string(),\n                },\n                Operation::OpPushAmount { amount: 0 },\n                Operation::OpIncrementBalance,\n            ],\n        );\n        let result = TransactionExecutor::execute_transaction(transaction, chain_state);\n        assert!(result.is_ok());\n        let result_state = result.unwrap();\n        assert_eq!(result_state.get_account(\"1\").unwrap().balance, 0);\n    }\n\n    #[test]\n    fn test_execute_deposit_transaction_with_invalid_account() {\n        let chain_state = ChainState::new();\n        let transaction = Transaction::new(\n            TransactionType::Deposit,\n            vec![\n                Operation::OpPushAddress {\n                    address: \"1\".to_string(),\n                },\n                Operation::OpPushAmount { amount: 100 },\n                Operation::OpIncrementBalance,\n            ],\n        );\n        let result = TransactionExecutor::execute_transaction(transaction, chain_state);\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_execute_deposit_transaction_missing_address() {\n        let chain_state = get_test_chain_state();\n        // Push amount but no address\n        let transaction = Transaction::new(\n            TransactionType::Deposit,\n            vec![\n                Operation::OpPushAmount { amount: 100 },\n                Operation::OpIncrementBalance,\n            ],\n        );\n        let result = TransactionExecutor::execute_transaction(transaction, chain_state);\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_execute_deposit_transaction_missing_amount() {\n        let chain_state = get_test_chain_state();\n        // Push address but no amount\n        let transaction = Transaction::new(\n            TransactionType::Deposit,\n            vec![\n                Operation::OpPushAddress {\n                    address: \"1\".to_string(),\n                },\n                Operation::OpIncrementBalance,\n            ],\n        );\n        let result = TransactionExecutor::execute_transaction(transaction, chain_state);\n        assert!(result.is_err());\n    }\n\n    #[test]\n    fn test_execute_deposit_transaction_multiple_pushes_single_increment() {\n        let chain_state = get_test_chain_state();\n        // Push multiple values but only increment once (should use last pushed values)\n        let transaction = Transaction::new(\n            TransactionType::Deposit,\n            vec![\n                Operation::OpPushAddress {\n                    address: \"1\".to_string(),\n                },\n                Operation::OpPushAmount { amount: 100 },\n                Operation::OpPushAddress {\n                    address: \"1\".to_string(),\n                },\n                Operation::OpPushAmount { amount: 200 },\n                Operation::OpIncrementBalance,\n            ],\n        );\n        let result_state =\n            TransactionExecutor::execute_transaction(transaction, chain_state).unwrap();\n        // Should increment by 200 (the last pushed amount)\n        assert_eq!(result_state.get_account(\"1\").unwrap().balance, 200);\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","vidyootsenthil","TheValut-nameTBD","node","tests","protocol","mod.rs"],"content":"pub mod block;\npub mod deposits;\n","traces":[],"covered":0,"coverable":0}],"coverage":7.142857142857142,"covered":89,"coverable":1246}