<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <style>html, body {
  margin: 0;
  padding: 0;
}

.app {
  margin: 10px;
  padding: 0;
}

.files-list {
  margin: 10px 0 0;
  width: 100%;
  border-collapse: collapse;
}
.files-list__head {
  border: 1px solid #999;
}
.files-list__head > tr > th {
  padding: 10px;
  border: 1px solid #999;
  text-align: left;
  font-weight: normal;
  background: #ddd;
}
.files-list__body {
}
.files-list__file {
  cursor: pointer;
}
.files-list__file:hover {
  background: #ccf;
}
.files-list__file > td {
  padding: 10px;
  border: 1px solid #999;
}
.files-list__file > td:first-child::before {
  content: '\01F4C4';
  margin-right: 1em;
}
.files-list__file_low {
  background: #fcc;
}
.files-list__file_medium {
  background: #ffc;
}
.files-list__file_high {
  background: #cfc;
}
.files-list__file_folder > td:first-child::before {
  content: '\01F4C1';
  margin-right: 1em;
}

.file-header {
  border: 1px solid #999;
  display: flex;
  justify-content: space-between;
  align-items: center;
  position: sticky;
  top: 0;
  background: white;
}

.file-header__back {
  margin: 10px;
  cursor: pointer;
  flex-shrink: 0;
  flex-grow: 0;
  text-decoration: underline;
  color: #338;
}

.file-header__name {
  margin: 10px;
  flex-shrink: 2;
  flex-grow: 2;
}

.file-header__stat {
  margin: 10px;
  flex-shrink: 0;
  flex-grow: 0;
}

.file-content {
  margin: 10px 0 0;
  border: 1px solid #999;
  padding: 10px;
  counter-reset: line;
  display: flex;
  flex-direction: column;
}

.code-line::before {
    content: counter(line);
    margin-right: 10px;
}
.code-line {
  margin: 0;
  padding: 0.3em;
  height: 1em;
  counter-increment: line;
}
.code-line_covered {
  background: #cfc;
}
.code-line_uncovered {
  background: #fcc;
}
</style>
</head>
<body>
    <div id="root"></div>
    <script>
        var data = {"files":[{"path":["/","home","vidyootsenthil","Documents","TheValut-nameTBD","bin","cli","src","errors.rs"],"content":"use derive_more::Display;\n\n#[derive(Debug, Display)]\npub enum KeygenError {\n    #[display(\"Password mismatch\")]\n    PasswordMismatch,\n\n    #[display(\"Failed to create directory.\")]\n    DirectoryCreation(String),\n\n    #[display(\"Io error: {}\", _0)]\n    Io(std::io::Error),\n\n    #[display(\"Failed to encode key.\")]\n    KeyEncoding(String),\n\n    #[display(\"Failed to encrypt key.\")]\n    Encryption(String),\n\n    #[display(\"Failed to create directory.\")]\n    KeyFileNotFound(String),\n}\n\n#[derive(Debug)]\n#[allow(dead_code, clippy::enum_variant_names, clippy::large_enum_variant)]\npub enum CliError {\n    KeygenError(KeygenError),\n    RpcError(tonic::Status),\n    NodeError(String),\n}\n\nimpl From\u003cKeygenError\u003e for CliError {\n    fn from(error: KeygenError) -\u003e Self {\n        CliError::KeygenError(error)\n    }\n}\n","traces":[{"line":33,"address":[5867216],"length":1,"stats":{"Line":0}},{"line":34,"address":[5867219],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":2},{"path":["/","home","vidyootsenthil","Documents","TheValut-nameTBD","bin","cli","src","main.rs"],"content":"mod errors;\nmod rpc_client;\n\nuse aes_gcm::{\n    aead::{Aead, KeyInit},\n    Aes256Gcm, Key, Nonce,\n};\nuse argon2::{\n    password_hash::{\n        rand_core::{OsRng, RngCore},\n        SaltString,\n    },\n    Argon2,\n};\nuse base64::{engine::general_purpose::STANDARD as BASE64, Engine as _};\nuse clap::{Parser, Subcommand};\nuse directories::ProjectDirs;\nuse libp2p::identity::Keypair;\nuse rpc_client::{rpc_create_deposit_intent, rpc_spend, rpc_start_signing};\nuse std::{fs, path::PathBuf};\n\nuse crate::{\n    errors::{CliError, KeygenError},\n    rpc_client::rpc_get_pending_deposit_intents,\n};\nuse node::{\n    key_manager::get_config, start_node::start_node, EncryptionParams, KeyData, NodeConfig,\n};\nuse types::errors::NodeError;\n\nstruct VaultConfigPath {\n    key_file_path: PathBuf,\n    config_file_path: PathBuf,\n}\n\nfn get_key_file_path() -\u003e Result\u003cVaultConfigPath, KeygenError\u003e {\n    let proj_dirs = ProjectDirs::from(\"\", \"\", \"TheVault\").ok_or_else(|| {\n        KeygenError::DirectoryCreation(\"Failed to determine project directory\".into())\n    })?;\n\n    let config_dir = proj_dirs.config_dir();\n    fs::create_dir_all(config_dir).map_err(|e| KeygenError::DirectoryCreation(e.to_string()))?;\n\n    Ok(VaultConfigPath {\n        key_file_path: config_dir.join(\"config.json\"),\n        config_file_path: config_dir.join(\"config.yaml\"),\n    })\n}\n\nfn get_log_file_path() -\u003e Result\u003cPathBuf, KeygenError\u003e {\n    let proj_dirs = ProjectDirs::from(\"\", \"\", \"TheVault\").ok_or_else(|| {\n        KeygenError::DirectoryCreation(\"Failed to determine project directory\".into())\n    })?;\n\n    let log_dir = proj_dirs.config_dir();\n    let path = log_dir.join(\"node.log\");\n    Ok(path)\n}\n\nfn generate_key(password: \u0026str, salt: \u0026SaltString) -\u003e Result\u003cVec\u003cu8\u003e, KeygenError\u003e {\n    let argon2 = Argon2::default();\n    let password_bytes = password.as_bytes();\n    let mut key = vec![0u8; 32];\n\n    argon2\n        .hash_password_into(password_bytes, salt.as_str().as_bytes(), \u0026mut key)\n        .map_err(|e| KeygenError::Encryption(e.to_string()))?;\n    Ok(key)\n}\n\nfn encrypt_private_key(\n    keypair: \u0026Keypair,\n    password: \u0026str,\n) -\u003e Result\u003c(String, EncryptionParams), KeygenError\u003e {\n    let salt = SaltString::generate(\u0026mut OsRng);\n    let key = generate_key(password, \u0026salt)?;\n\n    let mut nonce_bytes = [0u8; 12];\n    OsRng.fill_bytes(\u0026mut nonce_bytes);\n    let nonce = Nonce::from_slice(\u0026nonce_bytes);\n\n    let private_key_bytes = keypair\n        .to_protobuf_encoding()\n        .map_err(|e| KeygenError::KeyEncoding(e.to_string()))?;\n\n    let cipher = Aes256Gcm::new(Key::\u003cAes256Gcm\u003e::from_slice(\u0026key));\n\n    let ciphertext = cipher\n        .encrypt(nonce, private_key_bytes.as_ref())\n        .map_err(|e| KeygenError::Encryption(e.to_string()))?;\n\n    let params = EncryptionParams {\n        kdf: \"argon2id\".to_string(),\n        salt_b64: salt.to_string(),\n        iv_b64: BASE64.encode(nonce_bytes),\n    };\n\n    Ok((BASE64.encode(ciphertext), params))\n}\n\nfn get_password() -\u003e Result\u003cString, KeygenError\u003e {\n    let password = rpassword::prompt_password(\"Enter password: \").map_err(KeygenError::Io)?;\n\n    let confirm = rpassword::prompt_password(\"Confirm password: \").map_err(KeygenError::Io)?;\n\n    if password != confirm {\n        return Err(KeygenError::PasswordMismatch);\n    }\n\n    Ok(password)\n}\n\n#[derive(Parser)]\n#[command(name = \"keygen\")]\n#[command(about = \"Generate public and private key pairs for the Vault.\")]\n#[command(version = \"0.0.1\")]\nstruct Cli {\n    #[command(subcommand)]\n    command: Commands,\n}\n\n#[derive(Subcommand)]\nenum Commands {\n    /// Generate a new keypair and save it to a file set by the --output flag\n    Setup {\n        #[arg(short, long)]\n        output_dir: Option\u003cString\u003e,\n        #[arg(short, long)]\n        file_name: Option\u003cString\u003e,\n    },\n    /// Run the node and connect to the network\n    Run {\n        #[arg(short, long)]\n        key_file_path: Option\u003cString\u003e,\n        #[arg(short, long)]\n        config_file_path: Option\u003cString\u003e,\n        #[arg(short, long)]\n        grpc_port: Option\u003cu16\u003e,\n        #[arg(short, long)]\n        log_file: Option\u003cString\u003e,\n        #[arg(short = 'n', long)]\n        max_signers: Option\u003cu16\u003e,\n        #[arg(short = 't', long)]\n        min_signers: Option\u003cu16\u003e,\n    },\n    Spend {\n        amount: u64,\n        address_to: String,\n        #[arg(short, long)]\n        endpoint: Option\u003cString\u003e,\n    },\n    StartSigning {\n        hex_message: String,\n        #[arg(short, long)]\n        endpoint: Option\u003cString\u003e,\n    },\n    Deposit {\n        amount: u64,\n        #[arg(short, long)]\n        endpoint: Option\u003cString\u003e,\n    },\n    GetPendingDepositIntents {\n        #[arg(short, long)]\n        endpoint: Option\u003cString\u003e,\n    },\n}\n\n#[tokio::main]\n#[allow(clippy::result_large_err)]\nasync fn main() -\u003e Result\u003c(), CliError\u003e {\n    let cli = Cli::parse();\n\n    match cli.command {\n        Commands::Setup {\n            output_dir,\n            file_name,\n        } =\u003e {\n            setup_config(output_dir, file_name).map_err(|e| {\n                println!(\"Keygen Error: {}\", e);\n                CliError::KeygenError(e)\n            })?;\n        }\n        Commands::Run {\n            key_file_path,\n            config_file_path,\n            grpc_port,\n            log_file,\n            max_signers,\n            min_signers,\n        } =\u003e {\n            start_node_cli(\n                key_file_path,\n                config_file_path,\n                grpc_port,\n                log_file,\n                max_signers,\n                min_signers,\n            )\n            .await\n            .map_err(|e| CliError::NodeError(e.to_string()))?;\n        }\n        Commands::Spend {\n            amount,\n            endpoint,\n            address_to,\n        } =\u003e {\n            rpc_spend(endpoint, amount, address_to)\n                .await\n                .map_err(CliError::RpcError)?;\n        }\n        Commands::StartSigning {\n            hex_message,\n            endpoint,\n        } =\u003e {\n            rpc_start_signing(endpoint, hex_message)\n                .await\n                .map_err(CliError::RpcError)?;\n        }\n        Commands::Deposit { amount, endpoint } =\u003e {\n            let response = rpc_create_deposit_intent(endpoint, amount)\n                .await\n                .map_err(CliError::RpcError)?;\n\n            println!(\"Deposit intent created: {:?}\", response);\n        }\n        Commands::GetPendingDepositIntents { endpoint } =\u003e {\n            rpc_get_pending_deposit_intents(endpoint)\n                .await\n                .map_err(CliError::RpcError)?;\n        }\n    }\n\n    Ok(())\n}\n\nfn setup_config(output_dir: Option\u003cString\u003e, file_name: Option\u003cString\u003e) -\u003e Result\u003c(), KeygenError\u003e {\n    let keypair = Keypair::generate_ed25519();\n    let public_key_b58 = keypair.public().to_peer_id().to_base58();\n\n    let user_password = get_password()?;\n\n    let (encrypted_private_key, encryption_params) = encrypt_private_key(\u0026keypair, \u0026user_password)?;\n\n    let key_data = KeyData {\n        public_key_b58: public_key_b58.clone(),\n        encrypted_private_key_b64: encrypted_private_key,\n        encryption_params,\n    };\n\n    let paths = if let Some(output) = output_dir {\n        let path = PathBuf::from(output);\n        if path.is_dir() {\n            VaultConfigPath {\n                key_file_path: path.join(format!(\n                    \"{}.json\",\n                    file_name.clone().unwrap_or(\"key\".to_string())\n                )),\n                config_file_path: path.join(format!(\n                    \"{}.yaml\",\n                    file_name.clone().unwrap_or(\"config\".to_string())\n                )),\n            }\n        } else {\n            return Err(KeygenError::KeyFileNotFound(\n                \"Output path is a file, not a directory. Please provide a directory path.\"\n                    .to_string(),\n            ));\n        }\n    } else {\n        get_key_file_path()?\n    };\n\n    let mut config = NodeConfig::new(\n        paths.key_file_path.clone(),\n        paths.config_file_path.clone(),\n        get_log_file_path().ok(),\n        \u0026user_password,\n    )\n    .map_err(|e| KeygenError::KeyFileNotFound(e.to_string()))?;\n\n    config.set_key_data(key_data);\n\n    config\n        .save_to_file()\n        .map_err(|e| KeygenError::KeyFileNotFound(e.to_string()))?;\n\n    println!(\n        \"Key data has been saved to {} with the peer id {}. To modify the allowed peers and other configurations, edit the config file here: {}\",\n        paths.key_file_path.display(),\n        public_key_b58,\n        paths.config_file_path.display()\n    );\n\n    Ok(())\n}\n\nasync fn start_node_cli(\n    key_file_path: Option\u003cString\u003e,\n    config_file_path: Option\u003cString\u003e,\n    grpc_port: Option\u003cu16\u003e,\n    log_file: Option\u003cString\u003e,\n    max_signers: Option\u003cu16\u003e,\n    min_signers: Option\u003cu16\u003e,\n) -\u003e Result\u003c(), NodeError\u003e {\n    let config = match get_config(key_file_path.clone(), config_file_path.clone()) {\n        Ok(config) =\u003e config,\n        Err(e) =\u003e {\n            return Err(NodeError::Error(format!(\"Failed to get config: {}\", e)));\n        }\n    };\n\n    start_node(\n        max_signers,\n        min_signers,\n        config,\n        grpc_port,\n        log_file.map(PathBuf::from),\n    )\n    .await?;\n    Ok(())\n}\n\n#[cfg(test)]\nmod tests;\n","traces":[{"line":36,"address":[5680567,5680548,5679712],"length":1,"stats":{"Line":0}},{"line":37,"address":[5897760],"length":1,"stats":{"Line":0}},{"line":38,"address":[5897774],"length":1,"stats":{"Line":0}},{"line":41,"address":[5680096,5680024],"length":1,"stats":{"Line":0}},{"line":42,"address":[5680128],"length":1,"stats":{"Line":0}},{"line":44,"address":[5680410],"length":1,"stats":{"Line":0}},{"line":45,"address":[5680287],"length":1,"stats":{"Line":0}},{"line":46,"address":[5680329],"length":1,"stats":{"Line":0}},{"line":50,"address":[5681102,5680592,5681096],"length":1,"stats":{"Line":0}},{"line":51,"address":[5680802,5680609],"length":1,"stats":{"Line":0}},{"line":52,"address":[5898030],"length":1,"stats":{"Line":0}},{"line":55,"address":[5680904,5680976],"length":1,"stats":{"Line":0}},{"line":56,"address":[5680992],"length":1,"stats":{"Line":0}},{"line":57,"address":[5681029],"length":1,"stats":{"Line":0}},{"line":60,"address":[5681745,5681739,5681120],"length":1,"stats":{"Line":3}},{"line":61,"address":[5681176],"length":1,"stats":{"Line":1}},{"line":62,"address":[5681203],"length":1,"stats":{"Line":3}},{"line":63,"address":[5681240],"length":1,"stats":{"Line":1}},{"line":65,"address":[5681453,5681592],"length":1,"stats":{"Line":3}},{"line":66,"address":[5681357,5681276],"length":1,"stats":{"Line":4}},{"line":67,"address":[5898132,5898112],"length":1,"stats":{"Line":0}},{"line":68,"address":[5681619],"length":1,"stats":{"Line":1}},{"line":71,"address":[5683776,5683684,5681760],"length":1,"stats":{"Line":4}},{"line":75,"address":[5681816],"length":1,"stats":{"Line":2}},{"line":76,"address":[5681853],"length":1,"stats":{"Line":1}},{"line":78,"address":[5682078],"length":1,"stats":{"Line":3}},{"line":79,"address":[5682101],"length":1,"stats":{"Line":1}},{"line":80,"address":[5682177],"length":1,"stats":{"Line":3}},{"line":82,"address":[5682354,5682224,5683774],"length":1,"stats":{"Line":1}},{"line":84,"address":[5682322],"length":1,"stats":{"Line":0}},{"line":86,"address":[5682526,5682443],"length":1,"stats":{"Line":4}},{"line":88,"address":[5682790,5682652],"length":1,"stats":{"Line":1}},{"line":89,"address":[5682566],"length":1,"stats":{"Line":3}},{"line":90,"address":[5898365,5898352],"length":1,"stats":{"Line":0}},{"line":93,"address":[5682887],"length":1,"stats":{"Line":3}},{"line":94,"address":[5682959],"length":1,"stats":{"Line":1}},{"line":95,"address":[5683024],"length":1,"stats":{"Line":3}},{"line":98,"address":[5683225,5683348],"length":1,"stats":{"Line":4}},{"line":101,"address":[5684573,5683792,5684591],"length":1,"stats":{"Line":0}},{"line":102,"address":[5683809],"length":1,"stats":{"Line":0}},{"line":104,"address":[5684125,5684579,5684037],"length":1,"stats":{"Line":0}},{"line":106,"address":[5684385,5684309],"length":1,"stats":{"Line":0}},{"line":107,"address":[5684485],"length":1,"stats":{"Line":0}},{"line":110,"address":[5684396],"length":1,"stats":{"Line":0}},{"line":170,"address":[5733481,5733475,5733008],"length":1,"stats":{"Line":0}},{"line":171,"address":[5901483],"length":1,"stats":{"Line":0}},{"line":173,"address":[5733350,5733169,5733239,5733109],"length":1,"stats":{"Line":0}},{"line":174,"address":[5901779],"length":1,"stats":{"Line":0}},{"line":178,"address":[5902580,5902618,5905710,5902482,5905472,5901835],"length":1,"stats":{"Line":0}},{"line":179,"address":[5905543,5905499],"length":1,"stats":{"Line":0}},{"line":180,"address":[5905612],"length":1,"stats":{"Line":0}},{"line":183,"address":[5901908,5901919,5901927],"length":1,"stats":{"Line":0}},{"line":199,"address":[5933105],"length":1,"stats":{"Line":0}},{"line":200,"address":[5903410,5905767,5905744],"length":1,"stats":{"Line":0}},{"line":202,"address":[5902134],"length":1,"stats":{"Line":0}},{"line":207,"address":[5902222,5903761,5903626,5903663,5902777,5903936],"length":1,"stats":{"Line":0}},{"line":208,"address":[5903628,5902807,5903455,5901552,5902770],"length":1,"stats":{"Line":0}},{"line":209,"address":[5933358,5933386],"length":1,"stats":{"Line":0}},{"line":211,"address":[5902232],"length":1,"stats":{"Line":0}},{"line":215,"address":[5904387,5904247,5902857,5904112,5902320,5904149],"length":1,"stats":{"Line":0}},{"line":216,"address":[5902887,5903941,5902850,5901573,5904114],"length":1,"stats":{"Line":0}},{"line":217,"address":[5904240,5904365],"length":1,"stats":{"Line":0}},{"line":219,"address":[5902330],"length":1,"stats":{"Line":0}},{"line":220,"address":[5902398,5905041,5904698,5902937,5904563,5904600],"length":1,"stats":{"Line":0}},{"line":221,"address":[5901594,5904392,5902967,5904565,5902930],"length":1,"stats":{"Line":0}},{"line":222,"address":[5904691],"length":1,"stats":{"Line":0}},{"line":224,"address":[5904950,5904899],"length":1,"stats":{"Line":0}},{"line":226,"address":[5902408],"length":1,"stats":{"Line":0}},{"line":227,"address":[5903017,5902456,5905217,5905254,5905460,5905352],"length":1,"stats":{"Line":0}},{"line":228,"address":[5903010,5903047,5905046,5901615,5905219],"length":1,"stats":{"Line":0}},{"line":229,"address":[5905345,5905438],"length":1,"stats":{"Line":0}},{"line":233,"address":[5733372,5733193],"length":1,"stats":{"Line":0}},{"line":236,"address":[5687554,5684624,5689780],"length":1,"stats":{"Line":0}},{"line":237,"address":[5684678],"length":1,"stats":{"Line":0}},{"line":238,"address":[5684821,5684889],"length":1,"stats":{"Line":0}},{"line":240,"address":[5684951,5685018,5689653],"length":1,"stats":{"Line":0}},{"line":242,"address":[5689632,5685190,5685289],"length":1,"stats":{"Line":0}},{"line":245,"address":[5685645],"length":1,"stats":{"Line":0}},{"line":250,"address":[5685945,5687781],"length":1,"stats":{"Line":0}},{"line":251,"address":[5686032],"length":1,"stats":{"Line":0}},{"line":252,"address":[5686106,5686186],"length":1,"stats":{"Line":0}},{"line":254,"address":[5686256,5686582],"length":1,"stats":{"Line":0}},{"line":258,"address":[5687146,5686895],"length":1,"stats":{"Line":0}},{"line":264,"address":[5686287],"length":1,"stats":{"Line":0}},{"line":265,"address":[5686217],"length":1,"stats":{"Line":0}},{"line":270,"address":[5687620,5689485,5686047],"length":1,"stats":{"Line":0}},{"line":274,"address":[5687544,5687826],"length":1,"stats":{"Line":0}},{"line":275,"address":[5687834,5687895],"length":1,"stats":{"Line":0}},{"line":276,"address":[5687911,5687972],"length":1,"stats":{"Line":0}},{"line":277,"address":[5687995],"length":1,"stats":{"Line":0}},{"line":279,"address":[5688242],"length":1,"stats":{"Line":0}},{"line":281,"address":[5688379],"length":1,"stats":{"Line":0}},{"line":283,"address":[5688578,5688719],"length":1,"stats":{"Line":0}},{"line":285,"address":[5688687],"length":1,"stats":{"Line":0}},{"line":287,"address":[5688752],"length":1,"stats":{"Line":0}},{"line":294,"address":[5689088],"length":1,"stats":{"Line":0}},{"line":297,"address":[5689824],"length":1,"stats":{"Line":0}},{"line":305,"address":[5899125,5900283,5899264,5899193],"length":1,"stats":{"Line":0}},{"line":306,"address":[5899495],"length":1,"stats":{"Line":0}},{"line":307,"address":[5899390],"length":1,"stats":{"Line":0}},{"line":308,"address":[5900008,5899422],"length":1,"stats":{"Line":0}},{"line":315,"address":[5899554],"length":1,"stats":{"Line":0}},{"line":317,"address":[5899584],"length":1,"stats":{"Line":0}},{"line":319,"address":[5899826,5899905,5899180,5900331,5900516,5900596],"length":1,"stats":{"Line":0}},{"line":320,"address":[5900675],"length":1,"stats":{"Line":0}}],"covered":21,"coverable":105},{"path":["/","home","vidyootsenthil","Documents","TheValut-nameTBD","bin","cli","src","rpc_client.rs"],"content":"use node::grpc::grpc_handler::node_proto::{\n    self, node_control_client::NodeControlClient, CreateDepositIntentResponse,\n    GetPendingDepositIntentsResponse, SpendFundsResponse, StartSigningResponse,\n};\nuse tonic::Status;\n\npub async fn rpc_spend(\n    endpoint: Option\u003cString\u003e,\n    amount: u64,\n    address_to: String,\n) -\u003e Result\u003cSpendFundsResponse, Status\u003e {\n    println!(\"Spending {} satoshis\", amount);\n\n    let mut client =\n        NodeControlClient::connect(endpoint.unwrap_or(\"http://[::1]:50051\".to_string()))\n            .await\n            .expect(\"Failed to connect\");\n\n    let spendfunds_response = client\n        .spend_funds(tonic::Request::new(node_proto::SpendFundsRequest {\n            amount_satoshis: amount,\n            address_to,\n        }))\n        .await?;\n\n    println!(\"Spent {:?} satoshis\", spendfunds_response);\n\n    Ok(spendfunds_response.into_inner())\n}\n\npub async fn rpc_start_signing(\n    endpoint: Option\u003cString\u003e,\n    hex_message: String,\n) -\u003e Result\u003cStartSigningResponse, Status\u003e {\n    println!(\"Starting signing session for message: {}\", hex_message);\n\n    let mut client =\n        NodeControlClient::connect(endpoint.unwrap_or(\"http://[::1]:50051\".to_string()))\n            .await\n            .expect(\"Failed to connect\");\n\n    let start_signing_response = client\n        .start_signing(tonic::Request::new(node_proto::StartSigningRequest {\n            hex_message,\n        }))\n        .await?;\n\n    Ok(start_signing_response.into_inner())\n}\n\npub async fn rpc_create_deposit_intent(\n    endpoint: Option\u003cString\u003e,\n    amount: u64,\n) -\u003e Result\u003cCreateDepositIntentResponse, Status\u003e {\n    println!(\"Creating deposit intent: {}\", amount);\n\n    let mut client =\n        NodeControlClient::connect(endpoint.unwrap_or(\"http://[::1]:50051\".to_string()))\n            .await\n            .expect(\"Failed to connect\");\n\n    let create_deposit_intent_response = client\n        .create_deposit_intent(tonic::Request::new(\n            node_proto::CreateDepositIntentRequest {\n                amount_satoshis: amount,\n            },\n        ))\n        .await?;\n\n    Ok(create_deposit_intent_response.into_inner())\n}\n\npub async fn rpc_get_pending_deposit_intents(\n    endpoint: Option\u003cString\u003e,\n) -\u003e Result\u003cGetPendingDepositIntentsResponse, Status\u003e {\n    let mut client =\n        NodeControlClient::connect(endpoint.unwrap_or(\"http://[::1]:50051\".to_string()))\n            .await\n            .expect(\"Failed to connect\");\n\n    let get_pending_deposit_intents_response = client\n        .get_pending_deposit_intents(tonic::Request::new(\n            node_proto::GetPendingDepositIntentsRequest {},\n        ))\n        .await?;\n\n    Ok(get_pending_deposit_intents_response.into_inner())\n}\n","traces":[{"line":7,"address":[6061120],"length":1,"stats":{"Line":0}},{"line":12,"address":[6079610,6079479],"length":1,"stats":{"Line":0}},{"line":14,"address":[6079679,6079951,6079897,6079759,6080201,6080180],"length":1,"stats":{"Line":0}},{"line":16,"address":[5934480],"length":1,"stats":{"Line":0}},{"line":19,"address":[6080801,6080689,6080470,6080726,6080440,6080244],"length":1,"stats":{"Line":0}},{"line":20,"address":[6080307],"length":1,"stats":{"Line":0}},{"line":21,"address":[6080261],"length":1,"stats":{"Line":0}},{"line":22,"address":[6080265],"length":1,"stats":{"Line":0}},{"line":24,"address":[5934498],"length":1,"stats":{"Line":0}},{"line":26,"address":[6080926,6080974],"length":1,"stats":{"Line":0}},{"line":28,"address":[6081043],"length":1,"stats":{"Line":0}},{"line":31,"address":[6061200],"length":1,"stats":{"Line":0}},{"line":35,"address":[6081797,6081669],"length":1,"stats":{"Line":0}},{"line":37,"address":[6081866,6082081,6082129,6082352,6081943,6082370],"length":1,"stats":{"Line":0}},{"line":39,"address":[5935821],"length":1,"stats":{"Line":0}},{"line":42,"address":[6082588,6082618,6082834,6082871,6082413,6082946],"length":1,"stats":{"Line":0}},{"line":43,"address":[6082463],"length":1,"stats":{"Line":0}},{"line":44,"address":[6082430],"length":1,"stats":{"Line":0}},{"line":46,"address":[6082672,6082611,6082836,6082648,6081742,6082939],"length":1,"stats":{"Line":0}},{"line":48,"address":[6083155,6083071],"length":1,"stats":{"Line":0}},{"line":51,"address":[6061264],"length":1,"stats":{"Line":0}},{"line":55,"address":[6083659,6083787],"length":1,"stats":{"Line":0}},{"line":57,"address":[6083856,6083933,6084071,6084342,6084119,6084360],"length":1,"stats":{"Line":0}},{"line":59,"address":[5936409],"length":1,"stats":{"Line":0}},{"line":62,"address":[6084509,6084403,6084539,6084755,6084792,6084867],"length":1,"stats":{"Line":0}},{"line":63,"address":[6084432],"length":1,"stats":{"Line":0}},{"line":65,"address":[6084420],"length":1,"stats":{"Line":0}},{"line":68,"address":[5936424],"length":1,"stats":{"Line":0}},{"line":70,"address":[6085076,6084992],"length":1,"stats":{"Line":0}},{"line":73,"address":[6061312],"length":1,"stats":{"Line":0}},{"line":76,"address":[6085860,6085815,6085513,6086080,6085636,6086098],"length":1,"stats":{"Line":0}},{"line":78,"address":[5936905],"length":1,"stats":{"Line":0}},{"line":81,"address":[6086523,6086598,6086270,6086141,6086240,6086486],"length":1,"stats":{"Line":0}},{"line":82,"address":[6086163],"length":1,"stats":{"Line":0}},{"line":85,"address":[5936920],"length":1,"stats":{"Line":0}},{"line":87,"address":[6087091,6086891],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":36},{"path":["/","home","vidyootsenthil","Documents","TheValut-nameTBD","bin","cli","src","tests.rs"],"content":"use super::*;\nuse assert_matches::assert_matches;\nuse std::fs;\nuse tempfile::tempdir;\n\n// Helper function to decrypt private key\nfn decrypt_private_key(\n    encrypted_key: \u0026str,\n    password: \u0026str,\n    params: \u0026EncryptionParams,\n) -\u003e Result\u003cVec\u003cu8\u003e, KeygenError\u003e {\n    let salt = SaltString::from_b64(\u0026params.salt_b64)\n        .map_err(|e| KeygenError::Encryption(e.to_string()))?;\n    let key = generate_key(password, \u0026salt)?;\n\n    let nonce_bytes = BASE64\n        .decode(\u0026params.iv_b64)\n        .map_err(|e| KeygenError::Encryption(e.to_string()))?;\n    let nonce = Nonce::from_slice(\u0026nonce_bytes);\n\n    let cipher = Aes256Gcm::new(Key::\u003cAes256Gcm\u003e::from_slice(\u0026key));\n\n    let ciphertext = BASE64\n        .decode(encrypted_key)\n        .map_err(|e| KeygenError::Encryption(e.to_string()))?;\n\n    cipher\n        .decrypt(nonce, ciphertext.as_ref())\n        .map_err(|e| KeygenError::Encryption(e.to_string()))\n}\n\n// Test helper to generate keypair without password prompt\nfn generate_test_keypair(output_path: Option\u003cPathBuf\u003e, password: \u0026str) -\u003e Result\u003c(), KeygenError\u003e {\n    let keypair = Keypair::generate_ed25519();\n    let public_key = keypair.public().encode_protobuf();\n    let public_key_b58 = bs58::encode(public_key).into_string();\n\n    let (encrypted_private_key, encryption_params) = encrypt_private_key(\u0026keypair, password)?;\n\n    let key_data = KeyData {\n        public_key_b58: public_key_b58.clone(),\n        encrypted_private_key_b64: encrypted_private_key,\n        encryption_params,\n    };\n\n    let json = serde_json::to_string_pretty(\u0026key_data)\n        .map_err(|e| KeygenError::Io(std::io::Error::other(e)))?;\n\n    let key_file_path = if let Some(path) = output_path {\n        if path.is_dir() {\n            path.join(\"config.json\")\n        } else {\n            path\n        }\n    } else {\n        get_key_file_path()?.key_file_path\n    };\n\n    fs::write(\u0026key_file_path, json).map_err(KeygenError::Io)?;\n    Ok(())\n}\n\n#[test]\nfn test_key_generation_and_encryption() {\n    let keypair = Keypair::generate_ed25519();\n    let password = \"test_password123\";\n\n    let (encrypted_key, params) = encrypt_private_key(\u0026keypair, password).unwrap();\n\n    assert_eq!(params.kdf, \"argon2id\");\n    assert!(!params.salt_b64.is_empty());\n    assert!(!params.iv_b64.is_empty());\n    assert!(!encrypted_key.is_empty());\n\n    // Verify we can decrypt with correct password\n    let decrypted = decrypt_private_key(\u0026encrypted_key, password, \u0026params).unwrap();\n    let original = keypair.to_protobuf_encoding().unwrap();\n    assert_eq!(decrypted, original);\n}\n\n#[test]\nfn test_decryption_with_wrong_password() {\n    let keypair = Keypair::generate_ed25519();\n    let password = \"correct_password\";\n    let wrong_password = \"wrong_password\";\n\n    let (encrypted_key, params) = encrypt_private_key(\u0026keypair, password).unwrap();\n\n    // Attempt decryption with wrong password should fail\n    let result = decrypt_private_key(\u0026encrypted_key, wrong_password, \u0026params);\n    assert!(result.is_err());\n}\n\n#[test]\nfn test_key_file_operations() {\n    let temp_dir = tempdir().unwrap();\n    let output_path = temp_dir.path().join(\"test_config.json\");\n\n    // Test key generation and file writing\n    let result = generate_test_keypair(Some(output_path.clone()), \"test_password123\");\n    assert!(result.is_ok());\n\n    // Verify file exists and contains valid JSON\n    let contents = fs::read_to_string(\u0026output_path).unwrap();\n    let key_data: KeyData = serde_json::from_str(\u0026contents).unwrap();\n\n    assert!(!key_data.public_key_b58.is_empty());\n    assert!(!key_data.encrypted_private_key_b64.is_empty());\n    assert_eq!(key_data.encryption_params.kdf, \"argon2id\");\n}\n\n#[test]\nfn test_invalid_directory() {\n    // Test with a non-existent directory\n    let result = generate_test_keypair(\n        Some(PathBuf::from(\"/nonexistent/path/config.json\")),\n        \"test_password123\",\n    );\n    assert_matches!(result, Err(KeygenError::Io(_)));\n}\n\n#[test]\nfn test_key_encoding() {\n    let keypair = Keypair::generate_ed25519();\n    let public_key = keypair.public().encode_protobuf();\n    let public_key_b58 = bs58::encode(public_key).into_string();\n\n    // Verify the public key is properly encoded\n    assert!(!public_key_b58.is_empty());\n    assert!(bs58::decode(\u0026public_key_b58).into_vec().is_ok());\n}\n\n#[test]\nfn test_encryption_params_serialization() {\n    let params = EncryptionParams {\n        kdf: \"argon2id\".to_string(),\n        salt_b64: \"test_salt\".to_string(),\n        iv_b64: \"test_iv\".to_string(),\n    };\n\n    let json = serde_json::to_string(\u0026params).unwrap();\n    let deserialized: EncryptionParams = serde_json::from_str(\u0026json).unwrap();\n\n    assert_eq!(params.kdf, deserialized.kdf);\n    assert_eq!(params.salt_b64, deserialized.salt_b64);\n    assert_eq!(params.iv_b64, deserialized.iv_b64);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","vidyootsenthil","Documents","TheValut-nameTBD","bin","utxo-spend","src","main.rs"],"content":"use bip39::{Language, Mnemonic};\n#[allow(deprecated)]\nuse bitcoin::bip32::{DerivationPath, ExtendedPrivKey};\nuse bitcoin::consensus::encode::serialize;\nuse bitcoin::key::Secp256k1;\nuse bitcoin::transaction::OutPoint;\nuse bitcoin::witness::Witness;\nuse bitcoin::{Address, Amount, CompressedPublicKey, Network, PrivateKey, Transaction, Txid};\nuse esplora_client::Builder;\nuse node::wallet::SimpleWallet;\nuse std::str::FromStr;\n\n#[tokio::main]\nasync fn main() {\n    let (address, private_key) = generate_from_mnemonic(\n        \"promote aspect indoor neck stand lion wealth priority matrix nest broccoli feel\",\n    );\n    println!(\"Address: {}\", address);\n\n    let address_to =\n        Address::from_str(\"bc1pg520trs6vk0yplnx0mp5v7lrx2yyw00nqy8qmzdpevpz3knjz9fq2ps3jx\")\n            .unwrap()\n            .assume_checked();\n\n    let mut wallet = SimpleWallet::new(\u0026address);\n    wallet.utxos = get_utxos_for_address(\u0026address);\n\n    let (mut tx, sighash) = wallet.create_spend(1000, \u0026address_to).unwrap();\n    println!(\"Tx: {:?}\", tx);\n    println!(\"Sighash: {:?}\", sighash);\n\n    // Sign the transaction\n    sign_transaction(\u0026mut tx, \u0026private_key, \u0026sighash);\n\n    println!(\"Tx signed: {:?}\", tx);\n\n    // // Broadcast the transaction\n    broadcast_transaction(\u0026tx).await;\n}\n\nfn sign_transaction(tx: \u0026mut Transaction, private_key: \u0026PrivateKey, sighash: \u0026[u8; 32]) {\n    // For P2WPKH, we need to create a witness signature\n    let secp = Secp256k1::new();\n\n    // Create the signature (this is simplified - in practice you'd need proper sighash computation)\n    let message = bitcoin::secp256k1::Message::from_digest(*sighash);\n    let signature = secp.sign_ecdsa(\u0026message, \u0026private_key.inner);\n\n    // Create witness with signature + sighash type (0x01 = SIGHASH_ALL)\n    let mut sig_bytes = signature.serialize_der().to_vec();\n    sig_bytes.push(0x01); // SIGHASH_ALL\n\n    let compressed_pubkey = CompressedPublicKey::from_private_key(\u0026secp, private_key)\n        .expect(\"Failed to get compressed public key\");\n\n    let mut witness = Witness::new();\n    witness.push(sig_bytes);\n    witness.push(compressed_pubkey.to_bytes());\n\n    // Add witness to the first (and only) input\n    if let Some(input) = tx.input.first_mut() {\n        input.witness = witness;\n    }\n\n    println!(\"Transaction signed!\");\n}\n\nasync fn broadcast_transaction(tx: \u0026Transaction) {\n    // Create esplora client for testnet4\n    let builder = Builder::new(\"https://blockstream.info/testnet/api\");\n    let client = builder.build_async().unwrap();\n\n    // Serialize the transaction to raw bytes\n    let tx_bytes = serialize(tx);\n    let tx_hex = hex::encode(\u0026tx_bytes);\n\n    println!(\"Raw transaction: {}\", tx_hex);\n\n    // Broadcast the transaction\n    match client.broadcast(tx).await {\n        Ok(()) =\u003e {\n            println!(\"✅ Transaction broadcast successfully!\");\n            println!(\"Txid: {:?}\", tx.compute_txid());\n        }\n        Err(e) =\u003e {\n            println!(\"❌ Failed to broadcast transaction: {}\", e);\n        }\n    }\n}\n\npub fn get_utxos_for_address(address: \u0026Address) -\u003e Vec\u003cnode::wallet::Utxo\u003e {\n    let utxos = vec![node::wallet::Utxo {\n        outpoint: OutPoint::new(\n            Txid::from_str(\"f0d3f62a1a516e75ff5e5c4946a2d714a8a813167d79224b3a1ec0a241cf0e89\")\n                .unwrap(),\n            0,\n        ),\n        value: Amount::from_sat(50_000_000),\n        script_pubkey: address.script_pubkey(),\n    }];\n    utxos\n}\n\n#[allow(deprecated)]\npub fn generate_from_mnemonic(mnemonic: \u0026str) -\u003e (Address, PrivateKey) {\n    // Generate a new mnemonic (12 words)\n    let mnemonic = Mnemonic::parse_in_normalized(Language::English, mnemonic).unwrap();\n    println!(\"Mnemonic: {}\", mnemonic);\n\n    // Convert to seed\n    let seed = mnemonic.to_seed(\"\"); // Empty passphrase\n\n    // Create extended private key\n    let secp = Secp256k1::new();\n    let xprv = ExtendedPrivKey::new_master(Network::Testnet4, \u0026seed).unwrap();\n\n    // Derive key at standard path (m/84'/1'/0'/0/0 for signet P2WPKH)\n    let derivation_path = DerivationPath::from_str(\"m/84'/1'/0'/0/0\").unwrap();\n    let derived_xprv = xprv.derive_priv(\u0026secp, \u0026derivation_path).unwrap();\n\n    // Get the private key\n    let private_key = PrivateKey::new(derived_xprv.private_key, Network::Testnet4);\n    let compressed_public_key: CompressedPublicKey =\n        CompressedPublicKey::from_private_key(\u0026secp, \u0026private_key)\n            .expect(\"Failed to convert public key to compressed public key\");\n    let address = Address::p2wpkh(\u0026compressed_public_key, Network::Testnet4);\n\n    println!(\"Extended Private Key: {}\", xprv);\n    println!(\"Derived Private Key (WIF): {}\", private_key.to_wif());\n    println!(\"Address: {}\", address);\n    (address, private_key)\n}\n","traces":[{"line":14,"address":[5603378,5603384,5602976],"length":1,"stats":{"Line":0}},{"line":18,"address":[5591667],"length":1,"stats":{"Line":0}},{"line":20,"address":[5591756],"length":1,"stats":{"Line":0}},{"line":25,"address":[5591845],"length":1,"stats":{"Line":0}},{"line":26,"address":[5591868,5591953,5591933],"length":1,"stats":{"Line":0}},{"line":28,"address":[5592062],"length":1,"stats":{"Line":0}},{"line":29,"address":[5592307,5592232],"length":1,"stats":{"Line":0}},{"line":30,"address":[5592376],"length":1,"stats":{"Line":0}},{"line":33,"address":[5592472],"length":1,"stats":{"Line":0}},{"line":35,"address":[5592511],"length":1,"stats":{"Line":0}},{"line":38,"address":[5591520,5592607,5592737],"length":1,"stats":{"Line":0}},{"line":41,"address":[5600192,5601185,5601213],"length":1,"stats":{"Line":0}},{"line":43,"address":[5600238],"length":1,"stats":{"Line":0}},{"line":46,"address":[5600273],"length":1,"stats":{"Line":0}},{"line":47,"address":[5600356],"length":1,"stats":{"Line":0}},{"line":50,"address":[5600401],"length":1,"stats":{"Line":0}},{"line":51,"address":[5600470],"length":1,"stats":{"Line":0}},{"line":53,"address":[5600560],"length":1,"stats":{"Line":0}},{"line":56,"address":[5600617],"length":1,"stats":{"Line":0}},{"line":57,"address":[5600624],"length":1,"stats":{"Line":0}},{"line":58,"address":[5600736],"length":1,"stats":{"Line":0}},{"line":61,"address":[5601078,5600791],"length":1,"stats":{"Line":0}},{"line":62,"address":[5600902,5601003],"length":1,"stats":{"Line":0}},{"line":65,"address":[5600973,5601080],"length":1,"stats":{"Line":0}},{"line":68,"address":[5589814,5589854,5589696,5590376,5589721,5590425],"length":1,"stats":{"Line":0}},{"line":70,"address":[5589786],"length":1,"stats":{"Line":0}},{"line":71,"address":[5589901],"length":1,"stats":{"Line":0}},{"line":74,"address":[5589960],"length":1,"stats":{"Line":0}},{"line":75,"address":[5590029],"length":1,"stats":{"Line":0}},{"line":77,"address":[5590094,5590164],"length":1,"stats":{"Line":0}},{"line":80,"address":[5590233,5590451,5590686,5589841,5590322],"length":1,"stats":{"Line":0}},{"line":81,"address":[5591001],"length":1,"stats":{"Line":0}},{"line":82,"address":[5590791,5590862],"length":1,"stats":{"Line":0}},{"line":83,"address":[5590881],"length":1,"stats":{"Line":0}},{"line":85,"address":[5590713],"length":1,"stats":{"Line":0}},{"line":86,"address":[5590761,5591070],"length":1,"stats":{"Line":0}},{"line":91,"address":[5601264,5601680,5601686],"length":1,"stats":{"Line":0}},{"line":92,"address":[5601350,5601667,5601479,5601304],"length":1,"stats":{"Line":0}},{"line":93,"address":[5601427],"length":1,"stats":{"Line":0}},{"line":94,"address":[5601314,5601382],"length":1,"stats":{"Line":0}},{"line":98,"address":[5601434],"length":1,"stats":{"Line":0}},{"line":99,"address":[5601460],"length":1,"stats":{"Line":0}},{"line":105,"address":[5602955,5601712,5602949],"length":1,"stats":{"Line":0}},{"line":107,"address":[5601745],"length":1,"stats":{"Line":0}},{"line":108,"address":[5601804],"length":1,"stats":{"Line":0}},{"line":111,"address":[5601903],"length":1,"stats":{"Line":0}},{"line":114,"address":[5601908],"length":1,"stats":{"Line":0}},{"line":115,"address":[5601930,5602010],"length":1,"stats":{"Line":0}},{"line":118,"address":[5602040],"length":1,"stats":{"Line":0}},{"line":119,"address":[5602184,5602133],"length":1,"stats":{"Line":0}},{"line":122,"address":[5602214],"length":1,"stats":{"Line":0}},{"line":123,"address":[5602309],"length":1,"stats":{"Line":0}},{"line":126,"address":[5602358],"length":1,"stats":{"Line":0}},{"line":128,"address":[5602413],"length":1,"stats":{"Line":0}},{"line":129,"address":[5602489],"length":1,"stats":{"Line":0}},{"line":130,"address":[5602739],"length":1,"stats":{"Line":0}},{"line":131,"address":[5602820],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":57},{"path":["/","home","vidyootsenthil","Documents","TheValut-nameTBD","crates","clients","src","lib.rs"],"content":"use async_trait::async_trait;\nuse bitcoin::{consensus, Address, Network, Transaction};\nuse esplora_client::AsyncClient;\nuse std::{collections::HashSet, str::FromStr};\nuse tokio::sync::broadcast;\nuse tokio::time::{sleep, Duration};\nuse tracing::{error, info};\n\n#[derive(Debug)]\npub enum NodeError {\n    Error(String),\n}\n\n#[async_trait]\npub trait WindowedConfirmedTransactionProvider {\n    // Must only return transactions that are confirmed in the given range [min_height, max_height].\n    // All returned transactions must have at least six confirmations (\u003c current_chain_tip_height - 6).\n    async fn get_confirmed_transactions(\n        \u0026self,\n        addresses: Vec\u003cAddress\u003e,\n        min_height: u32,\n        max_height: u32,\n    ) -\u003e Result\u003cVec\u003cTransaction\u003e, NodeError\u003e;\n\n    // Must poll for new transactions and send them to the given channel.\n    async fn poll_new_transactions(\u0026mut self, addresses: Vec\u003cAddress\u003e);\n}\n\n#[derive(Debug)]\npub struct EsploraApiClient {\n    client: AsyncClient,\n    tx_channel: broadcast::Sender\u003cTransaction\u003e,\n    deposit_intent_rx: Option\u003cbroadcast::Receiver\u003cString\u003e\u003e,\n}\n\nimpl EsploraApiClient {\n    pub fn new(\n        client: AsyncClient,\n        capacity: usize,\n        deposit_intent_rx: Option\u003cbroadcast::Receiver\u003cString\u003e\u003e,\n    ) -\u003e Self {\n        Self {\n            client,\n            tx_channel: broadcast::channel(capacity).0,\n            deposit_intent_rx,\n        }\n    }\n}\n\n#[async_trait]\nimpl WindowedConfirmedTransactionProvider for EsploraApiClient {\n    async fn get_confirmed_transactions(\n        \u0026self,\n        addresses: Vec\u003cAddress\u003e,\n        min_height: u32,\n        max_height: u32,\n    ) -\u003e Result\u003cVec\u003cTransaction\u003e, NodeError\u003e {\n        let blockchain_height = self.client.get_height().await.map_err(|e| {\n            NodeError::Error(format!(\"Cannot retrieve height of blockchain: {}\", e))\n        })?;\n\n        let new_max_height = max_height.min(blockchain_height - 6);\n        let mut confirmed_txs = Vec::new();\n\n        for address in \u0026addresses {\n            let mut last_seen_txid = None;\n\n            loop {\n                let address_txs = self\n                    .client\n                    .scripthash_txs(\u0026address.script_pubkey(), last_seen_txid)\n                    .await\n                    .map_err(|e| {\n                        NodeError::Error(format!(\"Cannot retrieve transactions for address: {}\", e))\n                    })?;\n\n                if address_txs.is_empty() {\n                    break;\n                }\n\n                last_seen_txid = Some(address_txs.last().unwrap().txid);\n\n                let mut found_confirmed = false;\n                let last_tx_height = address_txs.last().and_then(|tx| tx.status.block_height);\n\n                for tx in address_txs {\n                    if let Some(block_height) = tx.status.block_height {\n                        if block_height \u003e= min_height \u0026\u0026 block_height \u003c= new_max_height {\n                            if let Ok(full_tx) = self.client.get_tx(\u0026tx.txid).await {\n                                if let Ok(bitcoin_tx) =\n                                    consensus::deserialize(\u0026consensus::serialize(\u0026full_tx.unwrap()))\n                                {\n                                    confirmed_txs.push(bitcoin_tx);\n                                    found_confirmed = true;\n                                }\n                            }\n                        }\n                    }\n                }\n\n                if !found_confirmed \u0026\u0026 last_tx_height.is_some_and(|height| height \u003c min_height) {\n                    break;\n                }\n            }\n\n            sleep(Duration::from_secs(5)).await;\n        }\n\n        Ok(confirmed_txs)\n    }\n\n    async fn poll_new_transactions(\u0026mut self, addresses: Vec\u003cAddress\u003e) {\n        let mut last_confirmed_height = match self.client.get_height().await {\n            Ok(height) =\u003e height - 6,\n            Err(e) =\u003e {\n                error!(\"Cannot retrieve height of blockchain: {}\", e);\n                return;\n            }\n        };\n\n        info!(\n            \"Polling for new transactions, starting from confirmed height {}\",\n            last_confirmed_height\n        );\n\n        let mut deposit_intent_rx = self.deposit_intent_rx.take().unwrap();\n        let mut addresses: HashSet\u003c_\u003e = addresses.into_iter().collect();\n\n        loop {\n            tokio::select! {\n                _ = sleep(Duration::from_secs(30)) =\u003e {\n                    let current_height = match self.client.get_height().await {\n                        Ok(height) =\u003e height,\n                        Err(e) =\u003e {\n                            error!(\"Cannot retrieve height of blockchain: {}\", e);\n                            continue;\n                        }\n                    };\n\n                    let new_confirmed_height = current_height - 6;\n\n                    if new_confirmed_height \u003e last_confirmed_height {\n                        info!(\n                            \"New confirmed block found. From height {} to {}\",\n                            last_confirmed_height + 1,\n                            new_confirmed_height\n                        );\n\n                        let new_txs = match self\n                            .get_confirmed_transactions(\n                                addresses.iter().cloned().collect(),\n                                last_confirmed_height + 1,\n                                new_confirmed_height,\n                            )\n                            .await\n                        {\n                            Ok(txs) =\u003e txs,\n                            Err(e) =\u003e {\n                                error!(\"Error getting confirmed transactions: {:?}\", e);\n                                continue;\n                            }\n                        };\n\n                        for tx in new_txs {\n                            println!(\"Found new confirmed transaction: {}\", tx.compute_txid());\n                            match self.tx_channel.send(tx) {\n                                Ok(_) =\u003e (),\n                                Err(e) =\u003e {\n                                    error!(\"Error sending transaction to channel: {:?}\", e);\n                                }\n                            }\n                        }\n\n                        last_confirmed_height = new_confirmed_height;\n                    }\n                }\n                Ok(address_str) = deposit_intent_rx.recv() =\u003e {\n                    info!(\"Received new deposit address to monitor: {}\", \u0026address_str);\n                    if addresses.insert(\n                        Address::from_str(\u0026address_str)\n                            .unwrap()\n                            .require_network(Network::Bitcoin)\n                            .unwrap(),\n                    ) {\n                        info!(\"Now polling {} addresses.\", addresses.len());\n                    }\n                }\n            }\n        }\n    }\n}\n","traces":[{"line":37,"address":[15960928,15961196,15961202],"length":1,"stats":{"Line":1}},{"line":44,"address":[15961012,15961078],"length":1,"stats":{"Line":2}},{"line":58,"address":[15738334,15743678,15738533,15738413,15743456,15737941,15739245,15738889],"length":1,"stats":{"Line":3}},{"line":59,"address":[16035362,16035302],"length":1,"stats":{"Line":0}},{"line":62,"address":[13138956],"length":1,"stats":{"Line":1}},{"line":63,"address":[2020385],"length":1,"stats":{"Line":1}},{"line":65,"address":[13139227,13139591,13139211,13139108],"length":1,"stats":{"Line":4}},{"line":66,"address":[12675714],"length":1,"stats":{"Line":1}},{"line":68,"address":[13141598,13139665],"length":1,"stats":{"Line":2}},{"line":69,"address":[12676256,12676453,12676202,12676627,12676527,12675951],"length":1,"stats":{"Line":5}},{"line":71,"address":[12675971,12676035,12676149],"length":1,"stats":{"Line":3}},{"line":72,"address":[2020579,2021489,2019322,2021494,2021693,2021449],"length":1,"stats":{"Line":5}},{"line":73,"address":[2024848,2025066],"length":1,"stats":{"Line":0}},{"line":74,"address":[13143810,13143750],"length":1,"stats":{"Line":0}},{"line":77,"address":[15740740],"length":1,"stats":{"Line":1}},{"line":81,"address":[2022094,2022029],"length":1,"stats":{"Line":2}},{"line":83,"address":[16032837],"length":1,"stats":{"Line":1}},{"line":84,"address":[13143989,13141044,13143984],"length":1,"stats":{"Line":3}},{"line":86,"address":[13141309,13141164,13141396],"length":1,"stats":{"Line":3}},{"line":87,"address":[2022809,2022671],"length":1,"stats":{"Line":2}},{"line":88,"address":[15741626,15743078,15741675],"length":1,"stats":{"Line":3}},{"line":89,"address":[2023455,2023008,2020612,2019343,2023053,2022899],"length":1,"stats":{"Line":5}},{"line":90,"address":[2023779,2023699,2023527,2023631],"length":1,"stats":{"Line":3}},{"line":93,"address":[15742777],"length":1,"stats":{"Line":1}},{"line":94,"address":[15742878],"length":1,"stats":{"Line":1}},{"line":101,"address":[13144009,13141524,13141607,13144000],"length":1,"stats":{"Line":4}},{"line":106,"address":[15739353,15743170,15739387,15738004,15743122],"length":1,"stats":{"Line":4}},{"line":109,"address":[16031478],"length":1,"stats":{"Line":1}},{"line":112,"address":[13069199],"length":1,"stats":{"Line":0}},{"line":113,"address":[15573122],"length":1,"stats":{"Line":0}},{"line":114,"address":[16036759,16036839],"length":1,"stats":{"Line":0}},{"line":115,"address":[16036680],"length":1,"stats":{"Line":0}},{"line":116,"address":[13146187,13144920,13146474],"length":1,"stats":{"Line":0}},{"line":121,"address":[2026138,2026083,2026445],"length":1,"stats":{"Line":0}},{"line":126,"address":[13145323,13145851],"length":1,"stats":{"Line":0}},{"line":127,"address":[2027128,2027008],"length":1,"stats":{"Line":0}},{"line":129,"address":[13156418],"length":1,"stats":{"Line":0}},{"line":130,"address":[15573174],"length":1,"stats":{"Line":0}}],"covered":25,"coverable":38},{"path":["/","home","vidyootsenthil","Documents","TheValut-nameTBD","crates","node","build.rs"],"content":"fn main() -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\n    tonic_build::compile_protos(\"proto/node.proto\")?;\n    Ok(())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","vidyootsenthil","Documents","TheValut-nameTBD","crates","node","src","db.rs"],"content":"use rocksdb::DB;\n\nuse protocol::{\n    block::{Block, BlockHash},\n    chain_state::ChainState,\n};\nuse types::errors::NodeError;\n\nuse crate::deposit_intents::DepositIntent;\n\npub trait Db: Send {\n    fn get_block_by_height(\u0026self, height: u64) -\u003e Result\u003cOption\u003cBlock\u003e, NodeError\u003e;\n    fn get_block_by_hash(\u0026self, hash: BlockHash) -\u003e Result\u003cOption\u003cBlock\u003e, NodeError\u003e;\n    fn get_tip_block_hash(\u0026self) -\u003e Result\u003cOption\u003cBlockHash\u003e, NodeError\u003e;\n    fn get_chain_state(\u0026self) -\u003e Result\u003cOption\u003cChainState\u003e, NodeError\u003e;\n    fn insert_chain_state(\u0026mut self, chain_state: ChainState) -\u003e Result\u003c(), NodeError\u003e;\n    fn insert_block(\u0026mut self, block: Block) -\u003e Result\u003c(), NodeError\u003e;\n    fn insert_deposit_intent(\u0026mut self, intent: DepositIntent) -\u003e Result\u003c(), NodeError\u003e;\n    fn get_deposit_intent(\u0026self, tracking_id: \u0026str) -\u003e Result\u003cOption\u003cDepositIntent\u003e, NodeError\u003e;\n}\n\npub struct RocksDb {\n    pub db: DB,\n}\n\nimpl RocksDb {\n    pub fn new(path: \u0026str) -\u003e Self {\n        let mut opts = rocksdb::Options::default();\n        opts.create_if_missing(true);\n        opts.create_missing_column_families(true);\n\n        let cfs = vec![\"deposit_intents\", \"blocks\", \"chain_state\"];\n        let db = DB::open_cf(\u0026opts, path, cfs).unwrap();\n\n        Self { db }\n    }\n}\n\nimpl Db for RocksDb {\n    fn get_block_by_height(\u0026self, height: u64) -\u003e Result\u003cOption\u003cBlock\u003e, NodeError\u003e {\n        let block_hash = self.db.get_cf(\n            self.db.cf_handle(\"blocks\").unwrap(),\n            format!(\"h:{}\", height),\n        )?;\n        if let Some(block_hash) = block_hash {\n            let block = self.db.get_cf(\n                self.db.cf_handle(\"blocks\").unwrap(),\n                format!(\"b:{}\", hex::encode(block_hash)),\n            )?;\n            Ok(block.and_then(|b| Block::deserialize(\u0026b).ok()))\n        } else {\n            Ok(None)\n        }\n    }\n\n    fn get_block_by_hash(\u0026self, hash: BlockHash) -\u003e Result\u003cOption\u003cBlock\u003e, NodeError\u003e {\n        let block = self.db.get_cf(\n            self.db.cf_handle(\"blocks\").unwrap(),\n            format!(\"b:{}\", hex::encode(hash)),\n        )?;\n        Ok(block.and_then(|b| Block::deserialize(\u0026b).ok()))\n    }\n\n    fn get_tip_block_hash(\u0026self) -\u003e Result\u003cOption\u003cBlockHash\u003e, NodeError\u003e {\n        let tip = self\n            .db\n            .get_cf(self.db.cf_handle(\"blocks\").unwrap(), \"h:tip\")?;\n        Ok(tip.and_then(|b| b.as_slice().try_into().ok()))\n    }\n\n    fn insert_chain_state(\u0026mut self, chain_state: ChainState) -\u003e Result\u003c(), NodeError\u003e {\n        self.db.put_cf(\n            self.db.cf_handle(\"chain_state\").unwrap(),\n            \"c:state\",\n            chain_state.serialize()?,\n        )?;\n        Ok(())\n    }\n\n    fn get_chain_state(\u0026self) -\u003e Result\u003cOption\u003cChainState\u003e, NodeError\u003e {\n        let chain_state = self\n            .db\n            .get_cf(self.db.cf_handle(\"chain_state\").unwrap(), \"c:state\")?;\n        Ok(chain_state.and_then(|b| ChainState::deserialize(\u0026b).ok()))\n    }\n\n    fn insert_block(\u0026mut self, block: Block) -\u003e Result\u003c(), NodeError\u003e {\n        let block_hash = block.hash();\n        self.db\n            .put_cf(\n                self.db.cf_handle(\"blocks\").unwrap(),\n                format!(\"b:{}\", hex::encode(block_hash)),\n                block.serialize()?,\n            )\n            .map_err(|e| NodeError::Error(format!(\"Failed to insert block: {}\", e)))?;\n\n        self.db\n            .put_cf(\n                self.db.cf_handle(\"blocks\").unwrap(),\n                format!(\"h:{}\", block.header.height),\n                block_hash,\n            )\n            .map_err(|e| NodeError::Error(format!(\"Failed to insert block: {}\", e)))?;\n\n        self.db\n            .put_cf(self.db.cf_handle(\"blocks\").unwrap(), \"h:tip\", block_hash)?;\n\n        Ok(())\n    }\n\n    fn insert_deposit_intent(\u0026mut self, intent: DepositIntent) -\u003e Result\u003c(), NodeError\u003e {\n        let key = format!(\"di:{}\", intent.deposit_tracking_id);\n        let value = bincode::encode_to_vec(\u0026intent, bincode::config::standard())\n            .map_err(|e| NodeError::Error(format!(\"Failed to serialize deposit intent: {}\", e)))?;\n\n        self.db\n            .put_cf(self.db.cf_handle(\"deposit_intents\").unwrap(), key, value)?;\n        Ok(())\n    }\n\n    fn get_deposit_intent(\u0026self, tracking_id: \u0026str) -\u003e Result\u003cOption\u003cDepositIntent\u003e, NodeError\u003e {\n        let key = format!(\"di:{}\", tracking_id);\n        let value = self\n            .db\n            .get_cf(self.db.cf_handle(\"deposit_intents\").unwrap(), key)?;\n\n        Ok(value.and_then(|v| {\n            bincode::decode_from_slice(\u0026v, bincode::config::standard())\n                .ok()\n                .map(|(intent, _)| intent)\n        }))\n    }\n}\n","traces":[{"line":27,"address":[11571210,11571216,11570768],"length":1,"stats":{"Line":0}},{"line":28,"address":[5775259],"length":1,"stats":{"Line":0}},{"line":29,"address":[10003619],"length":1,"stats":{"Line":0}},{"line":30,"address":[12130572],"length":1,"stats":{"Line":0}},{"line":32,"address":[11570923],"length":1,"stats":{"Line":0}},{"line":33,"address":[11571100],"length":1,"stats":{"Line":0}},{"line":40,"address":[11572747,11571232,11572652],"length":1,"stats":{"Line":0}},{"line":41,"address":[5775917,5775723,5776005],"length":1,"stats":{"Line":0}},{"line":42,"address":[11571299],"length":1,"stats":{"Line":0}},{"line":43,"address":[12131018],"length":1,"stats":{"Line":0}},{"line":45,"address":[11571673,11571823],"length":1,"stats":{"Line":0}},{"line":46,"address":[5776766,5776685],"length":1,"stats":{"Line":0}},{"line":47,"address":[12131554,12131434],"length":1,"stats":{"Line":0}},{"line":48,"address":[10004680],"length":1,"stats":{"Line":0}},{"line":50,"address":[10005228,10005337],"length":1,"stats":{"Line":0}},{"line":52,"address":[10004571],"length":1,"stats":{"Line":0}},{"line":56,"address":[11573590,11573619,11572832],"length":1,"stats":{"Line":0}},{"line":57,"address":[5777289,5777759,5777792,5777671],"length":1,"stats":{"Line":0}},{"line":58,"address":[11572881],"length":1,"stats":{"Line":0}},{"line":59,"address":[11572931],"length":1,"stats":{"Line":0}},{"line":61,"address":[12133131,12133231],"length":1,"stats":{"Line":0}},{"line":64,"address":[5778445,5778474,5778032],"length":1,"stats":{"Line":0}},{"line":65,"address":[11573670,11573843,11573812,11573720],"length":1,"stats":{"Line":0}},{"line":67,"address":[10006462,10006560],"length":1,"stats":{"Line":0}},{"line":68,"address":[11421968,11421995],"length":1,"stats":{"Line":0}},{"line":71,"address":[5778953,5778480],"length":1,"stats":{"Line":0}},{"line":72,"address":[5778757,5778936,5778872],"length":1,"stats":{"Line":0}},{"line":73,"address":[12133819,12133893],"length":1,"stats":{"Line":0}},{"line":75,"address":[10007024,10007379],"length":1,"stats":{"Line":0}},{"line":77,"address":[5778904],"length":1,"stats":{"Line":0}},{"line":80,"address":[5778976,5779393,5779422],"length":1,"stats":{"Line":0}},{"line":81,"address":[5779014,5779182,5779152,5779062],"length":1,"stats":{"Line":0}},{"line":83,"address":[10007454,10007552],"length":1,"stats":{"Line":0}},{"line":84,"address":[10007679,10007779],"length":1,"stats":{"Line":0}},{"line":87,"address":[5781104,5779440],"length":1,"stats":{"Line":0}},{"line":88,"address":[5779483],"length":1,"stats":{"Line":0}},{"line":89,"address":[10008585,10009563,10008677,10008796],"length":1,"stats":{"Line":0}},{"line":91,"address":[5779553],"length":1,"stats":{"Line":0}},{"line":92,"address":[10008041],"length":1,"stats":{"Line":0}},{"line":93,"address":[12135332,12135269],"length":1,"stats":{"Line":0}},{"line":95,"address":[11422304,11422326],"length":1,"stats":{"Line":0}},{"line":97,"address":[5780725,5781049,5780548],"length":1,"stats":{"Line":0}},{"line":99,"address":[10008830],"length":1,"stats":{"Line":0}},{"line":100,"address":[5780415],"length":1,"stats":{"Line":0}},{"line":103,"address":[11576397],"length":1,"stats":{"Line":0}},{"line":105,"address":[11576762,11576527,11576694],"length":1,"stats":{"Line":0}},{"line":106,"address":[5780938,5780755],"length":1,"stats":{"Line":0}},{"line":108,"address":[11576730],"length":1,"stats":{"Line":0}},{"line":111,"address":[11577806,11577870,11576864],"length":1,"stats":{"Line":0}},{"line":112,"address":[11576907,11576983],"length":1,"stats":{"Line":0}},{"line":113,"address":[10009917,10010041,10009860,10010596],"length":1,"stats":{"Line":0}},{"line":114,"address":[6408870,6408848],"length":1,"stats":{"Line":0}},{"line":116,"address":[10010326,10010546,10010462],"length":1,"stats":{"Line":0}},{"line":117,"address":[5781615,5781685,5781882],"length":1,"stats":{"Line":0}},{"line":118,"address":[12137394],"length":1,"stats":{"Line":0}},{"line":121,"address":[11578620,11578596,11577888],"length":1,"stats":{"Line":0}},{"line":122,"address":[5782168],"length":1,"stats":{"Line":0}},{"line":123,"address":[11578317,11578212],"length":1,"stats":{"Line":0}},{"line":125,"address":[10010855,10011069,10010929],"length":1,"stats":{"Line":0}},{"line":127,"address":[10866557,10866336],"length":1,"stats":{"Line":0}},{"line":128,"address":[6409134,6409216],"length":1,"stats":{"Line":0}},{"line":130,"address":[6409344,6409356],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":62},{"path":["/","home","vidyootsenthil","Documents","TheValut-nameTBD","crates","node","src","deposit_intents","handler.rs"],"content":"use libp2p::gossipsub::{IdentTopic, Message};\nuse tracing::info;\nuse types::errors::NodeError;\n\nuse crate::{\n    NodeState,\n    db::Db,\n    deposit_intents::{DepositIntent, DepositIntentState},\n    handler::Handler,\n    swarm_manager::{Network, NetworkEvent, SelfRequest, SelfResponse},\n};\n\n#[async_trait::async_trait]\nimpl\u003cN: Network, D: Db\u003e Handler\u003cN, D\u003e for DepositIntentState {\n    async fn handle(\n        \u0026mut self,\n        node: \u0026mut NodeState\u003cN, D\u003e,\n        message: Option\u003cNetworkEvent\u003e,\n    ) -\u003e Result\u003c(), types::errors::NodeError\u003e {\n        match message {\n            Some(NetworkEvent::SelfRequest {\n                request: SelfRequest::CreateDeposit { deposit_intent },\n                response_channel,\n            }) =\u003e {\n                let response = self.create_deposit(node, deposit_intent).await;\n                if let Some(response_channel) = response_channel {\n                    response_channel\n                        .send(SelfResponse::CreateDepositResponse {\n                            success: response.is_ok(),\n                        })\n                        .map_err(|e| NodeError::Error(format!(\"Failed to send response: {}\", e)))?;\n                }\n            }\n            Some(NetworkEvent::SelfRequest {\n                request: SelfRequest::GetPendingDepositIntents,\n                response_channel,\n            }) =\u003e {\n                let response = self.get_pending_deposit_intents();\n                if let Some(response_channel) = response_channel {\n                    response_channel\n                        .send(SelfResponse::GetPendingDepositIntentsResponse { intents: response })\n                        .map_err(|e| NodeError::Error(format!(\"Failed to send response: {}\", e)))?;\n                }\n            }\n            Some(NetworkEvent::GossipsubMessage(Message { data, topic, .. })) =\u003e {\n                if topic == IdentTopic::new(\"deposit-intents\").hash() {\n                    let deposit_intent =\n                        serde_json::from_slice::\u003cDepositIntent\u003e(\u0026data).map_err(|e| {\n                            NodeError::Error(format!(\"Failed to parse deposit intent: {}\", e))\n                        })?;\n\n                    if let Err(e) = self.create_deposit(node, deposit_intent).await {\n                        info!(\"Failed to store deposit intent: {}\", e);\n                    }\n                }\n            }\n            _ =\u003e {}\n        }\n        Ok(())\n    }\n}\n","traces":[{"line":20,"address":[10790060,10790279],"length":1,"stats":{"Line":2}},{"line":21,"address":[7395399],"length":1,"stats":{"Line":2}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[7570443],"length":1,"stats":{"Line":4}},{"line":26,"address":[7348440],"length":1,"stats":{"Line":2}},{"line":27,"address":[10793496,10793338],"length":1,"stats":{"Line":2}},{"line":28,"address":[10245641],"length":1,"stats":{"Line":2}},{"line":29,"address":[7348524],"length":1,"stats":{"Line":2}},{"line":31,"address":[10793464,10796422,10796400],"length":1,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[6102538,6102784],"length":1,"stats":{"Line":0}},{"line":39,"address":[7395812],"length":1,"stats":{"Line":0}},{"line":40,"address":[7396172,7396049,7395951],"length":1,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[6103116,6108160,6108182],"length":1,"stats":{"Line":0}},{"line":45,"address":[10242686],"length":1,"stats":{"Line":1}},{"line":46,"address":[6107201,6102244,6103783,6103545],"length":1,"stats":{"Line":6}},{"line":47,"address":[7401696,7397056,7396826,7401923,7401929,7396914],"length":1,"stats":{"Line":4}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[7401718,7401783],"length":1,"stats":{"Line":0}},{"line":52,"address":[7394486,7397244,7397405,7399145],"length":1,"stats":{"Line":4}},{"line":53,"address":[10247012,10247107,10247352],"length":1,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":1}}],"covered":12,"coverable":29},{"path":["/","home","vidyootsenthil","Documents","TheValut-nameTBD","crates","node","src","deposit_intents","mod.rs"],"content":"use std::collections::HashSet;\n\nuse bincode::{Decode, Encode};\nuse serde::{Deserialize, Serialize};\nuse tokio::sync::broadcast;\n\npub mod handler;\npub mod utils;\n\n#[derive(Debug, Clone, Serialize, Deserialize, Encode, Decode)]\npub struct DepositIntent {\n    pub amount_sat: u64,\n    pub deposit_tracking_id: String,\n    pub deposit_address: String,\n    pub timestamp: u64,\n}\n\npub struct DepositIntentState {\n    pub pending_intents: Vec\u003cDepositIntent\u003e,\n    pub deposit_addresses: HashSet\u003cString\u003e,\n    pub deposit_intent_tx: broadcast::Sender\u003cString\u003e,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","vidyootsenthil","Documents","TheValut-nameTBD","crates","node","src","deposit_intents","utils.rs"],"content":"use std::collections::HashSet;\n\nuse tokio::sync::broadcast;\nuse tracing::error;\n\nuse types::errors::NodeError;\n\nuse crate::{\n    NodeState,\n    db::Db,\n    deposit_intents::{DepositIntent, DepositIntentState},\n    swarm_manager::Network,\n};\n\nimpl DepositIntentState {\n    pub fn new(deposit_intent_tx: broadcast::Sender\u003cString\u003e) -\u003e Self {\n        Self {\n            pending_intents: vec![],\n            deposit_addresses: HashSet::new(),\n            deposit_intent_tx,\n        }\n    }\n\n    pub async fn create_deposit\u003cN: Network, D: Db\u003e(\n        \u0026mut self,\n        node: \u0026mut NodeState\u003cN, D\u003e,\n        deposit_intent: DepositIntent,\n    ) -\u003e Result\u003c(), NodeError\u003e {\n        node.db.insert_deposit_intent(deposit_intent.clone())?;\n\n        if self\n            .deposit_addresses\n            .insert(deposit_intent.deposit_address.clone())\n        {\n            if let Err(e) = self\n                .deposit_intent_tx\n                .send(deposit_intent.deposit_address.clone())\n            {\n                error!(\"Failed to notify deposit monitor of new address: {}\", e);\n            }\n        }\n\n        Ok(())\n    }\n\n    pub fn get_pending_deposit_intents(\u0026self) -\u003e Vec\u003cDepositIntent\u003e {\n        self.pending_intents.clone()\n    }\n}\n","traces":[{"line":16,"address":[9183968,9184168,9184174],"length":1,"stats":{"Line":4}},{"line":18,"address":[7123176],"length":1,"stats":{"Line":7}},{"line":19,"address":[7123219],"length":1,"stats":{"Line":4}},{"line":24,"address":[6257456],"length":1,"stats":{"Line":2}},{"line":29,"address":[9028855,9028970],"length":1,"stats":{"Line":4}},{"line":31,"address":[5834481,5834522],"length":1,"stats":{"Line":4}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[5834490],"length":1,"stats":{"Line":2}},{"line":35,"address":[5834641,5834600],"length":1,"stats":{"Line":4}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[9372083],"length":1,"stats":{"Line":2}},{"line":39,"address":[8975047,8974707,8974802],"length":1,"stats":{"Line":4}},{"line":43,"address":[9029187],"length":1,"stats":{"Line":2}},{"line":46,"address":[7123360],"length":1,"stats":{"Line":0}},{"line":47,"address":[7123377],"length":1,"stats":{"Line":0}}],"covered":11,"coverable":15},{"path":["/","home","vidyootsenthil","Documents","TheValut-nameTBD","crates","node","src","dkg","handler.rs"],"content":"use tracing::{error, info};\n\nuse crate::{\n    NodeState,\n    db::Db,\n    dkg::DkgState,\n    handler::Handler,\n    swarm_manager::{DirectMessage, Network, NetworkEvent},\n};\n\n#[async_trait::async_trait]\nimpl\u003cN: Network, D: Db\u003e Handler\u003cN, D\u003e for DkgState {\n    async fn handle(\n        \u0026mut self,\n        node: \u0026mut NodeState\u003cN, D\u003e,\n        message: Option\u003cNetworkEvent\u003e,\n    ) -\u003e Result\u003c(), types::errors::NodeError\u003e {\n        match message {\n            Some(NetworkEvent::Subscribed { peer_id, topic }) =\u003e {\n                if topic == self.start_dkg_topic.hash() {\n                    self.dkg_listeners.insert(peer_id);\n                    info!(\n                        \"Peer {} subscribed to topic {topic}. Listeners: {}\",\n                        peer_id,\n                        self.dkg_listeners.len()\n                    );\n                    if let Err(e) = self.handle_dkg_start(node).await {\n                        error!(\"❌ Failed to handle DKG start: {}\", e);\n                    }\n                }\n            }\n            Some(NetworkEvent::GossipsubMessage(message)) =\u003e {\n                if message.topic == self.round1_topic.hash() {\n                    if let Some(source_peer) = message.source {\n                        self.handle_round1_payload(node, source_peer, \u0026message.data)?;\n                    }\n                }\n            }\n            Some(NetworkEvent::MessageEvent((peer, DirectMessage::Round2Package(package)))) =\u003e {\n                self.handle_round2_payload(node, peer, package)?;\n            }\n            _ =\u003e {}\n        }\n        Ok(())\n    }\n}\n","traces":[{"line":18,"address":[],"length":0,"stats":{"Line":2}},{"line":19,"address":[12593413],"length":1,"stats":{"Line":2}},{"line":20,"address":[7419330,7419098],"length":1,"stats":{"Line":6}},{"line":21,"address":[12593933],"length":1,"stats":{"Line":2}},{"line":22,"address":[7420135],"length":1,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[7419890,7420609,7422262,7418389],"length":1,"stats":{"Line":8}},{"line":28,"address":[8449639,8449544,8449884],"length":1,"stats":{"Line":0}},{"line":32,"address":[11850298],"length":1,"stats":{"Line":1}},{"line":33,"address":[5956272,5954694],"length":1,"stats":{"Line":2}},{"line":34,"address":[7421281,7420890],"length":1,"stats":{"Line":2}},{"line":35,"address":[8447896],"length":1,"stats":{"Line":1}},{"line":39,"address":[8448345],"length":1,"stats":{"Line":1}},{"line":40,"address":[7421557,7421810],"length":1,"stats":{"Line":1}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":1}}],"covered":12,"coverable":18},{"path":["/","home","vidyootsenthil","Documents","TheValut-nameTBD","crates","node","src","dkg","key_creation.rs"],"content":"use frost_secp256k1::{self as frost, keys::dkg::round2};\nuse libp2p::PeerId;\nuse tracing::{debug, error, info, warn};\nuse types::errors::NodeError;\n\nuse crate::{\n    NodeState,\n    db::Db,\n    dkg::DkgState,\n    peer_id_to_identifier,\n    swarm_manager::{DirectMessage, Network},\n};\n\nimpl DkgState {\n    pub async fn handle_dkg_start\u003cN: Network, D: Db\u003e(\n        \u0026mut self,\n        node: \u0026mut NodeState\u003cN, D\u003e,\n    ) -\u003e Result\u003c(), NodeError\u003e {\n        if self.dkg_started {\n            debug!(\"DKG already started, skipping DKG process\");\n            return Ok(());\n        }\n\n        if node.private_key_package.is_some() \u0026\u0026 node.pubkey_package.is_some() {\n            info!(\"DKG keys already exist, skipping DKG process\");\n            return Ok(());\n        }\n\n        if self.dkg_listeners.len() + 1 != node.max_signers as usize {\n            debug!(\n                \"Not all listeners have subscribed to the DKG topic, not starting DKG process. Listeners: {:?}\",\n                self.dkg_listeners.len()\n            );\n            return Ok(());\n        }\n\n        info!(\"Starting DKG process\");\n\n        self.dkg_started = true;\n\n        // Run the DKG initialization code\n        let participant_identifier = peer_id_to_identifier(\u0026node.peer_id);\n\n        let (round1_secret_package, round1_package) = frost::keys::dkg::part1(\n            participant_identifier,\n            node.max_signers,\n            node.min_signers,\n            node.rng,\n        )\n        .expect(\"Failed to generate round1 package\");\n\n        self.r1_secret_package = Some(round1_secret_package);\n\n        let round1_package_bytes = round1_package\n            .serialize()\n            .expect(\"Failed to serialize round1 package\");\n\n        // Broadcast START_DKG message to the network,\n        let start_message = format!(\"START_DKG:{}\", node.peer_id);\n\n        match node.network_handle.send_broadcast(\n            self.start_dkg_topic.clone(),\n            start_message.as_bytes().to_vec(),\n        ) {\n            Ok(_) =\u003e (),\n            Err(e) =\u003e {\n                return Err(NodeError::Error(format!(\n                    \"Failed to send broadcast: {:?}\",\n                    e\n                )));\n            }\n        }\n\n        match node\n            .network_handle\n            .send_broadcast(self.round1_topic.clone(), round1_package_bytes)\n        {\n            Ok(_) =\u003e (),\n            Err(e) =\u003e {\n                return Err(NodeError::Error(format!(\n                    \"Failed to send broadcast: {:?}\",\n                    e\n                )));\n            }\n        }\n\n        match self.try_enter_round2(node) {\n            Ok(_) =\u003e {\n                info!(\n                    \"Generated and published round1 package in response to DKG start signal from {}\",\n                    \u0026node.peer_id\n                );\n                Ok(())\n            }\n            Err(e) =\u003e Err(NodeError::Error(format!(\"Failed to enter round2: {}\", e))),\n        }\n    }\n\n    pub fn handle_round1_payload\u003cN: Network, D: Db\u003e(\n        \u0026mut self,\n        node: \u0026mut NodeState\u003cN, D\u003e,\n        sender_peer_id: PeerId,\n        package: \u0026[u8],\n    ) -\u003e Result\u003c(), NodeError\u003e {\n        let identifier = peer_id_to_identifier(\u0026sender_peer_id);\n        let package = match frost::keys::dkg::round1::Package::deserialize(package) {\n            Ok(package) =\u003e package,\n            Err(e) =\u003e {\n                return Err(NodeError::Error(format!(\n                    \"Failed to deserialize round1 package: {}\",\n                    e\n                )));\n            }\n        };\n        // Add package to peer packages\n        self.round1_peer_packages.insert(identifier, package);\n\n        debug!(\n            \"Received round1 package from {} ({}/{})\",\n            sender_peer_id,\n            self.round1_peer_packages.len(),\n            node.max_signers - 1\n        );\n\n        self.try_enter_round2(node)?;\n\n        Ok(())\n    }\n\n    pub fn try_enter_round2\u003cN: Network, D: Db\u003e(\n        \u0026mut self,\n        node: \u0026mut NodeState\u003cN, D\u003e,\n    ) -\u003e Result\u003c(), NodeError\u003e {\n        if let Some(r1_secret_package) = self.r1_secret_package.as_ref() {\n            if self.round1_peer_packages.len() + 1 == node.max_signers as usize {\n                info!(\"Received all round1 packages, entering part2\");\n                // all packages received\n                let part2_result =\n                    frost::keys::dkg::part2(r1_secret_package.clone(), \u0026self.round1_peer_packages);\n                match part2_result {\n                    Ok((round2_secret_package, round2_packages)) =\u003e {\n                        info!(\"-------------------- ENTERING ROUND 2 ---------------------\");\n                        self.r1_secret_package = None;\n                        self.r2_secret_package = Some(round2_secret_package);\n\n                        for peer_to_send_to in self.dkg_listeners.iter() {\n                            let identifier = peer_id_to_identifier(peer_to_send_to);\n                            let package_to_send = match round2_packages.get(\u0026identifier) {\n                                Some(package) =\u003e package,\n                                None =\u003e {\n                                    warn!(\"Round2 package not found for {}\", peer_to_send_to);\n                                    return Err(NodeError::Error(format!(\n                                        \"Round2 package not found for {}\",\n                                        peer_to_send_to\n                                    )));\n                                }\n                            };\n\n                            let request = DirectMessage::Round2Package(package_to_send.clone());\n\n                            match node\n                                .network_handle\n                                .send_private_message(*peer_to_send_to, request)\n                            {\n                                Ok(_) =\u003e {\n                                    debug!(\n                                        \"{} Sent round2 package to {}\",\n                                        node.peer_id, peer_to_send_to\n                                    );\n                                }\n                                Err(e) =\u003e {\n                                    error!(\"Round2 package not found for {}\", peer_to_send_to);\n                                    return Err(NodeError::Error(format!(\n                                        \"Failed to send private request: {:?}\",\n                                        e\n                                    )));\n                                }\n                            }\n\n                            debug!(\"Sent round2 package to {}\", peer_to_send_to);\n                        }\n                    }\n                    Err(e) =\u003e {\n                        return Err(NodeError::Error(format!(\"DKG round2 failed: {}\", e)));\n                    }\n                }\n            }\n        }\n\n        Ok(())\n    }\n\n    pub fn handle_round2_payload\u003cN: Network, D: Db\u003e(\n        \u0026mut self,\n        node: \u0026mut NodeState\u003cN, D\u003e,\n        sender_peer_id: PeerId,\n        package: round2::Package,\n    ) -\u003e Result\u003c(), NodeError\u003e {\n        let identifier = peer_id_to_identifier(\u0026sender_peer_id);\n\n        match node\n            .network_handle\n            .send_private_message(sender_peer_id, DirectMessage::Pong)\n        {\n            Ok(_) =\u003e (),\n            Err(e) =\u003e {\n                return Err(NodeError::Error(format!(\n                    \"Failed to send private response: {:?}\",\n                    e\n                )));\n            }\n        }\n\n        // Add package to peer packages\n        self.round2_peer_packages.insert(identifier, package);\n\n        debug!(\n            \"Received round2 package from {} ({}/{})\",\n            sender_peer_id,\n            self.round2_peer_packages.len(),\n            node.max_signers - 1\n        );\n        if let Some(r2_secret_package) = self.r2_secret_package.as_ref() {\n            if self.round2_peer_packages.len() + 1 == node.max_signers as usize {\n                info!(\"Received all round2 packages, entering part3\");\n                let part3_result = frost::keys::dkg::part3(\n                    \u0026r2_secret_package.clone(),\n                    \u0026self.round1_peer_packages,\n                    \u0026self.round2_peer_packages,\n                );\n\n                match part3_result {\n                    Ok((private_key_package, pubkey_package)) =\u003e {\n                        info!(\n                            \"🎉 DKG finished successfully. Public key: {:?}\",\n                            pubkey_package.verifying_key()\n                        );\n\n                        self.save_dkg_keys(node, \u0026private_key_package, \u0026pubkey_package)?;\n\n                        self.dkg_started = false;\n                    }\n                    Err(e) =\u003e {\n                        error!(\"DKG failed during part3 aggregation: {}\", e);\n                        // Reset state so that a fresh DKG can be attempted again later\n                        self.reset_dkg_state();\n                    }\n                }\n            }\n        }\n\n        Ok(())\n    }\n\n    /// Reset DKG state after a failed run so that a new DKG round can be initiated.\n    fn reset_dkg_state(\u0026mut self) {\n        self.dkg_started = false;\n        self.r1_secret_package = None;\n        self.r2_secret_package = None;\n        self.round1_peer_packages.clear();\n        self.round2_peer_packages.clear();\n    }\n}\n","traces":[{"line":15,"address":[6562576],"length":1,"stats":{"Line":2}},{"line":19,"address":[12307984],"length":1,"stats":{"Line":3}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":6}},{"line":25,"address":[],"length":0,"stats":{"Line":4}},{"line":26,"address":[9088346],"length":1,"stats":{"Line":2}},{"line":29,"address":[12308260,12308149],"length":1,"stats":{"Line":6}},{"line":30,"address":[12313166],"length":1,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[6277525],"length":1,"stats":{"Line":2}},{"line":37,"address":[],"length":0,"stats":{"Line":4}},{"line":39,"address":[12639218],"length":1,"stats":{"Line":4}},{"line":42,"address":[6273273],"length":1,"stats":{"Line":2}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[5960292,5960073],"length":1,"stats":{"Line":3}},{"line":54,"address":[],"length":0,"stats":{"Line":7}},{"line":59,"address":[6274527,6274460],"length":1,"stats":{"Line":4}},{"line":61,"address":[],"length":0,"stats":{"Line":11}},{"line":62,"address":[12640667,12640613],"length":1,"stats":{"Line":4}},{"line":63,"address":[12640763,12640683],"length":1,"stats":{"Line":6}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[12640878],"length":1,"stats":{"Line":0}},{"line":67,"address":[6276890,6274950],"length":1,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":6}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[9085050,9085125],"length":1,"stats":{"Line":7}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[12310613],"length":1,"stats":{"Line":0}},{"line":80,"address":[9085269,9086693],"length":1,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[12310691],"length":1,"stats":{"Line":5}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[9085733],"length":1,"stats":{"Line":5}},{"line":95,"address":[9086266,9085371],"length":1,"stats":{"Line":0}},{"line":99,"address":[6571344,6571312,6569472],"length":1,"stats":{"Line":1}},{"line":105,"address":[],"length":0,"stats":{"Line":1}},{"line":106,"address":[8588191],"length":1,"stats":{"Line":1}},{"line":107,"address":[6569966],"length":1,"stats":{"Line":1}},{"line":108,"address":[6569671],"length":1,"stats":{"Line":0}},{"line":109,"address":[6569701],"length":1,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[9397869,9398026],"length":1,"stats":{"Line":2}},{"line":118,"address":[],"length":0,"stats":{"Line":0}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[12115897,12116557,12116732],"length":1,"stats":{"Line":2}},{"line":127,"address":[9399111],"length":1,"stats":{"Line":1}},{"line":130,"address":[9399200,9406036,9406030],"length":1,"stats":{"Line":2}},{"line":134,"address":[8589970],"length":1,"stats":{"Line":5}},{"line":135,"address":[9399355,9399429],"length":1,"stats":{"Line":7}},{"line":136,"address":[6562864,6563145],"length":1,"stats":{"Line":1}},{"line":138,"address":[6563048],"length":1,"stats":{"Line":1}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[9399691],"length":1,"stats":{"Line":1}},{"line":141,"address":[12117949],"length":1,"stats":{"Line":1}},{"line":142,"address":[8591280,8591585,8591201],"length":1,"stats":{"Line":2}},{"line":143,"address":[9400863,9401312],"length":1,"stats":{"Line":1}},{"line":144,"address":[6564847,6565073],"length":1,"stats":{"Line":1}},{"line":146,"address":[12119404],"length":1,"stats":{"Line":1}},{"line":147,"address":[12119573],"length":1,"stats":{"Line":1}},{"line":148,"address":[9511474],"length":1,"stats":{"Line":1}},{"line":149,"address":[6565615],"length":1,"stats":{"Line":1}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[12119834,12120164],"length":1,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[8593943,8592920],"length":1,"stats":{"Line":2}},{"line":161,"address":[8594003,8594101],"length":1,"stats":{"Line":2}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[9512678],"length":1,"stats":{"Line":1}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":1}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":172,"address":[8596018,8594177,8595769],"length":1,"stats":{"Line":0}},{"line":173,"address":[8596454,8596008],"length":1,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[12121420,12121974],"length":1,"stats":{"Line":2}},{"line":183,"address":[12117697],"length":1,"stats":{"Line":0}},{"line":184,"address":[8590844],"length":1,"stats":{"Line":0}},{"line":190,"address":[8590098],"length":1,"stats":{"Line":2}},{"line":193,"address":[12127919,12123680,12127191],"length":1,"stats":{"Line":1}},{"line":199,"address":[6571442],"length":1,"stats":{"Line":1}},{"line":201,"address":[6571507,6571480],"length":1,"stats":{"Line":2}},{"line":202,"address":[],"length":0,"stats":{"Line":0}},{"line":203,"address":[8596870],"length":1,"stats":{"Line":1}},{"line":205,"address":[],"length":0,"stats":{"Line":0}},{"line":206,"address":[],"length":0,"stats":{"Line":0}},{"line":207,"address":[6571631,6575657],"length":1,"stats":{"Line":0}},{"line":208,"address":[],"length":0,"stats":{"Line":0}},{"line":209,"address":[],"length":0,"stats":{"Line":0}},{"line":215,"address":[9406414],"length":1,"stats":{"Line":1}},{"line":217,"address":[6572167],"length":1,"stats":{"Line":0}},{"line":218,"address":[],"length":0,"stats":{"Line":0}},{"line":219,"address":[],"length":0,"stats":{"Line":0}},{"line":220,"address":[],"length":0,"stats":{"Line":0}},{"line":221,"address":[],"length":0,"stats":{"Line":0}},{"line":223,"address":[],"length":0,"stats":{"Line":2}},{"line":224,"address":[8600903,8598056,8598130],"length":1,"stats":{"Line":3}},{"line":225,"address":[8598417,8598157],"length":1,"stats":{"Line":1}},{"line":227,"address":[9517053],"length":1,"stats":{"Line":1}},{"line":228,"address":[9517094],"length":1,"stats":{"Line":1}},{"line":229,"address":[9517104],"length":1,"stats":{"Line":1}},{"line":232,"address":[],"length":0,"stats":{"Line":2}},{"line":233,"address":[9517778],"length":1,"stats":{"Line":2}},{"line":234,"address":[12126138,12126442,12126059,12126640],"length":1,"stats":{"Line":2}},{"line":235,"address":[],"length":0,"stats":{"Line":0}},{"line":236,"address":[],"length":0,"stats":{"Line":0}},{"line":239,"address":[6574590,6574105],"length":1,"stats":{"Line":2}},{"line":241,"address":[12127059],"length":1,"stats":{"Line":1}},{"line":243,"address":[],"length":0,"stats":{"Line":0}},{"line":244,"address":[8600215,8598986,8600456],"length":1,"stats":{"Line":0}},{"line":246,"address":[6575556,6575104],"length":1,"stats":{"Line":0}},{"line":252,"address":[],"length":0,"stats":{"Line":1}},{"line":256,"address":[5910512,5910830],"length":1,"stats":{"Line":0}},{"line":257,"address":[5910531],"length":1,"stats":{"Line":0}},{"line":258,"address":[11642772,11642796],"length":1,"stats":{"Line":0}},{"line":259,"address":[6003908,6003885],"length":1,"stats":{"Line":0}},{"line":260,"address":[6003984],"length":1,"stats":{"Line":0}},{"line":261,"address":[6004000],"length":1,"stats":{"Line":0}}],"covered":64,"coverable":137},{"path":["/","home","vidyootsenthil","Documents","TheValut-nameTBD","crates","node","src","dkg","mod.rs"],"content":"use std::collections::{BTreeMap, HashSet};\n\nuse frost_secp256k1::{\n    Identifier,\n    keys::dkg::{round1, round2},\n};\nuse libp2p::PeerId;\n\npub mod handler;\npub mod key_creation;\npub mod utils;\n\npub struct DkgState {\n    pub dkg_started: bool,\n    pub dkg_listeners: HashSet\u003cPeerId\u003e,\n\n    pub start_dkg_topic: libp2p::gossipsub::IdentTopic,\n    pub round1_topic: libp2p::gossipsub::IdentTopic,\n\n    pub round1_peer_packages: BTreeMap\u003cIdentifier, round1::Package\u003e,\n    pub round2_peer_packages: BTreeMap\u003cIdentifier, round2::Package\u003e,\n\n    pub r1_secret_package: Option\u003cround1::SecretPackage\u003e,\n    pub r2_secret_package: Option\u003cround2::SecretPackage\u003e,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","vidyootsenthil","Documents","TheValut-nameTBD","crates","node","src","dkg","utils.rs"],"content":"use std::collections::{BTreeMap, HashSet};\n\nuse base64::{Engine as _, engine::general_purpose::STANDARD as BASE64};\nuse frost_secp256k1::{self as frost};\nuse libp2p::gossipsub;\nuse protocol::block::{ChainConfig, GenesisBlock, ValidatorInfo};\n\nuse crate::{\n    DkgKeys, EncryptionParams, NodeConfig, NodeState,\n    db::Db,\n    dkg::DkgState,\n    key_manager::{decrypt_private_key, encrypt_private_key, get_password_from_prompt},\n    swarm_manager::Network,\n};\nuse types::errors::NodeError;\n\nimpl DkgState {\n    pub fn new() -\u003e Result\u003cSelf, NodeError\u003e {\n        Ok(DkgState {\n            dkg_listeners: HashSet::new(),\n            start_dkg_topic: gossipsub::IdentTopic::new(\"start-dkg\"),\n            round1_topic: gossipsub::IdentTopic::new(\"round1_topic\"),\n            round1_peer_packages: BTreeMap::new(),\n            round2_peer_packages: BTreeMap::new(),\n            r1_secret_package: None,\n            r2_secret_package: None,\n            dkg_started: false,\n        })\n    }\n\n    pub fn load_dkg_keys(\n        config: NodeConfig,\n    ) -\u003e Result\u003c\n        Option\u003c(frost::keys::KeyPackage, frost::keys::PublicKeyPackage)\u003e,\n        Box\u003cdyn std::error::Error\u003e,\n    \u003e {\n        if let Some(dkg_keys) = config.dkg_keys {\n            let password = get_password_from_prompt()?;\n\n            // Decrypt the private key package\n            let private_key_bytes = decrypt_private_key(\n                \u0026dkg_keys.encrypted_private_key_package_b64,\n                \u0026password,\n                \u0026dkg_keys.dkg_encryption_params,\n            )?;\n\n            // Deserialize the private key from decrypted bytes\n            let private_key = frost::keys::KeyPackage::deserialize(\u0026private_key_bytes)?;\n\n            // Deserialize the public key from base64\n            let pubkey_bytes = BASE64.decode(\u0026dkg_keys.pubkey_package_b64)?;\n            let pubkey = frost::keys::PublicKeyPackage::deserialize(\u0026pubkey_bytes)?;\n\n            Ok(Some((private_key, pubkey)))\n        } else {\n            Ok(None)\n        }\n    }\n\n    pub fn save_dkg_keys\u003cN: Network, D: Db\u003e(\n        \u0026mut self,\n        node: \u0026mut NodeState\u003cN, D\u003e,\n        private_key: \u0026frost::keys::KeyPackage,\n        pubkey: \u0026frost::keys::PublicKeyPackage,\n    ) -\u003e Result\u003c(), NodeError\u003e {\n        node.private_key_package = Some(private_key.clone());\n        node.pubkey_package = Some(pubkey.clone());\n\n        let password = match std::env::var(\"KEY_PASSWORD\") {\n            Ok(pw) =\u003e pw,\n            Err(_) =\u003e get_password_from_prompt()?,\n        };\n\n        // Serialize private key to bytes\n        let private_key_bytes = private_key\n            .serialize()\n            .map_err(|e| NodeError::Error(format!(\"Failed to serialize private key: {}\", e)))?;\n\n        // Use existing salt from key_data, or generate a new one if empty\n        let salt_b64 = if node.config.key_data.encryption_params.salt_b64.is_empty() {\n            // Generate a new salt\n            use frost::rand_core::RngCore;\n            let mut salt = [0u8; 16];\n            frost::rand_core::OsRng.fill_bytes(\u0026mut salt);\n            BASE64.encode(salt)\n        } else {\n            node.config.key_data.encryption_params.salt_b64.clone()\n        };\n\n        // Encrypt the private key package\n        let (encrypted_private_key_b64, iv_b64) =\n            encrypt_private_key(\u0026private_key_bytes, \u0026password, \u0026salt_b64)\n                .map_err(|e| NodeError::Error(format!(\"Failed to encrypt private key: {}\", e)))?;\n\n        // Serialize and base64 encode the public key package\n        let pubkey_bytes = pubkey\n            .serialize()\n            .map_err(|e| NodeError::Error(format!(\"Failed to serialize public key: {}\", e)))?;\n        let pubkey_package_b64 = BASE64.encode(pubkey_bytes);\n\n        node.config.set_dkg_keys(DkgKeys {\n            encrypted_private_key_package_b64: encrypted_private_key_b64,\n            dkg_encryption_params: EncryptionParams {\n                kdf: \"argon2id\".to_string(),\n                salt_b64,\n                iv_b64,\n            },\n            pubkey_package_b64,\n        });\n\n        let mut validators: Vec\u003cValidatorInfo\u003e = node\n            .peers\n            .iter()\n            .map(|peer_id| ValidatorInfo {\n                pub_key: peer_id.to_bytes(),\n                stake: 100,\n            })\n            .collect();\n\n        validators.sort_by(|a, b| a.pub_key.cmp(\u0026b.pub_key));\n\n        let chain_config = ChainConfig {\n            block_time_seconds: 10,\n            min_signers: node.min_signers,\n            max_signers: node.max_signers,\n            min_stake: 100,\n            max_block_size: 1000,\n        };\n\n        let genesis_block = GenesisBlock::new(\n            validators,\n            chain_config,\n            pubkey\n                .serialize()\n                .map_err(|e| NodeError::Error(format!(\"Failed to serialize public key: {}\", e)))?,\n        );\n\n        node.db.insert_block(genesis_block.to_block())?;\n\n        node.config.save_to_file()?;\n        Ok(())\n    }\n}\n","traces":[{"line":18,"address":[6004048,6004661,6004667],"length":1,"stats":{"Line":6}},{"line":19,"address":[11643408],"length":1,"stats":{"Line":7}},{"line":20,"address":[11643088],"length":1,"stats":{"Line":4}},{"line":21,"address":[6004081],"length":1,"stats":{"Line":7}},{"line":22,"address":[6004152],"length":1,"stats":{"Line":4}},{"line":23,"address":[6004224],"length":1,"stats":{"Line":7}},{"line":24,"address":[8851344],"length":1,"stats":{"Line":4}},{"line":25,"address":[6004324],"length":1,"stats":{"Line":7}},{"line":26,"address":[5911166],"length":1,"stats":{"Line":4}},{"line":31,"address":[6006998,6004688,6006642],"length":1,"stats":{"Line":0}},{"line":37,"address":[11644016,11643771],"length":1,"stats":{"Line":0}},{"line":38,"address":[11643963,11645804,11644065],"length":1,"stats":{"Line":0}},{"line":42,"address":[6005191],"length":1,"stats":{"Line":0}},{"line":43,"address":[11644342],"length":1,"stats":{"Line":0}},{"line":44,"address":[5912155],"length":1,"stats":{"Line":0}},{"line":48,"address":[8853794,8852695,8852612],"length":1,"stats":{"Line":0}},{"line":51,"address":[11644903,11645760],"length":1,"stats":{"Line":0}},{"line":52,"address":[5912977,5912894],"length":1,"stats":{"Line":0}},{"line":54,"address":[5913263],"length":1,"stats":{"Line":0}},{"line":56,"address":[8852022],"length":1,"stats":{"Line":0}},{"line":60,"address":[6579945,6575872,6580339],"length":1,"stats":{"Line":1}},{"line":66,"address":[8601306],"length":1,"stats":{"Line":1}},{"line":67,"address":[9520242,9520332],"length":1,"stats":{"Line":1}},{"line":69,"address":[12128657],"length":1,"stats":{"Line":1}},{"line":70,"address":[12128719],"length":1,"stats":{"Line":1}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[12129181,12129289,12129118,12132708],"length":1,"stats":{"Line":2}},{"line":77,"address":[11543312,11543328],"length":1,"stats":{"Line":0}},{"line":80,"address":[12129634,12129456,12129390],"length":1,"stats":{"Line":2}},{"line":83,"address":[9411912],"length":1,"stats":{"Line":0}},{"line":84,"address":[6577167],"length":1,"stats":{"Line":0}},{"line":85,"address":[9521336],"length":1,"stats":{"Line":0}},{"line":87,"address":[9411955,9411886],"length":1,"stats":{"Line":3}},{"line":91,"address":[],"length":0,"stats":{"Line":2}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[6577577],"length":1,"stats":{"Line":0}},{"line":96,"address":[9412702,9412534,9412594,9414875],"length":1,"stats":{"Line":2}},{"line":98,"address":[12130254],"length":1,"stats":{"Line":0}},{"line":99,"address":[6578039,6578162],"length":1,"stats":{"Line":3}},{"line":101,"address":[9522278,9522625],"length":1,"stats":{"Line":3}},{"line":102,"address":[12130529],"length":1,"stats":{"Line":1}},{"line":103,"address":[9522489],"length":1,"stats":{"Line":1}},{"line":104,"address":[9412985],"length":1,"stats":{"Line":2}},{"line":105,"address":[],"length":0,"stats":{"Line":1}},{"line":106,"address":[8603617],"length":1,"stats":{"Line":2}},{"line":108,"address":[6578475],"length":1,"stats":{"Line":2}},{"line":111,"address":[9413493],"length":1,"stats":{"Line":1}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[12103568,12103655],"length":1,"stats":{"Line":4}},{"line":115,"address":[5731470],"length":1,"stats":{"Line":1}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[9522925,9523005],"length":1,"stats":{"Line":6}},{"line":124,"address":[9523032],"length":1,"stats":{"Line":1}},{"line":125,"address":[9413695],"length":1,"stats":{"Line":2}},{"line":131,"address":[],"length":0,"stats":{"Line":1}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[8604369,8604302,8604453],"length":1,"stats":{"Line":3}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[5843600,5843584],"length":1,"stats":{"Line":0}},{"line":138,"address":[9414712,9414142,9414227],"length":1,"stats":{"Line":2}},{"line":140,"address":[],"length":0,"stats":{"Line":2}},{"line":141,"address":[],"length":0,"stats":{"Line":1}}],"covered":38,"coverable":62},{"path":["/","home","vidyootsenthil","Documents","TheValut-nameTBD","crates","node","src","grpc","grpc_handler.rs"],"content":"use crate::swarm_manager::NetworkHandle;\nuse tonic::{Request, Response, Status};\n\nuse crate::grpc::grpc_operator;\n\n// Include the generated proto code\npub mod node_proto {\n    tonic::include_proto!(\"node\");\n}\n\nuse node_proto::{\n    node_control_server::{NodeControl, NodeControlServer},\n    *,\n};\n\npub struct NodeControlService {\n    network: NetworkHandle,\n}\n\nimpl NodeControlService {\n    pub fn new(network: NetworkHandle) -\u003e Self {\n        Self { network }\n    }\n\n    pub fn into_server(self) -\u003e NodeControlServer\u003cSelf\u003e {\n        NodeControlServer::new(self)\n    }\n}\n\n#[tonic::async_trait]\nimpl NodeControl for NodeControlService {\n    async fn spend_funds(\n        \u0026self,\n        request: Request\u003cSpendFundsRequest\u003e,\n    ) -\u003e Result\u003cResponse\u003cSpendFundsResponse\u003e, Status\u003e {\n        let request = request.into_inner();\n        let response = grpc_operator::spend_funds(\u0026self.network, request).await?;\n\n        Ok(Response::new(response))\n    }\n\n    async fn start_signing(\n        \u0026self,\n        request: Request\u003cStartSigningRequest\u003e,\n    ) -\u003e Result\u003cResponse\u003cStartSigningResponse\u003e, Status\u003e {\n        let request = request.into_inner();\n        let response = grpc_operator::start_signing(\u0026self.network, request).await?;\n\n        Ok(Response::new(response))\n    }\n\n    async fn create_deposit_intent(\n        \u0026self,\n        request: Request\u003cCreateDepositIntentRequest\u003e,\n    ) -\u003e Result\u003cResponse\u003cCreateDepositIntentResponse\u003e, Status\u003e {\n        let request = request.into_inner();\n        let response = grpc_operator::create_deposit_intent(\u0026self.network, request).await?;\n\n        Ok(Response::new(response))\n    }\n\n    async fn get_pending_deposit_intents(\n        \u0026self,\n        _request: Request\u003cGetPendingDepositIntentsRequest\u003e,\n    ) -\u003e Result\u003cResponse\u003cGetPendingDepositIntentsResponse\u003e, Status\u003e {\n        let response = grpc_operator::get_pending_deposit_intents(\u0026self.network).await?;\n        Ok(Response::new(response))\n    }\n}\n","traces":[{"line":21,"address":[8906992],"length":1,"stats":{"Line":0}},{"line":25,"address":[8032192],"length":1,"stats":{"Line":0}},{"line":26,"address":[8032200],"length":1,"stats":{"Line":0}},{"line":36,"address":[9043829],"length":1,"stats":{"Line":0}},{"line":37,"address":[8522741,8522799,8522886,8522487],"length":1,"stats":{"Line":0}},{"line":39,"address":[11846306,11846446],"length":1,"stats":{"Line":0}},{"line":46,"address":[8524181],"length":1,"stats":{"Line":0}},{"line":47,"address":[8160993],"length":1,"stats":{"Line":0}},{"line":49,"address":[9045984,9046108],"length":1,"stats":{"Line":0}},{"line":56,"address":[9046805],"length":1,"stats":{"Line":0}},{"line":57,"address":[11848359,11848830,11848725,11848671],"length":1,"stats":{"Line":0}},{"line":59,"address":[8526370,8526218],"length":1,"stats":{"Line":0}},{"line":66,"address":[7558797],"length":1,"stats":{"Line":0}},{"line":67,"address":[8527570,8527674],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":14},{"path":["/","home","vidyootsenthil","Documents","TheValut-nameTBD","crates","node","src","grpc","grpc_operator.rs"],"content":"use crate::deposit_intents::DepositIntent;\nuse crate::grpc::grpc_handler::node_proto::{\n    self, CreateDepositIntentRequest, CreateDepositIntentResponse,\n    GetPendingDepositIntentsResponse, SpendFundsRequest, SpendFundsResponse, StartSigningRequest,\n    StartSigningResponse,\n};\nuse crate::swarm_manager::{Network, NetworkHandle, SelfRequest, SelfResponse};\nuse bitcoin::Address;\nuse bitcoin::hashes::Hash;\nuse bitcoin::secp256k1::Scalar;\nuse libp2p::gossipsub::IdentTopic;\nuse serde_json;\nuse std::str::FromStr;\nuse tonic::Status;\nuse tracing::{debug, info};\nuse uuid::Uuid;\n\npub async fn spend_funds(\n    network: \u0026NetworkHandle,\n    request: SpendFundsRequest,\n) -\u003e Result\u003cSpendFundsResponse, Status\u003e {\n    let amount_sat = request.amount_satoshis;\n    let address_to = request.address_to;\n\n    debug!(\"Received request to spend {} satoshis\", amount_sat);\n    let response = network\n        .send_self_request(\n            SelfRequest::Spend {\n                amount_sat,\n                address_to,\n            },\n            true,\n        )\n        .map_err(|e| Status::internal(format!(\"Network error: {:?}\", e)))?\n        .ok_or(Status::internal(\"No response from node\"))?\n        .await\n        .map_err(|e| Status::internal(format!(\"Network error: {:?}\", e)))?;\n\n    let SelfResponse::SpendRequestSent { sighash } = response else {\n        return Err(Status::internal(\"Invalid response from node\"));\n    };\n\n    Ok(SpendFundsResponse {\n        success: true,\n        message: format!(\"Spending {} satoshis\", amount_sat),\n        sighash: sighash.to_string(),\n    })\n}\n\npub async fn start_signing(\n    network: \u0026NetworkHandle,\n    request: StartSigningRequest,\n) -\u003e Result\u003cStartSigningResponse, Status\u003e {\n    let hex_msg = request.hex_message;\n\n    let network_request = SelfRequest::StartSigningSession {\n        hex_message: hex_msg.clone(),\n    };\n\n    let response = network\n        .send_self_request(network_request, true)\n        .map_err(|e| Status::internal(format!(\"Network error: {:?}\", e)))?\n        .ok_or(Status::internal(\"No response from node\"))?\n        .await\n        .map_err(|e| Status::internal(format!(\"Network error: {:?}\", e)))?;\n\n    let SelfResponse::StartSigningSessionResponse { sign_id } = response else {\n        return Err(Status::internal(format!(\n            \"Invalid response from node {:?}\",\n            response\n        )));\n    };\n\n    Ok(StartSigningResponse {\n        success: true,\n        message: \"Signing session started\".to_string(),\n        sign_id,\n    })\n}\n\npub async fn create_deposit_intent(\n    network: \u0026impl Network,\n    request: CreateDepositIntentRequest,\n) -\u003e Result\u003cCreateDepositIntentResponse, Status\u003e {\n    let req = request;\n\n    let amount_sat = if req.amount_satoshis \u003e 0 {\n        req.amount_satoshis\n    } else {\n        return Err(Status::invalid_argument(\n            \"Amount to deposit must be greater than 0\",\n        ));\n    };\n\n    let deposit_tracking_id = Uuid::new_v4().to_string();\n    let frost_pubkey_hex = network\n        .send_self_request(SelfRequest::GetFrostPublicKey, true)\n        .map_err(|e| Status::internal(format!(\"Network error: {:?}\", e)))?\n        .ok_or(Status::internal(\"No response from node\"))?\n        .await\n        .map_err(|e| Status::internal(format!(\"Network error: {:?}\", e)))?;\n\n    let SelfResponse::GetFrostPublicKeyResponse {\n        public_key: Some(public_key),\n    } = frost_pubkey_hex\n    else {\n        return Err(Status::internal(\n            \"Invalid response from node. No public key found.\",\n        ));\n    };\n\n    let public_key = bitcoin::PublicKey::from_str(\u0026public_key)\n        .map_err(|e| Status::internal(format!(\"Failed to parse public key: {}\", e)))?;\n\n    let secp = bitcoin::secp256k1::Secp256k1::new();\n\n    let internal_key = public_key.inner.x_only_public_key().0;\n\n    let tweak_scalar = Scalar::from_be_bytes(\n        bitcoin::hashes::sha256::Hash::hash(deposit_tracking_id.as_bytes()).to_byte_array(),\n    )\n    .expect(\"32 bytes, should not fail\");\n\n    let (tweaked_key, _) = internal_key\n        .add_tweak(\u0026secp, \u0026tweak_scalar)\n        .map_err(|e| Status::internal(format!(\"Failed to add tweak: {:?}\", e)))?;\n\n    let deposit_address = Address::p2tr(\u0026secp, tweaked_key, None, bitcoin::Network::Testnet);\n\n    let deposit_intent = DepositIntent {\n        amount_sat,\n        deposit_tracking_id: deposit_tracking_id.clone(),\n        deposit_address: deposit_address.to_string(),\n        timestamp: std::time::SystemTime::now()\n            .duration_since(std::time::UNIX_EPOCH)\n            .unwrap()\n            .as_secs(),\n    };\n\n    let _ = network\n        .send_self_request(SelfRequest::CreateDeposit { deposit_intent }, true)\n        .map_err(|e| Status::internal(format!(\"Network error: {:?}\", e)))?\n        .ok_or(Status::internal(\"No response from node\"))?\n        .await\n        .map_err(|e| Status::internal(format!(\"Network error: {:?}\", e)))?;\n\n    let broadcast_message = serde_json::json!({\n        \"deposit_address\": deposit_address.to_string(),\n        \"amount_sat\": amount_sat,\n        \"deposit_tracking_id\": deposit_tracking_id,\n        \"timestamp\": std::time::SystemTime::now()\n            .duration_since(std::time::UNIX_EPOCH)\n            .unwrap()\n            .as_secs()\n    });\n\n    if let Err(e) = network.send_broadcast(\n        IdentTopic::new(\"deposit-intents\"),\n        broadcast_message.to_string().as_bytes().to_vec(),\n    ) {\n        info!(\"Failed to broadcast new deposit address: {:?}\", e);\n    }\n\n    info!(\n        \"Received request to create deposit intent with amount {}. Tracking ID: {}. Deposit Address: {}\",\n        amount_sat,\n        deposit_tracking_id.clone(),\n        deposit_address.clone().to_string()\n    );\n\n    Ok(CreateDepositIntentResponse {\n        success: true,\n        message: \"Deposit intent created\".to_string(),\n        deposit_tracking_id,\n        deposit_address: deposit_address.to_string(),\n    })\n}\n\npub async fn get_pending_deposit_intents(\n    network: \u0026impl Network,\n) -\u003e Result\u003cGetPendingDepositIntentsResponse, Status\u003e {\n    let intents = network\n        .send_self_request(SelfRequest::GetPendingDepositIntents, true)\n        .map_err(|e| Status::internal(format!(\"Network error: {:?}\", e)))?\n        .ok_or(Status::internal(\"No response from node\"))?\n        .await\n        .map_err(|e| Status::internal(format!(\"Network error: {:?}\", e)))?;\n\n    let SelfResponse::GetPendingDepositIntentsResponse { intents } = intents else {\n        return Err(Status::internal(\"Invalid response from node\"));\n    };\n\n    Ok(GetPendingDepositIntentsResponse {\n        intents: intents\n            .iter()\n            .map(|intent| node_proto::DepositIntent {\n                amount_satoshis: intent.amount_sat,\n                deposit_tracking_id: intent.deposit_tracking_id.clone(),\n                deposit_address: intent.deposit_address.clone(),\n                timestamp: intent.timestamp,\n            })\n            .collect(),\n    })\n}\n","traces":[{"line":18,"address":[11475440],"length":1,"stats":{"Line":0}},{"line":22,"address":[11792167],"length":1,"stats":{"Line":0}},{"line":23,"address":[7397547],"length":1,"stats":{"Line":0}},{"line":25,"address":[8973786,8974284,8973912],"length":1,"stats":{"Line":0}},{"line":26,"address":[12227404,12227626,12227692,12226745,12227567,12228195,12227913,12228253,12229312,12227261,12228375,12227768,12227857],"length":1,"stats":{"Line":0}},{"line":28,"address":[11792639],"length":1,"stats":{"Line":0}},{"line":29,"address":[7397948],"length":1,"stats":{"Line":0}},{"line":30,"address":[12226648],"length":1,"stats":{"Line":0}},{"line":34,"address":[11795366,11793309,11795344],"length":1,"stats":{"Line":0}},{"line":35,"address":[8975030,8975447,8975122,8974730,8975507,8974999,8975228],"length":1,"stats":{"Line":0}},{"line":36,"address":[11092004],"length":1,"stats":{"Line":0}},{"line":37,"address":[8244522,8244669,8244567],"length":1,"stats":{"Line":0}},{"line":39,"address":[11794492],"length":1,"stats":{"Line":0}},{"line":40,"address":[8976129,8976733],"length":1,"stats":{"Line":0}},{"line":43,"address":[11794826],"length":1,"stats":{"Line":0}},{"line":45,"address":[12228594,12228703],"length":1,"stats":{"Line":0}},{"line":46,"address":[11794755],"length":1,"stats":{"Line":0}},{"line":50,"address":[8634112],"length":1,"stats":{"Line":0}},{"line":54,"address":[11795967],"length":1,"stats":{"Line":0}},{"line":57,"address":[12230041],"length":1,"stats":{"Line":0}},{"line":60,"address":[11796161,11796765,11797980,11796362,11797257,11796815,11797080,11797135,11796679,11796228,11796522,11796581],"length":1,"stats":{"Line":0}},{"line":62,"address":[7403200,7403230,7401586],"length":1,"stats":{"Line":0}},{"line":63,"address":[7402084,7401714,7401894,7401833,7401745,7401469,7402140],"length":1,"stats":{"Line":0}},{"line":64,"address":[7402032,7401986,7402344,7402176,7401328],"length":1,"stats":{"Line":0}},{"line":65,"address":[11798262,11797250,11798240],"length":1,"stats":{"Line":0}},{"line":67,"address":[12231462],"length":1,"stats":{"Line":0}},{"line":68,"address":[12231528,12231849],"length":1,"stats":{"Line":0}},{"line":74,"address":[8979111],"length":1,"stats":{"Line":0}},{"line":76,"address":[8979001],"length":1,"stats":{"Line":0}},{"line":81,"address":[8980032],"length":1,"stats":{"Line":2}},{"line":87,"address":[12232828],"length":1,"stats":{"Line":2}},{"line":88,"address":[7404087],"length":1,"stats":{"Line":2}},{"line":90,"address":[11798852,11798972],"length":1,"stats":{"Line":0}},{"line":95,"address":[8980643,8980455],"length":1,"stats":{"Line":4}},{"line":96,"address":[11799380,11799134,11799602,11799772,11800227,11800413,11799164,11800285,11799935,11803572,11799543,11799876,11799690,11799231],"length":1,"stats":{"Line":18}},{"line":97,"address":[7404352],"length":1,"stats":{"Line":2}},{"line":98,"address":[5894704,5894726,5885255],"length":1,"stats":{"Line":0}},{"line":99,"address":[11799196,11799502,11799594,11800035,11799975,11799471,11799722],"length":1,"stats":{"Line":4}},{"line":100,"address":[12232866,12233946,12234119,12233881,12234307],"length":1,"stats":{"Line":8}},{"line":101,"address":[11809078,11800403,11809056],"length":1,"stats":{"Line":0}},{"line":103,"address":[12234632,12234671],"length":1,"stats":{"Line":4}},{"line":104,"address":[5886589],"length":1,"stats":{"Line":2}},{"line":107,"address":[11800631,11803520],"length":1,"stats":{"Line":0}},{"line":112,"address":[11800959,11800812,11803444,11800707],"length":1,"stats":{"Line":4}},{"line":113,"address":[7406070,7414240,7414224],"length":1,"stats":{"Line":0}},{"line":115,"address":[12235189],"length":1,"stats":{"Line":2}},{"line":117,"address":[11801279,11801201],"length":1,"stats":{"Line":4}},{"line":120,"address":[11801343],"length":1,"stats":{"Line":2}},{"line":124,"address":[12235812,12237490,12235593],"length":1,"stats":{"Line":2}},{"line":125,"address":[8983072],"length":1,"stats":{"Line":2}},{"line":126,"address":[7414368,7406859,7414393],"length":1,"stats":{"Line":0}},{"line":128,"address":[11801935],"length":1,"stats":{"Line":2}},{"line":132,"address":[8983653],"length":1,"stats":{"Line":2}},{"line":133,"address":[12236172],"length":1,"stats":{"Line":2}},{"line":134,"address":[12236250,12236335],"length":1,"stats":{"Line":4}},{"line":140,"address":[11802815,11803037,11803328,11802978,11803269,11803733,11803919,11808538,11802666,11802523,11802599,11803159,11803791],"length":1,"stats":{"Line":16}},{"line":141,"address":[11802535],"length":1,"stats":{"Line":2}},{"line":142,"address":[7407843,7414574,7414544],"length":1,"stats":{"Line":0}},{"line":143,"address":[8984489,8984183,8984458,8984581,8984962,8984658,8984908],"length":1,"stats":{"Line":4}},{"line":144,"address":[12237274,12237813,12232887,12237339,12237625],"length":1,"stats":{"Line":8}},{"line":145,"address":[7414814,7414784,7409049,7408942],"length":1,"stats":{"Line":2}},{"line":147,"address":[5889943,5890498,5890940,5890756,5890427,5891009,5894309,5890136,5891221,5890682,5889988,5890065],"length":1,"stats":{"Line":3}},{"line":148,"address":[5890031],"length":1,"stats":{"Line":2}},{"line":151,"address":[5891065,5890983],"length":1,"stats":{"Line":4}},{"line":157,"address":[12239572,12239903,12239852],"length":1,"stats":{"Line":3}},{"line":158,"address":[7410533],"length":1,"stats":{"Line":1}},{"line":159,"address":[7410754,7410674,7410595],"length":1,"stats":{"Line":3}},{"line":161,"address":[11805924,11806025,11806297],"length":1,"stats":{"Line":0}},{"line":164,"address":[12241490],"length":1,"stats":{"Line":0}},{"line":171,"address":[11808018],"length":1,"stats":{"Line":1}},{"line":173,"address":[7412075],"length":1,"stats":{"Line":1}},{"line":174,"address":[11807896],"length":1,"stats":{"Line":1}},{"line":175,"address":[5893832],"length":1,"stats":{"Line":1}},{"line":179,"address":[12244144],"length":1,"stats":{"Line":0}},{"line":182,"address":[8991827,8992870,8992299,8992464,8991934,8992240,8993050,8993810,8992928,8992077,8992553,8992388,8992609],"length":1,"stats":{"Line":0}},{"line":183,"address":[8991819],"length":1,"stats":{"Line":0}},{"line":184,"address":[8992030,8993824,8993846],"length":1,"stats":{"Line":0}},{"line":185,"address":[8992684,8991899,8992199,8992291,8992420,8992624,8992168],"length":1,"stats":{"Line":0}},{"line":186,"address":[7416230,7415919,7415870,7415258,7416056],"length":1,"stats":{"Line":0}},{"line":187,"address":[7536444,7536489,7536579],"length":1,"stats":{"Line":0}},{"line":189,"address":[11811663],"length":1,"stats":{"Line":0}},{"line":190,"address":[12245794,12246223],"length":1,"stats":{"Line":0}},{"line":193,"address":[11811913],"length":1,"stats":{"Line":0}},{"line":194,"address":[8993386,8993269],"length":1,"stats":{"Line":0}},{"line":196,"address":[7417710,7417568,7417782,7417776],"length":1,"stats":{"Line":0}},{"line":197,"address":[8994340],"length":1,"stats":{"Line":0}},{"line":198,"address":[7417613],"length":1,"stats":{"Line":0}},{"line":199,"address":[7417642],"length":1,"stats":{"Line":0}},{"line":200,"address":[7417706],"length":1,"stats":{"Line":0}}],"covered":35,"coverable":89},{"path":["/","home","vidyootsenthil","Documents","TheValut-nameTBD","crates","node","src","grpc","mod.rs"],"content":"pub mod grpc_handler;\npub mod grpc_operator;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","vidyootsenthil","Documents","TheValut-nameTBD","crates","node","src","handler.rs"],"content":"use std::any::Any;\n\nuse types::errors::NodeError;\n\nuse crate::{Network, NodeState, db::Db, swarm_manager::NetworkEvent};\n\n#[async_trait::async_trait]\npub trait Handler\u003cN: Network, D: Db\u003e: Send + Any {\n    async fn handle(\n        \u0026mut self,\n        node: \u0026mut NodeState\u003cN, D\u003e,\n        message: Option\u003cNetworkEvent\u003e,\n    ) -\u003e Result\u003c(), NodeError\u003e;\n}\n\nimpl\u003cN: Network, D: Db\u003e dyn Handler\u003cN, D\u003e {\n    pub fn downcast_ref\u003cT\u003e(\u0026self) -\u003e Option\u003c\u0026T\u003e\n    where\n        T: Any,\n    {\n        (self as \u0026dyn Any).downcast_ref::\u003cT\u003e()\n    }\n}\n","traces":[{"line":17,"address":[6559760],"length":1,"stats":{"Line":1}},{"line":21,"address":[],"length":0,"stats":{"Line":1}}],"covered":2,"coverable":2},{"path":["/","home","vidyootsenthil","Documents","TheValut-nameTBD","crates","node","src","key_manager.rs"],"content":"use std::{fs, path::PathBuf};\n\nuse crate::{ConfigStore, EncryptionParams, KeyStore, NodeConfig};\nuse aes_gcm::{Aes256Gcm, Key, KeyInit, Nonce, aead::Aead};\nuse argon2::{Argon2, password_hash::SaltString};\nuse base64::{Engine as _, engine::general_purpose::STANDARD as BASE64};\nuse directories::ProjectDirs;\nuse frost_secp256k1 as frost;\nuse libp2p::identity::Keypair;\nuse tracing::debug;\nuse types::errors::NodeError;\n\npub fn get_key_file_path() -\u003e Result\u003cPathBuf, NodeError\u003e {\n    let proj_dirs = ProjectDirs::from(\"\", \"\", \"TheVault\")\n        .ok_or_else(|| NodeError::Error(\"Failed to determine project directory\".into()))?;\n\n    let config_dir = proj_dirs.config_dir();\n    fs::create_dir_all(config_dir)\n        .map_err(|e| NodeError::Error(format!(\"Failed to create config directory: {}\", e)))?;\n\n    let path = config_dir.join(\"config.json\");\n    debug!(\"Using key file path: {}\", path.display());\n    Ok(path)\n}\n\npub fn get_config_file_path(file_path_option: Option\u003cString\u003e) -\u003e Result\u003cPathBuf, NodeError\u003e {\n    if let Some(file_path_str) = file_path_option {\n        let mut path = PathBuf::from(file_path_str);\n        if path.is_dir() {\n            path.push(\"config.yaml\");\n        }\n        println!(\"Using config file path: {}\", path.display());\n        Ok(path)\n    } else {\n        let proj_dirs = ProjectDirs::from(\"\", \"\", \"TheVault\")\n            .ok_or_else(|| NodeError::Error(\"Failed to determine project directory\".into()))?;\n        let config_dir = proj_dirs.config_dir();\n        Ok(config_dir.join(\"config.yaml\"))\n    }\n}\n\npub fn derive_key_from_password(password: \u0026str, salt_str: \u0026str) -\u003e Result\u003cVec\u003cu8\u003e, NodeError\u003e {\n    let argon2 = Argon2::default();\n    let password_bytes = password.as_bytes();\n    let salt = SaltString::from_b64(salt_str)\n        .map_err(|e| NodeError::Error(format!(\"Salt decoding failed: {}\", e)))?;\n\n    let mut key = vec![0u8; 32];\n    argon2\n        .hash_password_into(password_bytes, salt.as_str().as_bytes(), \u0026mut key)\n        .map_err(|e| NodeError::Error(format!(\"Argon2 key derivation failed: {}\", e)))?;\n    Ok(key)\n}\n\npub fn encrypt_private_key(\n    private_key_data: \u0026[u8],\n    password: \u0026str,\n    salt_b64: \u0026str,\n) -\u003e Result\u003c(String, String), NodeError\u003e {\n    let key_bytes = derive_key_from_password(password, salt_b64)?;\n\n    // Generate random IV\n    let mut iv = [0u8; 12];\n    use frost::rand_core::RngCore;\n    frost::rand_core::OsRng.fill_bytes(\u0026mut iv);\n    let nonce = Nonce::from_slice(\u0026iv);\n\n    let cipher = Aes256Gcm::new(Key::\u003cAes256Gcm\u003e::from_slice(\u0026key_bytes));\n    let ciphertext = cipher\n        .encrypt(nonce, private_key_data)\n        .map_err(|e| NodeError::Error(format!(\"AES encryption failed: {}\", e)))?;\n\n    let encrypted_b64 = BASE64.encode(ciphertext);\n    let iv_b64 = BASE64.encode(iv);\n\n    Ok((encrypted_b64, iv_b64))\n}\n\npub fn decrypt_private_key(\n    encrypted_private_key_b64: \u0026str,\n    password: \u0026str,\n    params: \u0026EncryptionParams,\n) -\u003e Result\u003cVec\u003cu8\u003e, NodeError\u003e {\n    let key_bytes = derive_key_from_password(password, \u0026params.salt_b64)?;\n\n    let iv_bytes = BASE64\n        .decode(\u0026params.iv_b64)\n        .map_err(|e| NodeError::Error(format!(\"IV decoding failed: {}\", e)))?;\n    let nonce = Nonce::from_slice(\u0026iv_bytes);\n\n    let ciphertext = BASE64\n        .decode(encrypted_private_key_b64)\n        .map_err(|e| NodeError::Error(format!(\"Ciphertext decoding failed: {}\", e)))?;\n\n    let cipher = Aes256Gcm::new(Key::\u003cAes256Gcm\u003e::from_slice(\u0026key_bytes));\n\n    let decrypted_private_key = cipher\n        .decrypt(nonce, ciphertext.as_ref())\n        .map_err(|e| NodeError::Error(format!(\"AES decryption failed: {}\", e)))?;\n\n    Ok(decrypted_private_key)\n}\n\npub fn get_password_from_prompt() -\u003e Result\u003cString, NodeError\u003e {\n    rpassword::prompt_password(\"Enter password to decrypt identity key: \")\n        .map_err(|e| NodeError::Error(e.to_string()))\n}\n\npub fn get_config(\n    key_file_path: Option\u003cString\u003e,\n    config_file_path: Option\u003cString\u003e,\n) -\u003e Result\u003cNodeConfig, NodeError\u003e {\n    let key_file_path = if let Some(key_path) = key_file_path {\n        PathBuf::from(key_path)\n    } else {\n        get_key_file_path()?\n    };\n\n    let config_file_path = if let Some(config_path) = config_file_path {\n        PathBuf::from(config_path)\n    } else {\n        get_config_file_path(None)?\n    };\n\n    debug!(\"Using key file path: {}\", key_file_path.display());\n\n    let key_contents = fs::read_to_string(\u0026key_file_path)\n        .map_err(|e| NodeError::Error(format!(\"Failed to read config file: {}\", e)))?;\n\n    let key_store = serde_json::from_str::\u003cKeyStore\u003e(\u0026key_contents)\n        .map_err(|e| NodeError::Error(format!(\"Failed to deserialize key file: {}\", e)))?;\n\n    let config_contents = fs::read_to_string(\u0026config_file_path)\n        .map_err(|e| NodeError::Error(format!(\"Failed to read config file: {}\", e)))?;\n\n    let config_store = serde_yaml::from_str::\u003cConfigStore\u003e(\u0026config_contents)\n        .map_err(|e| NodeError::Error(format!(\"Failed to deserialize config file: {}\", e)))?;\n\n    let node_config = NodeConfig {\n        key_data: key_store.key_data,\n        dkg_keys: key_store.dkg_keys,\n        allowed_peers: config_store.allowed_peers,\n        log_file_path: config_store.log_file_path,\n        key_file_path,\n        config_file_path,\n    };\n\n    debug!(\"Read config file\");\n\n    Ok(node_config)\n}\n\npub fn load_and_decrypt_keypair(config_data: \u0026NodeConfig) -\u003e Result\u003cKeypair, NodeError\u003e {\n    let password = match std::env::var(\"KEY_PASSWORD\") {\n        Ok(pw) =\u003e pw,\n        Err(_) =\u003e get_password_from_prompt()?,\n    };\n\n    let private_key_protobuf = decrypt_private_key(\n        \u0026config_data.key_data.encrypted_private_key_b64,\n        \u0026password,\n        \u0026config_data.key_data.encryption_params,\n    )?;\n\n    Keypair::from_protobuf_encoding(\u0026private_key_protobuf).map_err(|e| {\n        NodeError::Error(format!(\n            \"Failed to reconstruct keypair from protobuf: {}\",\n            e\n        ))\n    })\n}\n\npub fn load_dkg_keys(\n    config: NodeConfig,\n) -\u003e Result\u003c\n    Option\u003c(frost::keys::KeyPackage, frost::keys::PublicKeyPackage)\u003e,\n    Box\u003cdyn std::error::Error\u003e,\n\u003e {\n    if let Some(dkg_keys) = config.dkg_keys {\n        let password = match std::env::var(\"KEY_PASSWORD\") {\n            Ok(pw) =\u003e pw,\n            Err(_) =\u003e get_password_from_prompt()?,\n        };\n\n        let private_key_bytes = decrypt_private_key(\n            \u0026dkg_keys.encrypted_private_key_package_b64,\n            \u0026password,\n            \u0026dkg_keys.dkg_encryption_params,\n        )?;\n\n        let private_key = frost::keys::KeyPackage::deserialize(\u0026private_key_bytes)?;\n\n        let pubkey_bytes = BASE64.decode(\u0026dkg_keys.pubkey_package_b64)?;\n        let pubkey = frost::keys::PublicKeyPackage::deserialize(\u0026pubkey_bytes)?;\n\n        Ok(Some((private_key, pubkey)))\n    } else {\n        Ok(None)\n    }\n}\n","traces":[{"line":13,"address":[8510801,8509152,8510779],"length":1,"stats":{"Line":0}},{"line":14,"address":[8509175,8509357],"length":1,"stats":{"Line":0}},{"line":15,"address":[8714125],"length":1,"stats":{"Line":0}},{"line":17,"address":[8714390,8714303],"length":1,"stats":{"Line":0}},{"line":18,"address":[8714575,8714425],"length":1,"stats":{"Line":0}},{"line":19,"address":[7333184,7333206],"length":1,"stats":{"Line":0}},{"line":21,"address":[8509801],"length":1,"stats":{"Line":0}},{"line":22,"address":[8755610,8755683,8756024],"length":1,"stats":{"Line":0}},{"line":23,"address":[8755914],"length":1,"stats":{"Line":0}},{"line":26,"address":[8512017,8510816,8511525],"length":1,"stats":{"Line":0}},{"line":27,"address":[8756620],"length":1,"stats":{"Line":0}},{"line":28,"address":[8756720],"length":1,"stats":{"Line":0}},{"line":29,"address":[8715964,8715896],"length":1,"stats":{"Line":0}},{"line":30,"address":[8813582],"length":1,"stats":{"Line":0}},{"line":32,"address":[8756957,8757013],"length":1,"stats":{"Line":0}},{"line":33,"address":[8813772],"length":1,"stats":{"Line":0}},{"line":35,"address":[8716478,8715767,8716347],"length":1,"stats":{"Line":0}},{"line":36,"address":[10180976,10180990],"length":1,"stats":{"Line":0}},{"line":37,"address":[8814230,8814155],"length":1,"stats":{"Line":0}},{"line":38,"address":[8757622],"length":1,"stats":{"Line":0}},{"line":42,"address":[8757808,8758775,8758781],"length":1,"stats":{"Line":2}},{"line":43,"address":[8814504],"length":1,"stats":{"Line":1}},{"line":44,"address":[8512144],"length":1,"stats":{"Line":2}},{"line":45,"address":[8758086,8757957],"length":1,"stats":{"Line":1}},{"line":46,"address":[8717096],"length":1,"stats":{"Line":0}},{"line":48,"address":[8814894],"length":1,"stats":{"Line":2}},{"line":49,"address":[8512879,8512723],"length":1,"stats":{"Line":1}},{"line":50,"address":[8758381,8758298],"length":1,"stats":{"Line":3}},{"line":51,"address":[10728912,10728936],"length":1,"stats":{"Line":0}},{"line":52,"address":[8717726],"length":1,"stats":{"Line":1}},{"line":55,"address":[8816672,8816740,8815440],"length":1,"stats":{"Line":2}},{"line":60,"address":[8758930],"length":1,"stats":{"Line":1}},{"line":63,"address":[8718191],"length":1,"stats":{"Line":2}},{"line":65,"address":[8815782],"length":1,"stats":{"Line":1}},{"line":66,"address":[8815855],"length":1,"stats":{"Line":1}},{"line":68,"address":[8513513],"length":1,"stats":{"Line":1}},{"line":69,"address":[8815988,8816164,8816059],"length":1,"stats":{"Line":4}},{"line":71,"address":[7197745,7197728],"length":1,"stats":{"Line":0}},{"line":73,"address":[8759594],"length":1,"stats":{"Line":1}},{"line":74,"address":[8513996],"length":1,"stats":{"Line":1}},{"line":76,"address":[8514106],"length":1,"stats":{"Line":1}},{"line":79,"address":[8761551,8760080,8761525],"length":1,"stats":{"Line":0}},{"line":84,"address":[8719290],"length":1,"stats":{"Line":0}},{"line":86,"address":[8760394,8761549,8760557,8760476],"length":1,"stats":{"Line":0}},{"line":87,"address":[8719513],"length":1,"stats":{"Line":0}},{"line":88,"address":[10181584,10181600],"length":1,"stats":{"Line":0}},{"line":89,"address":[8514969,8515052],"length":1,"stats":{"Line":0}},{"line":91,"address":[8720038,8720718,8719907],"length":1,"stats":{"Line":0}},{"line":93,"address":[7334224,7334208],"length":1,"stats":{"Line":0}},{"line":95,"address":[8817782,8817699],"length":1,"stats":{"Line":0}},{"line":97,"address":[8720342,8720474],"length":1,"stats":{"Line":0}},{"line":98,"address":[8515438],"length":1,"stats":{"Line":0}},{"line":99,"address":[10729584,10729601],"length":1,"stats":{"Line":0}},{"line":101,"address":[8720540],"length":1,"stats":{"Line":0}},{"line":104,"address":[8515936],"length":1,"stats":{"Line":0}},{"line":105,"address":[8761581],"length":1,"stats":{"Line":0}},{"line":106,"address":[10729778,10729760],"length":1,"stats":{"Line":0}},{"line":109,"address":[8521612,8521076,8516000],"length":1,"stats":{"Line":0}},{"line":113,"address":[8761686,8762207],"length":1,"stats":{"Line":0}},{"line":114,"address":[8516316,8516221],"length":1,"stats":{"Line":0}},{"line":116,"address":[8761868,8762017,8766981],"length":1,"stats":{"Line":0}},{"line":119,"address":[8721416,8721809,8721148],"length":1,"stats":{"Line":0}},{"line":120,"address":[8819124,8819031],"length":1,"stats":{"Line":0}},{"line":122,"address":[8819163,8819048,8823767],"length":1,"stats":{"Line":0}},{"line":125,"address":[8516748,8517046,8517341],"length":1,"stats":{"Line":0}},{"line":127,"address":[8766856,8763609,8762935,8763525],"length":1,"stats":{"Line":0}},{"line":128,"address":[7334710,7334688],"length":1,"stats":{"Line":0}},{"line":130,"address":[8726127,8722930,8723013,8723163],"length":1,"stats":{"Line":0}},{"line":131,"address":[8820699],"length":1,"stats":{"Line":0}},{"line":133,"address":[8764066,8766750,8764214,8764130],"length":1,"stats":{"Line":0}},{"line":134,"address":[8518618],"length":1,"stats":{"Line":0}},{"line":136,"address":[8518972,8518751,8518822],"length":1,"stats":{"Line":0}},{"line":137,"address":[8764488],"length":1,"stats":{"Line":0}},{"line":140,"address":[8821561],"length":1,"stats":{"Line":0}},{"line":141,"address":[8519313],"length":1,"stats":{"Line":0}},{"line":142,"address":[8821833],"length":1,"stats":{"Line":0}},{"line":143,"address":[8724305],"length":1,"stats":{"Line":0}},{"line":148,"address":[8822450,8822765,8822377],"length":1,"stats":{"Line":0}},{"line":150,"address":[8520332],"length":1,"stats":{"Line":0}},{"line":153,"address":[8824995,8824976,8824032],"length":1,"stats":{"Line":0}},{"line":154,"address":[8726494],"length":1,"stats":{"Line":0}},{"line":155,"address":[8824118],"length":1,"stats":{"Line":0}},{"line":156,"address":[8726528,8726696],"length":1,"stats":{"Line":0}},{"line":160,"address":[8767608],"length":1,"stats":{"Line":0}},{"line":161,"address":[8727003],"length":1,"stats":{"Line":0}},{"line":162,"address":[8727045],"length":1,"stats":{"Line":0}},{"line":165,"address":[10183470,10183248],"length":1,"stats":{"Line":0}},{"line":166,"address":[10731010,10730950],"length":1,"stats":{"Line":0}},{"line":173,"address":[8525366,8522672,8524963],"length":1,"stats":{"Line":4}},{"line":179,"address":[8522715,8522972],"length":1,"stats":{"Line":12}},{"line":180,"address":[8825405,8825291],"length":1,"stats":{"Line":0}},{"line":181,"address":[8727873],"length":1,"stats":{"Line":0}},{"line":182,"address":[8768714,8768527],"length":1,"stats":{"Line":0}},{"line":186,"address":[8768928],"length":1,"stats":{"Line":0}},{"line":187,"address":[8769023],"length":1,"stats":{"Line":0}},{"line":188,"address":[8825972],"length":1,"stats":{"Line":0}},{"line":191,"address":[8728688,8729787,8728605],"length":1,"stats":{"Line":0}},{"line":193,"address":[8728928,8729785],"length":1,"stats":{"Line":0}},{"line":194,"address":[8729143,8729226],"length":1,"stats":{"Line":0}},{"line":196,"address":[8770124],"length":1,"stats":{"Line":0}},{"line":198,"address":[8768434],"length":1,"stats":{"Line":4}}],"covered":21,"coverable":101},{"path":["/","home","vidyootsenthil","Documents","TheValut-nameTBD","crates","node","src","lib.rs"],"content":"use crate::{\n    db::Db, deposit_intents::DepositIntentState, dkg::DkgState, handler::Handler,\n    signing::SigningState,\n};\nuse aes_gcm::{Aes256Gcm, Key, KeyInit, Nonce, aead::Aead};\nuse argon2::{\n    Argon2,\n    password_hash::{\n        SaltString,\n        rand_core::{OsRng, RngCore},\n    },\n};\nuse base64::{Engine as _, engine::general_purpose::STANDARD as BASE64};\nuse frost_secp256k1::{self as frost, Identifier};\nuse libp2p::{PeerId, identity::Keypair};\nuse serde::{Deserialize, Serialize};\nuse std::{collections::HashSet, fs, path::PathBuf};\nuse swarm_manager::{Network, NetworkEvent};\nuse tokio::sync::broadcast;\nuse tracing::error;\nuse types::errors::NodeError;\n\npub mod db;\npub mod deposit_intents;\npub mod dkg;\npub mod grpc;\npub mod handler;\npub mod key_manager;\npub mod main_loop;\npub mod signing;\npub mod start_node;\npub mod swarm_manager;\npub mod wallet;\n\n#[derive(Clone, Serialize, Deserialize, PartialEq)]\npub struct PeerData {\n    pub name: String,\n    pub public_key: String,\n}\n\n#[derive(Clone, Serialize, Deserialize)]\npub struct DkgKeys {\n    pub encrypted_private_key_package_b64: String,\n    pub dkg_encryption_params: EncryptionParams,\n    pub pubkey_package_b64: String,\n}\n\n#[derive(Clone, Serialize, Deserialize)]\npub struct EncryptionParams {\n    pub kdf: String,\n    pub salt_b64: String,\n    pub iv_b64: String,\n}\n\n#[derive(Clone, Serialize, Deserialize)]\npub struct KeyData {\n    pub public_key_b58: String,\n    pub encrypted_private_key_b64: String,\n    pub encryption_params: EncryptionParams,\n}\n\n#[derive(Clone, Serialize, Deserialize)]\npub struct NodeConfig {\n    pub allowed_peers: Vec\u003cPeerData\u003e,\n    pub key_data: KeyData,\n    pub dkg_keys: Option\u003cDkgKeys\u003e,\n    pub log_file_path: Option\u003cPathBuf\u003e,\n    #[serde(skip)]\n    key_file_path: PathBuf,\n    #[serde(skip)]\n    config_file_path: PathBuf,\n}\n\n#[derive(Serialize, Deserialize)]\npub struct KeyStore {\n    key_data: KeyData,\n    dkg_keys: Option\u003cDkgKeys\u003e,\n}\n\n#[derive(Serialize, Deserialize)]\npub struct ConfigStore {\n    allowed_peers: Vec\u003cPeerData\u003e,\n    log_file_path: Option\u003cPathBuf\u003e,\n    key_file_path: PathBuf,\n}\n\nimpl NodeConfig {\n    pub fn new(\n        key_file_path: PathBuf,\n        config_file_path: PathBuf,\n        log_file_path: Option\u003cPathBuf\u003e,\n        password: \u0026str,\n    ) -\u003e Result\u003cSelf, NodeError\u003e {\n        // Generate a new keypair\n        let keypair = Keypair::generate_ed25519();\n        let public_key_b58 = keypair.public().to_peer_id().to_base58();\n\n        // Generate salt for encryption\n        let salt = SaltString::generate(\u0026mut OsRng);\n        let salt_b64 = salt.to_string();\n\n        // Derive encryption key from password\n        let argon2 = Argon2::default();\n        let mut key_bytes = vec![0u8; 32];\n        argon2\n            .hash_password_into(\n                password.as_bytes(),\n                salt.as_str().as_bytes(),\n                \u0026mut key_bytes,\n            )\n            .map_err(|e| NodeError::Error(format!(\"Argon2 key derivation failed: {}\", e)))?;\n\n        // Generate random IV for AES encryption\n        let mut iv = [0u8; 12];\n        frost::rand_core::OsRng.fill_bytes(\u0026mut iv);\n        let nonce = Nonce::from_slice(\u0026iv);\n\n        // Get private key bytes\n        let private_key_bytes = keypair\n            .to_protobuf_encoding()\n            .map_err(|e| NodeError::Error(format!(\"Failed to encode private key: {}\", e)))?;\n\n        // Encrypt the private key\n        let cipher = Aes256Gcm::new(Key::\u003cAes256Gcm\u003e::from_slice(\u0026key_bytes));\n        let ciphertext = cipher\n            .encrypt(nonce, private_key_bytes.as_ref())\n            .map_err(|e| NodeError::Error(format!(\"AES encryption failed: {}\", e)))?;\n\n        let encrypted_private_key_b64 = BASE64.encode(ciphertext);\n        let iv_b64 = BASE64.encode(iv);\n\n        let key_data = KeyData {\n            public_key_b58,\n            encrypted_private_key_b64,\n            encryption_params: EncryptionParams {\n                kdf: \"argon2id\".to_string(),\n                salt_b64,\n                iv_b64,\n            },\n        };\n\n        Ok(NodeConfig {\n            allowed_peers: Vec::new(),\n            key_data,\n            dkg_keys: None,\n            log_file_path,\n            key_file_path,\n            config_file_path,\n        })\n    }\n\n    pub fn save_to_file(\u0026self) -\u003e Result\u003c(), NodeError\u003e {\n        let key_store = KeyStore {\n            key_data: self.key_data.clone(),\n            dkg_keys: self.dkg_keys.clone(),\n        };\n\n        let key_info_str = serde_json::to_string_pretty(\u0026key_store)\n            .map_err(|e| NodeError::Error(format!(\"Failed to serialize key data: {}\", e)))?;\n\n        fs::write(\u0026self.key_file_path, key_info_str)\n            .map_err(|e| NodeError::Error(format!(\"Failed to write key data: {}\", e)))?;\n\n        let config_store = ConfigStore {\n            allowed_peers: self.allowed_peers.clone(),\n            log_file_path: self.log_file_path.clone(),\n            key_file_path: self.key_file_path.clone(),\n        };\n\n        let config_str: String = serde_yaml::to_string(\u0026config_store).unwrap();\n\n        fs::write(\u0026self.config_file_path, config_str)\n            .map_err(|e| NodeError::Error(format!(\"Failed to write config: {}\", e)))?;\n\n        Ok(())\n    }\n\n    pub fn set_dkg_keys(\u0026mut self, dkg_keys: DkgKeys) {\n        self.dkg_keys = Some(dkg_keys);\n    }\n\n    pub fn set_key_data(\u0026mut self, key_data: KeyData) {\n        self.key_data = key_data;\n    }\n}\n\npub struct NodeState\u003cN: Network, D: Db\u003e {\n    pub handlers: Vec\u003cBox\u003cdyn Handler\u003cN, D\u003e\u003e\u003e,\n    pub db: D,\n\n    pub peer_id: PeerId,\n    pub peers: HashSet\u003cPeerId\u003e,\n\n    pub min_signers: u16,\n    pub max_signers: u16,\n    pub rng: frost::rand_core::OsRng,\n    pub pubkey_package: Option\u003cfrost::keys::PublicKeyPackage\u003e,\n    pub private_key_package: Option\u003cfrost::keys::KeyPackage\u003e,\n\n    // FROST signing\n    pub wallet: crate::wallet::SimpleWallet,\n\n    pub config: NodeConfig,\n\n    pub network_handle: N,\n\n    pub network_events_stream: broadcast::Receiver\u003cNetworkEvent\u003e,\n    // track deposits and then send new addresses over a channel to the polling thread\n}\n\nimpl\u003cN: Network, D: Db\u003e NodeState\u003cN, D\u003e {\n    pub fn new_from_config(\n        network_handle: N,\n        min_signers: u16,\n        max_signers: u16,\n        config: NodeConfig,\n        storage_db: D,\n        network_events_sender: broadcast::Sender\u003cNetworkEvent\u003e,\n        deposit_intent_tx: broadcast::Sender\u003cString\u003e,\n    ) -\u003e Result\u003cSelf, NodeError\u003e {\n        let keys = key_manager::load_dkg_keys(config.clone())\n            .map_err(|e| NodeError::Error(format!(\"Failed to load DKG keys: {}\", e)))?;\n        let dkg_state = DkgState::new()?;\n        let signing_state = SigningState::new()?;\n        let deposit_intent_state = DepositIntentState::new(deposit_intent_tx);\n\n        let mut node_state = NodeState {\n            network_handle: network_handle.clone(),\n            network_events_stream: network_events_sender.subscribe(),\n            peer_id: network_handle.peer_id(),\n            min_signers,\n            max_signers,\n            db: storage_db,\n            peers: HashSet::new(),\n            rng: frost::rand_core::OsRng,\n            wallet: crate::wallet::SimpleWallet::default(),\n            config,\n            handlers: vec![\n                Box::new(dkg_state),\n                Box::new(signing_state),\n                Box::new(deposit_intent_state),\n            ],\n            pubkey_package: None,\n            private_key_package: None,\n        };\n\n        if let Some((private_key, pubkey)) = keys {\n            node_state.private_key_package = Some(private_key);\n            node_state.pubkey_package = Some(pubkey);\n        }\n\n        Ok(node_state)\n    }\n}\n\npub fn peer_id_to_identifier(peer_id: \u0026PeerId) -\u003e Identifier {\n    let bytes = peer_id.to_bytes();\n    match Identifier::derive(\u0026bytes) {\n        Ok(identifier) =\u003e identifier,\n        Err(e) =\u003e {\n            error!(\"Failed to derive identifier: {}\", e);\n            panic!(\"Failed to derive identifier\");\n        }\n    }\n}\n","traces":[{"line":88,"address":[8774795,8775267,8771440],"length":1,"stats":{"Line":3}},{"line":95,"address":[9170175],"length":1,"stats":{"Line":8}},{"line":96,"address":[8771667,8771735],"length":1,"stats":{"Line":11}},{"line":99,"address":[8771797],"length":1,"stats":{"Line":1}},{"line":100,"address":[7384405],"length":1,"stats":{"Line":10}},{"line":103,"address":[9211500],"length":1,"stats":{"Line":1}},{"line":104,"address":[9170613],"length":1,"stats":{"Line":10}},{"line":105,"address":[9211852,9214568,9212011],"length":1,"stats":{"Line":5}},{"line":107,"address":[9170662],"length":1,"stats":{"Line":1}},{"line":108,"address":[9170758],"length":1,"stats":{"Line":2}},{"line":109,"address":[8772190],"length":1,"stats":{"Line":6}},{"line":111,"address":[8611632,8611656],"length":1,"stats":{"Line":0}},{"line":114,"address":[9171096],"length":1,"stats":{"Line":5}},{"line":115,"address":[9171119],"length":1,"stats":{"Line":6}},{"line":116,"address":[8772495],"length":1,"stats":{"Line":5}},{"line":119,"address":[8772672,8772537,8774966],"length":1,"stats":{"Line":3}},{"line":121,"address":[10929094,10929072],"length":1,"stats":{"Line":0}},{"line":124,"address":[8772765,8772848],"length":1,"stats":{"Line":5}},{"line":125,"address":[7385476,7385583],"length":1,"stats":{"Line":2}},{"line":126,"address":[9212488],"length":1,"stats":{"Line":3}},{"line":127,"address":[8773079],"length":1,"stats":{"Line":0}},{"line":129,"address":[9171868,9171983],"length":1,"stats":{"Line":5}},{"line":130,"address":[7385799,7385897],"length":1,"stats":{"Line":5}},{"line":135,"address":[9213283],"length":1,"stats":{"Line":3}},{"line":142,"address":[7386706],"length":1,"stats":{"Line":4}},{"line":143,"address":[9172579],"length":1,"stats":{"Line":3}},{"line":144,"address":[7386467],"length":1,"stats":{"Line":3}},{"line":145,"address":[8774156],"length":1,"stats":{"Line":4}},{"line":146,"address":[9172820],"length":1,"stats":{"Line":3}},{"line":147,"address":[9213795],"length":1,"stats":{"Line":4}},{"line":148,"address":[9172882],"length":1,"stats":{"Line":4}},{"line":152,"address":[8775312,8776896,8776928],"length":1,"stats":{"Line":1}},{"line":154,"address":[9214950],"length":1,"stats":{"Line":2}},{"line":155,"address":[8775372],"length":1,"stats":{"Line":1}},{"line":158,"address":[8775853,8775683,8775748,8776926],"length":1,"stats":{"Line":3}},{"line":159,"address":[10372768,10372790],"length":1,"stats":{"Line":0}},{"line":161,"address":[9175558,9174732,9174615,9174852],"length":1,"stats":{"Line":3}},{"line":162,"address":[9215764],"length":1,"stats":{"Line":0}},{"line":165,"address":[9174886],"length":1,"stats":{"Line":1}},{"line":166,"address":[9174917],"length":1,"stats":{"Line":1}},{"line":167,"address":[8776336],"length":1,"stats":{"Line":1}},{"line":170,"address":[9216166,9216095],"length":1,"stats":{"Line":2}},{"line":172,"address":[9175417,9175261],"length":1,"stats":{"Line":1}},{"line":173,"address":[7525766,7525744],"length":1,"stats":{"Line":0}},{"line":175,"address":[9175458],"length":1,"stats":{"Line":1}},{"line":178,"address":[7389434,7389296],"length":1,"stats":{"Line":2}},{"line":179,"address":[8777125,8776968],"length":1,"stats":{"Line":3}},{"line":182,"address":[9216768,9216824],"length":1,"stats":{"Line":0}},{"line":183,"address":[7389522,7389591],"length":1,"stats":{"Line":0}},{"line":212,"address":[10930272,10933486,10934095],"length":1,"stats":{"Line":4}},{"line":221,"address":[],"length":0,"stats":{"Line":9}},{"line":222,"address":[5703952,5700613,5703978],"length":1,"stats":{"Line":0}},{"line":223,"address":[5700841,5703610,5700766],"length":1,"stats":{"Line":9}},{"line":224,"address":[7526870,7526930],"length":1,"stats":{"Line":11}},{"line":225,"address":[],"length":0,"stats":{"Line":14}},{"line":228,"address":[10374789],"length":1,"stats":{"Line":4}},{"line":229,"address":[5701574,5701490],"length":1,"stats":{"Line":11}},{"line":230,"address":[7527402],"length":1,"stats":{"Line":7}},{"line":234,"address":[7527537],"length":1,"stats":{"Line":4}},{"line":236,"address":[10375144],"length":1,"stats":{"Line":7}},{"line":238,"address":[10931976,10932109,10932429,10933619,10932037,10932245],"length":1,"stats":{"Line":11}},{"line":247,"address":[7528772,7529209],"length":1,"stats":{"Line":4}},{"line":248,"address":[10376456],"length":1,"stats":{"Line":0}},{"line":249,"address":[5703293,5703223,5703094],"length":1,"stats":{"Line":0}},{"line":252,"address":[10933266],"length":1,"stats":{"Line":7}},{"line":256,"address":[7390714,7389616,7390720],"length":1,"stats":{"Line":1}},{"line":257,"address":[7389641],"length":1,"stats":{"Line":3}},{"line":258,"address":[9217068,9216996],"length":1,"stats":{"Line":6}},{"line":259,"address":[8777593],"length":1,"stats":{"Line":3}},{"line":260,"address":[7389847],"length":1,"stats":{"Line":0}},{"line":261,"address":[7389895,7390000,7390252],"length":1,"stats":{"Line":0}},{"line":262,"address":[7390686,7390223],"length":1,"stats":{"Line":0}}],"covered":58,"coverable":72},{"path":["/","home","vidyootsenthil","Documents","TheValut-nameTBD","crates","node","src","main_loop.rs"],"content":"use tracing::info;\n\nuse crate::db::Db;\nuse crate::swarm_manager::{NetworkEvent, SelfRequest, SelfResponse};\nuse crate::{Network, NodeState};\nuse types::errors::NodeError;\n\nimpl\u003cN: Network + 'static, D: Db + 'static\u003e NodeState\u003cN, D\u003e {\n    pub async fn try_poll(\u0026mut self) -\u003e Result\u003cbool, NodeError\u003e {\n        let send_message = self.network_events_stream.try_recv().ok();\n        if let Some(event) = send_message {\n            self.handle(Some(event)).await?;\n            Ok(true)\n        } else {\n            Ok(false)\n        }\n    }\n\n    pub async fn poll(\u0026mut self) -\u003e Result\u003c(), NodeError\u003e {\n        let send_message = self.network_events_stream.recv().await.ok();\n        self.handle(send_message).await\n    }\n\n    pub async fn start(\u0026mut self) -\u003e Result\u003c(), NodeError\u003e {\n        info!(\"Local peer id: {}\", self.peer_id);\n\n        loop {\n            self.poll().await?\n        }\n    }\n\n    pub async fn handle(\u0026mut self, send_message: Option\u003cNetworkEvent\u003e) -\u003e Result\u003c(), NodeError\u003e {\n        let mut handlers = std::mem::take(\u0026mut self.handlers);\n\n        for handler in handlers.iter_mut() {\n            handler.handle(self, send_message.clone()).await?;\n        }\n\n        self.handlers = handlers;\n        match send_message {\n            Some(NetworkEvent::SelfRequest {\n                request: SelfRequest::GetFrostPublicKey,\n                response_channel,\n            }) =\u003e {\n                let response = self.get_frost_public_key();\n                if let Some(response_channel) = response_channel {\n                    response_channel\n                        .send(SelfResponse::GetFrostPublicKeyResponse {\n                            public_key: response,\n                        })\n                        .map_err(|e| NodeError::Error(format!(\"Failed to send response: {}\", e)))?;\n                }\n            }\n            Some(NetworkEvent::PeersConnected(list)) =\u003e {\n                for (peer_id, _multiaddr) in list {\n                    self.peers.insert(peer_id);\n                }\n            }\n            _ =\u003e {}\n        }\n        Ok(())\n    }\n}\n","traces":[{"line":9,"address":[5704368,5704376],"length":1,"stats":{"Line":11}},{"line":10,"address":[],"length":0,"stats":{"Line":7}},{"line":11,"address":[],"length":0,"stats":{"Line":7}},{"line":12,"address":[],"length":0,"stats":{"Line":7}},{"line":13,"address":[6529929],"length":1,"stats":{"Line":2}},{"line":15,"address":[],"length":0,"stats":{"Line":2}},{"line":19,"address":[9480635,9480758,9481115,9480580,9480483,9480448],"length":1,"stats":{"Line":0}},{"line":20,"address":[12585127,12584993,12585055,12585232],"length":1,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[12587265,12586005,12585875,12585840,12585965,12586748],"length":1,"stats":{"Line":0}},{"line":25,"address":[12585940,12586056,12586298],"length":1,"stats":{"Line":0}},{"line":27,"address":[9482688],"length":1,"stats":{"Line":0}},{"line":28,"address":[12199910,12199934,12200277,12199403,12199128],"length":1,"stats":{"Line":0}},{"line":32,"address":[10928771,10928736],"length":1,"stats":{"Line":9}},{"line":33,"address":[9483244,9483089],"length":1,"stats":{"Line":2}},{"line":35,"address":[6524999,6525633,6525101],"length":1,"stats":{"Line":3}},{"line":36,"address":[8150884],"length":1,"stats":{"Line":3}},{"line":39,"address":[12588567,12588488],"length":1,"stats":{"Line":6}},{"line":40,"address":[9484246,9484422],"length":1,"stats":{"Line":2}},{"line":41,"address":[12202138],"length":1,"stats":{"Line":2}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[12589048,12589150],"length":1,"stats":{"Line":4}},{"line":46,"address":[12202294],"length":1,"stats":{"Line":2}},{"line":47,"address":[],"length":0,"stats":{"Line":4}},{"line":48,"address":[12589257],"length":1,"stats":{"Line":2}},{"line":49,"address":[12589217],"length":1,"stats":{"Line":2}},{"line":51,"address":[9487072,9485038,9487094],"length":1,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":2}},{"line":55,"address":[9485494,9484524,9485359],"length":1,"stats":{"Line":7}},{"line":56,"address":[9044321],"length":1,"stats":{"Line":1}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":3}}],"covered":22,"coverable":34},{"path":["/","home","vidyootsenthil","Documents","TheValut-nameTBD","crates","node","src","signing","create_signature.rs"],"content":"use rand::seq::SliceRandom;\nuse std::collections::BTreeMap;\n\nuse frost_secp256k1::rand_core::RngCore;\nuse frost_secp256k1::{self as frost};\nuse hex;\nuse libp2p::PeerId;\nuse tracing::{debug, error, info, warn};\n\nuse crate::NodeState;\nuse crate::db::Db;\nuse crate::signing::ActiveSigning;\nuse crate::swarm_manager::{DirectMessage, Network};\nuse crate::{peer_id_to_identifier, signing::SigningState};\nuse types::errors::NodeError;\n\nimpl SigningState {\n    pub fn start_signing_session\u003cN: Network, D: Db\u003e(\n        \u0026mut self,\n        node: \u0026mut NodeState\u003cN, D\u003e,\n        message_hex: \u0026str,\n    ) -\u003e Result\u003cOption\u003cu64\u003e, NodeError\u003e {\n        if node.private_key_package.is_none() || node.pubkey_package.is_none() {\n            error!(\"❌ DKG not completed – cannot start signing\");\n            return Err(NodeError::Error(\"DKG not completed\".to_string()));\n        }\n\n        let Ok(message) = hex::decode(message_hex.trim()) else {\n            error!(\"❌ Invalid hex message\");\n            return Err(NodeError::Error(\"Invalid hex message\".to_string()));\n        };\n        if message.len() != 32 {\n            error!(\n                \"❌ Message must be 32-byte (sighash) – got {} bytes\",\n                message.len()\n            );\n            return Err(NodeError::Error(\n                \"Message must be 32-byte (sighash)\".to_string(),\n            ));\n        }\n\n        info!(\"Starting signing session for message: {}\", message_hex);\n\n        if self.active_signing.is_some() {\n            error!(\"❌ A signing session is already active\");\n            return Err(NodeError::Error(\n                \"A signing session is already active\".to_string(),\n            ));\n        }\n\n        let sign_id = node.rng.next_u64();\n        let self_identifier = peer_id_to_identifier(\u0026node.peer_id);\n\n        // Select participants: self + first (min_signers -1) peers\n        let required = (node.min_signers - 1) as usize;\n        if node.peers.len() \u003c required {\n            error!(\"❌ Not enough peers – need at least {} others\", required);\n            return Err(NodeError::Error(\"Not enough peers\".to_string()));\n        }\n        // Randomly shuffle peers and pick required number\n        let mut rng_rand = rand::rng();\n        let mut peer_pool = node.peers.clone().into_iter().collect::\u003cVec\u003c_\u003e\u003e();\n        peer_pool.shuffle(\u0026mut rng_rand);\n\n        let selected_peers: Vec\u003cPeerId\u003e = peer_pool.into_iter().take(required).collect();\n\n        let mut participants: Vec\u003c_\u003e = Vec::new();\n        participants.push(self_identifier);\n        for peer in \u0026selected_peers {\n            participants.push(peer_id_to_identifier(peer));\n        }\n\n        // Generate nonces \u0026 commitments for self\n        let key_pkg = match node.private_key_package.as_ref() {\n            Some(key_pkg) =\u003e key_pkg.clone(),\n            None =\u003e {\n                return Err(NodeError::Error(\"No private key found\".to_string()));\n            }\n        };\n        let (nonces, commitments) = frost::round1::commit(key_pkg.signing_share(), \u0026mut node.rng);\n\n        let mut commitments_map = BTreeMap::new();\n        commitments_map.insert(self_identifier, commitments);\n\n        // Save active session\n        self.active_signing = Some(ActiveSigning {\n            sign_id,\n            message: message.clone(),\n            selected_peers: selected_peers.clone(),\n            nonces,\n            commitments: commitments_map,\n            signature_shares: BTreeMap::new(),\n            signing_package: None,\n            is_coordinator: true,\n        });\n\n        // Broadcast SignRequest to chosen peers (skip self)\n        for peer in \u0026selected_peers {\n            let req = DirectMessage::SignRequest {\n                sign_id,\n                message: message.clone(),\n            };\n            node.network_handle\n                .send_private_message(*peer, req)\n                .map_err(|e| {\n                    NodeError::Error(format!(\"Failed to send private request: {:?}\", e))\n                })?;\n        }\n\n        Ok(Some(sign_id))\n    }\n\n    /// Handle incoming SignRequest (participant side)\n    pub fn handle_sign_request\u003cN: Network, D: Db\u003e(\n        \u0026mut self,\n        node: \u0026mut NodeState\u003cN, D\u003e,\n        peer: PeerId,\n        sign_id: u64,\n        message: Vec\u003cu8\u003e,\n    ) -\u003e Result\u003c(), NodeError\u003e {\n        if node.private_key_package.is_none() {\n            let _ = node.network_handle.send_private_message(\n                peer,\n                DirectMessage::Commitments {\n                    sign_id,\n                    commitments: Vec::new(),\n                },\n            );\n            return Ok(());\n        }\n\n        let key_pkg = match node.private_key_package.as_ref() {\n            Some(key_pkg) =\u003e key_pkg.clone(),\n            None =\u003e {\n                return Err(NodeError::Error(\"No private key found\".to_string()));\n            }\n        };\n        let (nonces, commitments) = frost::round1::commit(key_pkg.signing_share(), \u0026mut node.rng);\n\n        // Save session (one at a time for simplicity)\n        self.active_signing = Some(ActiveSigning {\n            sign_id,\n            message: message.clone(),\n            selected_peers: Vec::new(),\n            nonces,\n            commitments: BTreeMap::new(), // not used for participant\n            signature_shares: BTreeMap::new(),\n            signing_package: None,\n            is_coordinator: false,\n        });\n\n        let Ok(commit_bytes) = commitments.serialize() else {\n            return Err(NodeError::Error(\n                \"Failed to serialize commitments\".to_string(),\n            ));\n        };\n\n        let resp = DirectMessage::Commitments {\n            sign_id,\n            commitments: commit_bytes,\n        };\n        let _ = node.network_handle.send_private_message(peer, resp);\n\n        debug!(\n            \"🔐 Provided commitments for sign_id {} to {}\",\n            sign_id, peer\n        );\n\n        Ok(())\n    }\n\n    /// Coordinator receives commitments responses\n    pub fn handle_commitments_response\u003cN: Network, D: Db\u003e(\n        \u0026mut self,\n        node: \u0026mut NodeState\u003cN, D\u003e,\n        peer: PeerId,\n        sign_id: u64,\n        commitments_bytes: Vec\u003cu8\u003e,\n    ) -\u003e Result\u003c(), NodeError\u003e {\n        let Some(active) = self.active_signing.as_mut() else {\n            return Err(NodeError::Error(\"No active session\".to_string()));\n        };\n        if !active.is_coordinator || active.sign_id != sign_id {\n            return Err(NodeError::Error(\"Session id mismatch\".to_string()));\n        }\n\n        let Ok(commitments) = frost::round1::SigningCommitments::deserialize(\u0026commitments_bytes)\n        else {\n            warn!(\"Failed to deserialize commitments from {}\", peer);\n            return Err(NodeError::Error(\n                \"Failed to deserialize commitments\".to_string(),\n            ));\n        };\n        let identifier = peer_id_to_identifier(\u0026peer);\n        active.commitments.insert(identifier, commitments);\n        debug!(\n            \"📩 Received commitments from {} (total {}/{})\",\n            peer,\n            active.commitments.len(),\n            node.min_signers\n        );\n\n        if active.commitments.len() == node.min_signers as usize {\n            // Build signing package\n            let signing_package =\n                frost::SigningPackage::new(active.commitments.clone(), \u0026active.message);\n            active.signing_package = Some(signing_package.clone());\n            let Ok(pkg_bytes) = signing_package.serialize() else {\n                warn!(\"Failed to serialize signing package\");\n                return Err(NodeError::Error(\n                    \"Failed to serialize signing package\".to_string(),\n                ));\n            };\n\n            // Send package to participants (excluding self)\n            for peer in \u0026active.selected_peers {\n                let req = DirectMessage::SignPackage {\n                    sign_id,\n                    package: pkg_bytes.clone(),\n                };\n                let _ = node.network_handle.send_private_message(*peer, req);\n            }\n\n            // Generate our signature share\n            let sig_share = frost::round2::sign(\n                \u0026signing_package,\n                \u0026active.nonces,\n                match node.private_key_package.as_ref() {\n                    Some(key_pkg) =\u003e key_pkg,\n                    None =\u003e {\n                        return Err(NodeError::Error(\"No private key found\".to_string()));\n                    }\n                },\n            );\n            match sig_share {\n                Ok(sig_share) =\u003e {\n                    active\n                        .signature_shares\n                        .insert(peer_id_to_identifier(\u0026node.peer_id), sig_share);\n                }\n                Err(e) =\u003e {\n                    return Err(NodeError::Error(format!(\"Failed to sign: {}\", e)));\n                }\n            }\n\n            debug!(\"📦 Distributed signing package for session {}\", sign_id);\n        }\n\n        Ok(())\n    }\n\n    /// Participant handles SignPackage request\n    pub fn handle_sign_package\u003cN: Network, D: Db\u003e(\n        \u0026mut self,\n        node: \u0026mut NodeState\u003cN, D\u003e,\n        peer: PeerId,\n        sign_id: u64,\n        package_bytes: Vec\u003cu8\u003e,\n    ) -\u003e Result\u003c(), NodeError\u003e {\n        let Some(active) = self.active_signing.as_ref() else {\n            warn!(\"No active session to sign\");\n            return Err(NodeError::Error(\"No active session\".to_string()));\n        };\n        if active.sign_id != sign_id {\n            warn!(\"Session id mismatch\");\n            return Err(NodeError::Error(\"Session id mismatch\".to_string()));\n        }\n\n        let Ok(signing_package) = frost::SigningPackage::deserialize(\u0026package_bytes) else {\n            warn!(\"Failed to deserialize signing package\");\n            return Err(NodeError::Error(\n                \"Failed to deserialize signing package\".to_string(),\n            ));\n        };\n\n        let sig_share = frost::round2::sign(\n            \u0026signing_package,\n            \u0026active.nonces,\n            match node.private_key_package.as_ref() {\n                Some(key_pkg) =\u003e key_pkg,\n                None =\u003e {\n                    return Err(NodeError::Error(\"No private key found\".to_string()));\n                }\n            },\n        );\n        match sig_share {\n            Ok(sig_share) =\u003e {\n                let sig_bytes = sig_share.serialize();\n                let resp = DirectMessage::SignatureShare {\n                    sign_id,\n                    signature_share: sig_bytes,\n                };\n                let _ = node.network_handle.send_private_message(peer, resp);\n            }\n            Err(e) =\u003e {\n                return Err(NodeError::Error(format!(\"Failed to sign: {}\", e)));\n            }\n        }\n\n        debug!(\n            \"✍️  Sent signature share for session {} to {}\",\n            sign_id, peer\n        );\n        self.active_signing = None;\n\n        Ok(())\n    }\n\n    /// Coordinator handles incoming signature share\n    pub fn handle_signature_share\u003cN: Network, D: Db\u003e(\n        \u0026mut self,\n        node: \u0026mut NodeState\u003cN, D\u003e,\n        peer: PeerId,\n        sign_id: u64,\n        sig_bytes: Vec\u003cu8\u003e,\n    ) -\u003e Result\u003c(), NodeError\u003e {\n        let Some(active) = self.active_signing.as_mut() else {\n            return Err(NodeError::Error(\"No active session\".to_string()));\n        };\n        if !active.is_coordinator || active.sign_id != sign_id {\n            return Err(NodeError::Error(\"Session id mismatch\".to_string()));\n        }\n\n        let Ok(sig_share) = frost::round2::SignatureShare::deserialize(\u0026sig_bytes) else {\n            warn!(\"Failed to deserialize signature share from {}\", peer);\n            return Err(NodeError::Error(\n                \"Failed to deserialize signature share\".to_string(),\n            ));\n        };\n        let identifier = peer_id_to_identifier(\u0026peer);\n        active.signature_shares.insert(identifier, sig_share);\n        debug!(\n            \"✅ Received signature share from {} (total {}/{})\",\n            peer,\n            active.signature_shares.len(),\n            node.min_signers\n        );\n\n        if active.signature_shares.len() == node.min_signers as usize {\n            let signing_package = match active.signing_package.clone() {\n                Some(signing_package) =\u003e signing_package,\n                None =\u003e {\n                    return Err(NodeError::Error(\"No signing package found\".to_string()));\n                }\n            };\n            let group_sig = frost::aggregate(\n                \u0026signing_package,\n                \u0026active.signature_shares,\n                match node.pubkey_package.as_ref() {\n                    Some(public_key) =\u003e public_key,\n                    None =\u003e {\n                        return Err(NodeError::Error(\"No public key found\".to_string()));\n                    }\n                },\n            )\n            .expect(\"Aggregate\");\n            let sig_hex = hex::encode(group_sig.serialize().expect(\"serialize group sig\"));\n            debug!(\n                \"🎉 Final FROST signature for session {}: {}\",\n                sign_id, sig_hex\n            );\n\n            // If this signing session corresponds to a pending spend, finalise the transaction.\n            if let Some(pending) = self.pending_spends.remove(\u0026sign_id) {\n                match Self::frost_signature_to_bitcoin(\u0026group_sig) {\n                    Ok(bitcoin_sig) =\u003e {\n                        let mut tx = pending.tx;\n                        let mut witness = bitcoin::witness::Witness::new();\n                        witness.push(bitcoin_sig.as_ref());\n                        if let Some(input) = tx.input.first_mut() {\n                            input.witness = witness;\n                        }\n                        let raw_tx = bitcoin::consensus::encode::serialize(\u0026tx);\n                        debug!(\"📤 Signed transaction (hex): {}\", hex::encode(raw_tx));\n                    }\n                    Err(e) =\u003e debug!(\"❌ Failed to convert signature: {}\", e),\n                }\n            }\n            // Reset\n            self.active_signing = None;\n        }\n\n        Ok(())\n    }\n}\n","traces":[{"line":18,"address":[10138987,10134688,10141592],"length":1,"stats":{"Line":1}},{"line":23,"address":[6986369],"length":1,"stats":{"Line":1}},{"line":24,"address":[9771501,9763821,9771226],"length":1,"stats":{"Line":0}},{"line":25,"address":[6187642],"length":1,"stats":{"Line":0}},{"line":28,"address":[6180141,6180262],"length":1,"stats":{"Line":2}},{"line":29,"address":[6986546,6993062,6993337],"length":1,"stats":{"Line":0}},{"line":30,"address":[9770734],"length":1,"stats":{"Line":0}},{"line":32,"address":[6986689,6986610],"length":1,"stats":{"Line":2}},{"line":33,"address":[9600682],"length":1,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[6186744],"length":1,"stats":{"Line":0}},{"line":38,"address":[9769959],"length":1,"stats":{"Line":0}},{"line":42,"address":[9594619,9594685,9594979],"length":1,"stats":{"Line":2}},{"line":44,"address":[9594958,9595452],"length":1,"stats":{"Line":2}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[9764938,9765011],"length":1,"stats":{"Line":2}},{"line":52,"address":[9595547],"length":1,"stats":{"Line":1}},{"line":55,"address":[9765053,9765134],"length":1,"stats":{"Line":1}},{"line":56,"address":[9595636,9595690],"length":1,"stats":{"Line":2}},{"line":57,"address":[6990873,6987783,6990574],"length":1,"stats":{"Line":0}},{"line":58,"address":[6990839,6991343],"length":1,"stats":{"Line":0}},{"line":61,"address":[10136196,10136262],"length":1,"stats":{"Line":2}},{"line":62,"address":[10136270,10136340],"length":1,"stats":{"Line":2}},{"line":63,"address":[10136402,10136494],"length":1,"stats":{"Line":2}},{"line":65,"address":[10136513],"length":1,"stats":{"Line":1}},{"line":67,"address":[10136642],"length":1,"stats":{"Line":1}},{"line":68,"address":[9765681],"length":1,"stats":{"Line":1}},{"line":69,"address":[],"length":0,"stats":{"Line":1}},{"line":70,"address":[],"length":0,"stats":{"Line":2}},{"line":74,"address":[9596506],"length":1,"stats":{"Line":1}},{"line":75,"address":[],"length":0,"stats":{"Line":1}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[9766089],"length":1,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":1}},{"line":82,"address":[],"length":0,"stats":{"Line":1}},{"line":83,"address":[],"length":0,"stats":{"Line":1}},{"line":86,"address":[9767094,9766790],"length":1,"stats":{"Line":1}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":1}},{"line":89,"address":[10137610],"length":1,"stats":{"Line":1}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[6989186],"length":1,"stats":{"Line":1}},{"line":92,"address":[10137725],"length":1,"stats":{"Line":1}},{"line":93,"address":[6183066],"length":1,"stats":{"Line":1}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":1}},{"line":101,"address":[6183618],"length":1,"stats":{"Line":1}},{"line":103,"address":[9598151,9598217,9598387],"length":1,"stats":{"Line":2}},{"line":104,"address":[6990143],"length":1,"stats":{"Line":1}},{"line":105,"address":[9255214,9254992],"length":1,"stats":{"Line":0}},{"line":106,"address":[9255074,9255014],"length":1,"stats":{"Line":0}},{"line":110,"address":[6183671],"length":1,"stats":{"Line":1}},{"line":114,"address":[6994352,6996719,6997064],"length":1,"stats":{"Line":1}},{"line":121,"address":[10142983,10143064],"length":1,"stats":{"Line":2}},{"line":122,"address":[6177381,6179793],"length":1,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[10143120],"length":1,"stats":{"Line":0}},{"line":129,"address":[9774626],"length":1,"stats":{"Line":0}},{"line":132,"address":[9772123,9772054],"length":1,"stats":{"Line":2}},{"line":133,"address":[],"length":0,"stats":{"Line":1}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[9602728],"length":1,"stats":{"Line":0}},{"line":138,"address":[6177634],"length":1,"stats":{"Line":1}},{"line":141,"address":[],"length":0,"stats":{"Line":1}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":1}},{"line":144,"address":[],"length":0,"stats":{"Line":1}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[6177854],"length":1,"stats":{"Line":1}},{"line":147,"address":[9603146],"length":1,"stats":{"Line":1}},{"line":148,"address":[9772688],"length":1,"stats":{"Line":1}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":2}},{"line":153,"address":[6996772],"length":1,"stats":{"Line":0}},{"line":154,"address":[9604833],"length":1,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":2}},{"line":164,"address":[],"length":0,"stats":{"Line":1}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[6996168],"length":1,"stats":{"Line":1}},{"line":173,"address":[9605200,9609521,9611339],"length":1,"stats":{"Line":1}},{"line":180,"address":[9774856,9774777],"length":1,"stats":{"Line":2}},{"line":181,"address":[9774930,9780723],"length":1,"stats":{"Line":0}},{"line":183,"address":[9605534,9605447],"length":1,"stats":{"Line":2}},{"line":184,"address":[10151651,10145988],"length":1,"stats":{"Line":0}},{"line":187,"address":[9775031,9775179],"length":1,"stats":{"Line":2}},{"line":188,"address":[],"length":0,"stats":{"Line":0}},{"line":189,"address":[6997528,7002162,7002419],"length":1,"stats":{"Line":0}},{"line":190,"address":[],"length":0,"stats":{"Line":0}},{"line":191,"address":[],"length":0,"stats":{"Line":0}},{"line":194,"address":[10146213],"length":1,"stats":{"Line":1}},{"line":195,"address":[6997620],"length":1,"stats":{"Line":1}},{"line":196,"address":[6196745],"length":1,"stats":{"Line":0}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":0}},{"line":203,"address":[],"length":0,"stats":{"Line":2}},{"line":205,"address":[10147389,10150821],"length":1,"stats":{"Line":1}},{"line":206,"address":[],"length":0,"stats":{"Line":0}},{"line":207,"address":[9607062,9607141],"length":1,"stats":{"Line":2}},{"line":208,"address":[9776805,9776890],"length":1,"stats":{"Line":2}},{"line":209,"address":[],"length":0,"stats":{"Line":0}},{"line":210,"address":[10150714],"length":1,"stats":{"Line":0}},{"line":211,"address":[7001597],"length":1,"stats":{"Line":0}},{"line":216,"address":[9776922,9777013],"length":1,"stats":{"Line":2}},{"line":219,"address":[],"length":0,"stats":{"Line":1}},{"line":221,"address":[],"length":0,"stats":{"Line":1}},{"line":226,"address":[],"length":0,"stats":{"Line":0}},{"line":227,"address":[10148204],"length":1,"stats":{"Line":1}},{"line":228,"address":[6999560],"length":1,"stats":{"Line":1}},{"line":229,"address":[6198117],"length":1,"stats":{"Line":1}},{"line":230,"address":[],"length":0,"stats":{"Line":0}},{"line":231,"address":[],"length":0,"stats":{"Line":0}},{"line":235,"address":[6999827],"length":1,"stats":{"Line":1}},{"line":236,"address":[9777571],"length":1,"stats":{"Line":1}},{"line":237,"address":[10148643,10148691],"length":1,"stats":{"Line":2}},{"line":238,"address":[],"length":0,"stats":{"Line":0}},{"line":239,"address":[],"length":0,"stats":{"Line":1}},{"line":241,"address":[],"length":0,"stats":{"Line":0}},{"line":242,"address":[6999905,7000924],"length":1,"stats":{"Line":0}},{"line":246,"address":[9778072,9777750],"length":1,"stats":{"Line":1}},{"line":249,"address":[9776333],"length":1,"stats":{"Line":1}},{"line":253,"address":[9613781,9616132,9611360],"length":1,"stats":{"Line":1}},{"line":260,"address":[10151946,10152017],"length":1,"stats":{"Line":2}},{"line":261,"address":[],"length":0,"stats":{"Line":0}},{"line":262,"address":[10156109,10156540],"length":1,"stats":{"Line":0}},{"line":264,"address":[7003388],"length":1,"stats":{"Line":1}},{"line":265,"address":[7006660,7003473,7006403],"length":1,"stats":{"Line":0}},{"line":266,"address":[9615295,9614862],"length":1,"stats":{"Line":0}},{"line":269,"address":[],"length":0,"stats":{"Line":3}},{"line":270,"address":[9783593,9783259],"length":1,"stats":{"Line":0}},{"line":271,"address":[9784016],"length":1,"stats":{"Line":0}},{"line":272,"address":[9614087],"length":1,"stats":{"Line":0}},{"line":277,"address":[],"length":0,"stats":{"Line":0}},{"line":278,"address":[10152370],"length":1,"stats":{"Line":1}},{"line":279,"address":[6173004,6172926],"length":1,"stats":{"Line":2}},{"line":280,"address":[6173051],"length":1,"stats":{"Line":1}},{"line":281,"address":[],"length":0,"stats":{"Line":0}},{"line":282,"address":[10152553],"length":1,"stats":{"Line":0}},{"line":286,"address":[6173241],"length":1,"stats":{"Line":1}},{"line":287,"address":[9612293],"length":1,"stats":{"Line":1}},{"line":288,"address":[10152837],"length":1,"stats":{"Line":1}},{"line":293,"address":[],"length":0,"stats":{"Line":1}},{"line":295,"address":[10152711],"length":1,"stats":{"Line":0}},{"line":296,"address":[10152759,10154062],"length":1,"stats":{"Line":0}},{"line":300,"address":[9612904,9612564],"length":1,"stats":{"Line":1}},{"line":301,"address":[],"length":0,"stats":{"Line":0}},{"line":302,"address":[],"length":0,"stats":{"Line":0}},{"line":304,"address":[6173918,6174453],"length":1,"stats":{"Line":1}},{"line":306,"address":[10154010],"length":1,"stats":{"Line":1}},{"line":310,"address":[9621530,9616160,9623538],"length":1,"stats":{"Line":1}},{"line":317,"address":[10156761,10156856],"length":1,"stats":{"Line":2}},{"line":318,"address":[10163946,10156930],"length":1,"stats":{"Line":0}},{"line":320,"address":[7008163,7008250],"length":1,"stats":{"Line":2}},{"line":321,"address":[9623354,9616468],"length":1,"stats":{"Line":0}},{"line":324,"address":[9616535,9616650],"length":1,"stats":{"Line":2}},{"line":325,"address":[10163049,10163306,10157107],"length":1,"stats":{"Line":0}},{"line":326,"address":[7014914],"length":1,"stats":{"Line":0}},{"line":327,"address":[],"length":0,"stats":{"Line":0}},{"line":330,"address":[9786170],"length":1,"stats":{"Line":1}},{"line":331,"address":[10157221],"length":1,"stats":{"Line":1}},{"line":332,"address":[9786319,9786656,9786915],"length":1,"stats":{"Line":0}},{"line":333,"address":[],"length":0,"stats":{"Line":0}},{"line":334,"address":[],"length":0,"stats":{"Line":0}},{"line":335,"address":[],"length":0,"stats":{"Line":0}},{"line":336,"address":[],"length":0,"stats":{"Line":0}},{"line":339,"address":[9617155,9617809],"length":1,"stats":{"Line":2}},{"line":340,"address":[9617869],"length":1,"stats":{"Line":1}},{"line":341,"address":[],"length":0,"stats":{"Line":1}},{"line":342,"address":[],"length":0,"stats":{"Line":0}},{"line":343,"address":[6190100],"length":1,"stats":{"Line":0}},{"line":347,"address":[],"length":0,"stats":{"Line":0}},{"line":348,"address":[7009797],"length":1,"stats":{"Line":1}},{"line":349,"address":[9787563,9787785],"length":1,"stats":{"Line":2}},{"line":350,"address":[7010076],"length":1,"stats":{"Line":1}},{"line":351,"address":[],"length":0,"stats":{"Line":0}},{"line":352,"address":[9618403],"length":1,"stats":{"Line":0}},{"line":357,"address":[9618565],"length":1,"stats":{"Line":1}},{"line":358,"address":[9788526,9788137,9788216],"length":1,"stats":{"Line":2}},{"line":359,"address":[],"length":0,"stats":{"Line":0}},{"line":360,"address":[],"length":0,"stats":{"Line":0}},{"line":364,"address":[6190997,6191539,6194294],"length":1,"stats":{"Line":2}},{"line":365,"address":[10160168,10160258],"length":1,"stats":{"Line":0}},{"line":366,"address":[9789317],"length":1,"stats":{"Line":0}},{"line":367,"address":[9619909],"length":1,"stats":{"Line":0}},{"line":368,"address":[10160485],"length":1,"stats":{"Line":0}},{"line":369,"address":[7011724,7011809],"length":1,"stats":{"Line":0}},{"line":370,"address":[9620136,9620462],"length":1,"stats":{"Line":0}},{"line":371,"address":[],"length":0,"stats":{"Line":0}},{"line":373,"address":[],"length":0,"stats":{"Line":0}},{"line":374,"address":[7012508,7012224,7012148],"length":1,"stats":{"Line":0}},{"line":376,"address":[9789254,9791052],"length":1,"stats":{"Line":0}},{"line":380,"address":[],"length":0,"stats":{"Line":1}},{"line":383,"address":[],"length":0,"stats":{"Line":1}}],"covered":102,"coverable":200},{"path":["/","home","vidyootsenthil","Documents","TheValut-nameTBD","crates","node","src","signing","handler.rs"],"content":"use crate::NodeState;\nuse crate::db::Db;\nuse crate::handler::Handler;\nuse crate::signing::SigningState;\nuse crate::swarm_manager::{DirectMessage, Network, NetworkEvent, SelfRequest, SelfResponse};\nuse types::errors::NodeError;\n\n#[async_trait::async_trait]\nimpl\u003cN: Network, D: Db\u003e Handler\u003cN, D\u003e for SigningState {\n    async fn handle(\n        \u0026mut self,\n        node: \u0026mut NodeState\u003cN, D\u003e,\n        message: Option\u003cNetworkEvent\u003e,\n    ) -\u003e Result\u003c(), NodeError\u003e {\n        match message {\n            Some(NetworkEvent::SelfRequest {\n                request: SelfRequest::StartSigningSession { hex_message },\n                ..\n            }) =\u003e {\n                let _ = self.start_signing_session(node, \u0026hex_message)?;\n            }\n            Some(NetworkEvent::SelfRequest {\n                request:\n                    SelfRequest::Spend {\n                        amount_sat,\n                        address_to,\n                    },\n                response_channel,\n            }) =\u003e {\n                let response = self.start_spend_request(node, amount_sat, \u0026address_to);\n                if let Some(response_channel) = response_channel {\n                    response_channel\n                        .send(SelfResponse::SpendRequestSent {\n                            sighash: response.unwrap_or(\"No sighash\".to_string()),\n                        })\n                        .map_err(|e| NodeError::Error(format!(\"Failed to send response: {}\", e)))?;\n                }\n            }\n            Some(NetworkEvent::MessageEvent((\n                peer,\n                DirectMessage::SignRequest { sign_id, message },\n            ))) =\u003e self.handle_sign_request(node, peer, sign_id, message)?,\n            Some(NetworkEvent::MessageEvent((\n                peer,\n                DirectMessage::SignPackage { sign_id, package },\n            ))) =\u003e self.handle_sign_package(node, peer, sign_id, package)?,\n            Some(NetworkEvent::MessageEvent((\n                peer,\n                DirectMessage::Commitments {\n                    sign_id,\n                    commitments,\n                },\n            ))) =\u003e self.handle_commitments_response(node, peer, sign_id, commitments)?,\n            Some(NetworkEvent::MessageEvent((\n                peer,\n                DirectMessage::SignatureShare {\n                    sign_id,\n                    signature_share,\n                },\n            ))) =\u003e self.handle_signature_share(node, peer, sign_id, signature_share)?,\n            _ =\u003e (),\n        }\n\n        Ok(())\n    }\n}\n","traces":[{"line":15,"address":[8729301,8729495],"length":1,"stats":{"Line":2}},{"line":16,"address":[7334089],"length":1,"stats":{"Line":1}},{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[8729909,8729653],"length":1,"stats":{"Line":2}},{"line":22,"address":[7334177],"length":1,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[6231322],"length":1,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[8730599],"length":1,"stats":{"Line":0}},{"line":34,"address":[8730954,8730409,8730507],"length":1,"stats":{"Line":0}},{"line":36,"address":[8734534,8734512,8730809],"length":1,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":1}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[7335887],"length":1,"stats":{"Line":1}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[8731884,8732574],"length":1,"stats":{"Line":1}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":1}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":1}}],"covered":8,"coverable":41},{"path":["/","home","vidyootsenthil","Documents","TheValut-nameTBD","crates","node","src","signing","mod.rs"],"content":"pub mod create_signature;\npub mod handler;\npub mod utils;\nuse std::collections::BTreeMap;\n\nuse frost_secp256k1::{self as frost, Identifier};\nuse libp2p::PeerId;\n\n// Active signing session tracking\npub struct ActiveSigning {\n    pub sign_id: u64,\n    pub message: Vec\u003cu8\u003e,\n    pub selected_peers: Vec\u003cPeerId\u003e,\n    pub nonces: frost::round1::SigningNonces,\n    pub commitments: BTreeMap\u003cIdentifier, frost::round1::SigningCommitments\u003e,\n    pub signature_shares: BTreeMap\u003cIdentifier, frost::round2::SignatureShare\u003e,\n    pub signing_package: Option\u003cfrost::SigningPackage\u003e,\n    pub is_coordinator: bool,\n}\n\npub struct SigningState {\n    pub active_signing: Option\u003cActiveSigning\u003e,\n    pub pending_spends: std::collections::BTreeMap\u003cu64, crate::wallet::PendingSpend\u003e,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","vidyootsenthil","Documents","TheValut-nameTBD","crates","node","src","signing","utils.rs"],"content":"use std::{collections::BTreeMap, str::FromStr};\n\nuse frost_secp256k1::{self as frost};\nuse tracing::{error, info};\nuse types::errors::NodeError;\n\nuse crate::{NodeState, db::Db, signing::SigningState, swarm_manager::Network};\n\nimpl SigningState {\n    pub fn new() -\u003e Result\u003cSelf, NodeError\u003e {\n        Ok(SigningState {\n            active_signing: None,\n            pending_spends: BTreeMap::new(),\n        })\n    }\n\n    pub fn frost_signature_to_bitcoin(\n        frost_sig: \u0026frost::Signature,\n    ) -\u003e Result\u003cbitcoin::secp256k1::schnorr::Signature, String\u003e {\n        let sig_bytes = frost_sig\n            .serialize()\n            .map_err(|e| format!(\"Serialize frost sig: {}\", e))?;\n\n        let schnorr_bytes = match sig_bytes.len() {\n            64 =\u003e sig_bytes,\n            65 =\u003e sig_bytes[..64].to_vec(),\n            _ =\u003e return Err(format!(\"Unsupported signature len {}\", sig_bytes.len())),\n        };\n\n        bitcoin::secp256k1::schnorr::Signature::from_slice(\u0026schnorr_bytes)\n            .map_err(|e| format!(\"Parse schnorr sig: {}\", e))\n    }\n\n    pub fn start_spend_request\u003cN: Network, D: Db\u003e(\n        \u0026mut self,\n        node: \u0026mut NodeState\u003cN, D\u003e,\n        amount_sat: u64,\n        address: \u0026str,\n    ) -\u003e Option\u003cString\u003e {\n        info!(\"🚀 Creating spend request for {} sat\", amount_sat);\n        let address = bitcoin::Address::from_str(address).ok()?.assume_checked();\n        match node.wallet.create_spend(amount_sat, \u0026address) {\n            Ok((tx, sighash)) =\u003e {\n                let sighash_hex = hex::encode(sighash);\n                match self.start_signing_session(node, \u0026sighash_hex) {\n                    Ok(_) =\u003e (),\n                    Err(e) =\u003e {\n                        error!(\"❌ Failed to start signing session: {}\", e);\n                        return None;\n                    }\n                }\n\n                if let Some(active) = \u0026self.active_signing {\n                    self.pending_spends\n                        .insert(active.sign_id, crate::wallet::PendingSpend { tx });\n                    info!(\"🚀 Spend request prepared (session id {})\", active.sign_id);\n\n                    Some(hex::encode(sighash))\n                } else {\n                    error!(\"❌ Failed to start signing session\");\n                    None\n                }\n            }\n            Err(e) =\u003e {\n                error!(\"❌ Failed to create spend transaction: {}\", e);\n                None\n            }\n        }\n    }\n}\n","traces":[{"line":10,"address":[6096496,6096288,6096490],"length":1,"stats":{"Line":4}},{"line":11,"address":[9295362],"length":1,"stats":{"Line":7}},{"line":12,"address":[9295291],"length":1,"stats":{"Line":7}},{"line":13,"address":[8821491],"length":1,"stats":{"Line":4}},{"line":17,"address":[9254194,9253344,9253980],"length":1,"stats":{"Line":0}},{"line":20,"address":[9253484,9253369],"length":1,"stats":{"Line":0}},{"line":22,"address":[9253445],"length":1,"stats":{"Line":0}},{"line":24,"address":[9253569,9253636],"length":1,"stats":{"Line":0}},{"line":25,"address":[9253681],"length":1,"stats":{"Line":0}},{"line":26,"address":[9253806,9253730],"length":1,"stats":{"Line":0}},{"line":27,"address":[8821997,8822335],"length":1,"stats":{"Line":0}},{"line":30,"address":[9253888,9253768],"length":1,"stats":{"Line":0}},{"line":31,"address":[6238504,6238480],"length":1,"stats":{"Line":0}},{"line":34,"address":[7015216,7019476,7019482],"length":1,"stats":{"Line":0}},{"line":40,"address":[9793413,9793119],"length":1,"stats":{"Line":0}},{"line":41,"address":[7015511,7016048],"length":1,"stats":{"Line":0}},{"line":42,"address":[6202564],"length":1,"stats":{"Line":0}},{"line":43,"address":[9624587],"length":1,"stats":{"Line":0}},{"line":44,"address":[10165187],"length":1,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[6205149,6203090,6205415],"length":1,"stats":{"Line":0}},{"line":49,"address":[9627291],"length":1,"stats":{"Line":0}},{"line":53,"address":[7016674,7018133],"length":1,"stats":{"Line":0}},{"line":54,"address":[9794699,9794546],"length":1,"stats":{"Line":0}},{"line":55,"address":[7016736,7016941],"length":1,"stats":{"Line":0}},{"line":56,"address":[10165800,10166162],"length":1,"stats":{"Line":0}},{"line":58,"address":[7017783,7017248],"length":1,"stats":{"Line":0}},{"line":60,"address":[6204605,6204314,6203361],"length":1,"stats":{"Line":0}},{"line":61,"address":[9626484],"length":1,"stats":{"Line":0}},{"line":64,"address":[9624524],"length":1,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}}],"covered":4,"coverable":34},{"path":["/","home","vidyootsenthil","Documents","TheValut-nameTBD","crates","node","src","start_node.rs"],"content":"use types::errors::NodeError;\n\nuse crate::{\n    NodeConfig, NodeState, db::RocksDb, grpc::grpc_handler::NodeControlService,\n    key_manager::load_and_decrypt_keypair, swarm_manager::build_swarm,\n};\nuse clients::{EsploraApiClient, WindowedConfirmedTransactionProvider};\nuse esplora_client::Builder;\nuse std::path::{Path, PathBuf};\nuse tokio::sync::broadcast;\nuse tonic::transport::Server;\nuse tracing::{error, info};\nuse tracing_appender::rolling::{RollingFileAppender, Rotation};\nuse tracing_subscriber::{EnvFilter, fmt, prelude::*};\n\npub async fn start_node(\n    max_signers: Option\u003cu16\u003e,\n    min_signers: Option\u003cu16\u003e,\n    config: NodeConfig,\n    grpc_port: Option\u003cu16\u003e,\n    log_file: Option\u003cPathBuf\u003e,\n) -\u003e Result\u003c(), NodeError\u003e {\n    // Initialize logging\n    let env_filter = EnvFilter::try_from_default_env().unwrap_or_else(|_| EnvFilter::new(\"info\"));\n\n    let registry = tracing_subscriber::registry().with(env_filter);\n\n    if let Some(log_path) = config.log_file_path.clone().or(log_file) {\n        // File logging\n        let log_dir = Path::new(\u0026log_path);\n\n        if !log_dir.exists() {\n            info!(\"Creating log directory: {:?}\", log_dir);\n            if let Err(e) = std::fs::create_dir_all(log_dir) {\n                error!(\n                    \"Failed to create log directory {}: {}\",\n                    log_dir.display(),\n                    e\n                );\n                return Err(NodeError::Error(e.to_string()));\n            }\n        }\n\n        let file_appender = RollingFileAppender::new(Rotation::DAILY, log_dir, \"node.log\");\n\n        let file_layer = fmt::layer()\n            .with_writer(file_appender)\n            .with_ansi(false)\n            .with_target(true)\n            .with_thread_ids(true)\n            .with_thread_names(true);\n\n        let console_layer = fmt::layer()\n            .with_writer(std::io::stdout)\n            .with_ansi(true)\n            .with_target(false);\n\n        registry.with(file_layer).with(console_layer).init();\n        info!(\n            \"Logging initialized with file output: {}\",\n            log_path.display()\n        );\n    } else {\n        // Console-only logging\n        let console_layer = fmt::layer()\n            .with_writer(std::io::stdout)\n            .with_ansi(true)\n            .with_target(false);\n\n        registry.with(console_layer).init();\n        info!(\"Logging initialized with console output only\");\n    }\n\n    let keypair = match load_and_decrypt_keypair(\u0026config) {\n        Ok(kp) =\u003e kp,\n        Err(e) =\u003e {\n            error!(\"Failed to decrypt key: {}\", e);\n            return Err(e);\n        }\n    };\n\n    let max_signers = max_signers.unwrap_or(5);\n    let min_signers = min_signers.unwrap_or(3);\n\n    let allowed_peers = config.allowed_peers.clone();\n\n    let (network_handle, mut swarm) =\n        build_swarm(keypair.clone(), allowed_peers.clone()).expect(\"Failed to build swarm\");\n\n    let (deposit_intent_tx, deposit_intent_rx) = broadcast::channel(100);\n\n    let mut node_state = NodeState::new_from_config(\n        network_handle,\n        min_signers,\n        max_signers,\n        config,\n        RocksDb::new(\"nodedb.db\"),\n        swarm.network_events.clone(),\n        deposit_intent_tx,\n    )\n    .expect(\"Failed to create node\");\n\n    let network_handle = node_state.network_handle.clone();\n\n    let swarm_handle = tokio::spawn(async move {\n        swarm.start().await;\n    });\n\n    let grpc_handle = tokio::spawn(async move {\n        let addr = format!(\"0.0.0.0:{}\", grpc_port.unwrap_or(50051))\n            .parse()\n            .unwrap();\n\n        let node_control_service = NodeControlService::new(network_handle);\n\n        info!(\"gRPC server listening on {}\", addr);\n\n        Server::builder()\n            .add_service(node_control_service.into_server())\n            .serve(addr)\n            .await\n            .expect(\"gRPC server failed\");\n    });\n\n    let main_loop_handle = tokio::spawn(async move { node_state.start().await });\n\n    let deposit_monitor_handle = tokio::spawn(async move {\n        let mut client = EsploraApiClient::new(\n            Builder::new(\"https://blockstream.info/testnet/api\")\n                .build_async()\n                .unwrap(),\n            100,\n            Some(deposit_intent_rx),\n        );\n\n        client.poll_new_transactions(vec![]).await;\n    });\n\n    // Wait for either task to complete (they should run indefinitely)\n    tokio::select! {\n        result = grpc_handle =\u003e {\n            match result {\n                Ok(_) =\u003e info!(\"gRPC server stopped\"),\n                Err(e) =\u003e error!(\"gRPC server error: {}\", e),\n            }\n        }\n        result = swarm_handle =\u003e {\n            match result {\n                Ok(_) =\u003e info!(\"Swarm stopped\"),\n                Err(e) =\u003e error!(\"Swarm error: {}\", e),\n            }\n        }\n        result = main_loop_handle =\u003e {\n            match result {\n                Ok(Ok(_)) =\u003e info!(\"Main loop stopped\"),\n                Ok(Err(e)) =\u003e error!(\"Main loop error: {}\", e),\n                Err(e) =\u003e error!(\"Main loop task error: {}\", e),\n            }\n        }\n        result = deposit_monitor_handle =\u003e {\n            match result {\n                Ok(_) =\u003e info!(\"Deposit monitor stopped\"),\n                Err(e) =\u003e error!(\"Deposit monitor error: {}\", e),\n            }\n        }\n    }\n\n    Ok(())\n}\n","traces":[{"line":16,"address":[9367216],"length":1,"stats":{"Line":0}},{"line":24,"address":[12592667,12611856,12611872,12592542],"length":1,"stats":{"Line":0}},{"line":26,"address":[9488268,9488350],"length":1,"stats":{"Line":0}},{"line":28,"address":[8715023,8714941],"length":1,"stats":{"Line":0}},{"line":30,"address":[8715178,8715283],"length":1,"stats":{"Line":0}},{"line":32,"address":[12593267],"length":1,"stats":{"Line":0}},{"line":33,"address":[12593310,12593704,12593401],"length":1,"stats":{"Line":0}},{"line":34,"address":[9161874,9162386],"length":1,"stats":{"Line":0}},{"line":35,"address":[8716831],"length":1,"stats":{"Line":0}},{"line":40,"address":[9490151,9490761],"length":1,"stats":{"Line":0}},{"line":44,"address":[9490930,9488890],"length":1,"stats":{"Line":0}},{"line":46,"address":[9163594,9163713],"length":1,"stats":{"Line":0}},{"line":47,"address":[9491003],"length":1,"stats":{"Line":0}},{"line":53,"address":[12595665,12595725],"length":1,"stats":{"Line":0}},{"line":58,"address":[8717789],"length":1,"stats":{"Line":0}},{"line":59,"address":[9492090],"length":1,"stats":{"Line":0}},{"line":65,"address":[9165205],"length":1,"stats":{"Line":0}},{"line":70,"address":[12597104],"length":1,"stats":{"Line":0}},{"line":71,"address":[8719139],"length":1,"stats":{"Line":0}},{"line":74,"address":[8718876,8719850],"length":1,"stats":{"Line":0}},{"line":75,"address":[12598003],"length":1,"stats":{"Line":0}},{"line":76,"address":[9166148],"length":1,"stats":{"Line":0}},{"line":77,"address":[8719896,8723909,8723543],"length":1,"stats":{"Line":0}},{"line":78,"address":[9170200],"length":1,"stats":{"Line":0}},{"line":82,"address":[8720143,8720038],"length":1,"stats":{"Line":0}},{"line":83,"address":[9493779],"length":1,"stats":{"Line":0}},{"line":85,"address":[9166481],"length":1,"stats":{"Line":0}},{"line":87,"address":[8720346,8720236,8720266,8723470],"length":1,"stats":{"Line":0}},{"line":90,"address":[9167066,9166987],"length":1,"stats":{"Line":0}},{"line":93,"address":[9494488],"length":1,"stats":{"Line":0}},{"line":96,"address":[12599055],"length":1,"stats":{"Line":0}},{"line":97,"address":[9167323,9167403],"length":1,"stats":{"Line":0}},{"line":98,"address":[12599203],"length":1,"stats":{"Line":0}},{"line":99,"address":[9494851],"length":1,"stats":{"Line":0}},{"line":103,"address":[12599653,12599560],"length":1,"stats":{"Line":0}},{"line":105,"address":[9495220,9507773,9495409,9507619,9508040,9507962,9507520,9507545],"length":1,"stats":{"Line":0}},{"line":106,"address":[8733742,8733843,8733927,8733786],"length":1,"stats":{"Line":0}},{"line":109,"address":[9180704,9180890,9182607,9182984,9168328,9180747,9168088],"length":1,"stats":{"Line":0}},{"line":110,"address":[12612775,12612595,12612989],"length":1,"stats":{"Line":0}},{"line":112,"address":[9181254,9181143],"length":1,"stats":{"Line":0}},{"line":114,"address":[12613065,12613228],"length":1,"stats":{"Line":0}},{"line":116,"address":[8735222,8734973,8734899],"length":1,"stats":{"Line":0}},{"line":118,"address":[9182220,9182544,9182788,9182423,9182482,9182846,9181748],"length":1,"stats":{"Line":0}},{"line":119,"address":[8735684],"length":1,"stats":{"Line":0}},{"line":120,"address":[12614242],"length":1,"stats":{"Line":0}},{"line":121,"address":[8120625],"length":1,"stats":{"Line":0}},{"line":122,"address":[8735810,8736288],"length":1,"stats":{"Line":0}},{"line":125,"address":[9183040,9183189,9183335,9183566,9168524,9168351,9183075],"length":1,"stats":{"Line":0}},{"line":127,"address":[9183721,9183820,9184223,9183696,9184437,9184431,9168547,9168707],"length":1,"stats":{"Line":0}},{"line":128,"address":[8737131,8737358],"length":1,"stats":{"Line":0}},{"line":129,"address":[9511133,9511246],"length":1,"stats":{"Line":0}},{"line":133,"address":[8737320],"length":1,"stats":{"Line":0}},{"line":136,"address":[8737601,8737207,8737471,8737400],"length":1,"stats":{"Line":0}},{"line":140,"address":[8722537,8725179],"length":1,"stats":{"Line":0}},{"line":168,"address":[8725893],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":55},{"path":["/","home","vidyootsenthil","Documents","TheValut-nameTBD","crates","node","src","swarm_manager.rs"],"content":"use futures::StreamExt;\nuse libp2p::{\n    Multiaddr, PeerId,\n    request_response::{Event, Message},\n    swarm::SwarmEvent,\n};\nuse std::{\n    collections::{BTreeMap, HashSet, hash_map::DefaultHasher},\n    fmt::Debug,\n    future::Future,\n    hash::{Hash, Hasher},\n    pin::Pin,\n    time::Duration,\n};\nuse tracing::info;\n\nuse frost_secp256k1::keys::dkg::round2;\nuse libp2p::{\n    StreamProtocol, Swarm, gossipsub, mdns, noise, request_response, swarm::NetworkBehaviour, tcp,\n    yamux,\n};\nuse libp2p::{identity::Keypair, request_response::cbor};\nuse tokio::{\n    io,\n    sync::{\n        broadcast,\n        mpsc::{self, unbounded_channel},\n    },\n};\n\nuse crate::{PeerData, deposit_intents::DepositIntent};\nuse types::errors::{NetworkError, NodeError};\n\n#[derive(Clone, Debug, serde::Serialize, serde::Deserialize)]\npub struct PingBody {\n    pub message: String,\n}\n\n#[derive(Clone, Debug, serde::Serialize, serde::Deserialize)]\npub enum DirectMessage {\n    Ping(PingBody),\n    Round2Package(round2::Package),\n    SignRequest {\n        sign_id: u64,\n        message: Vec\u003cu8\u003e,\n    },\n    SignPackage {\n        sign_id: u64,\n        package: Vec\u003cu8\u003e,\n    },\n    Pong,\n    Commitments {\n        sign_id: u64,\n        commitments: Vec\u003cu8\u003e,\n    },\n    SignatureShare {\n        sign_id: u64,\n        signature_share: Vec\u003cu8\u003e,\n    },\n}\n\n#[derive(Clone, Debug, serde::Serialize, serde::Deserialize)]\npub enum SelfRequest {\n    GetFrostPublicKey,\n    CreateDeposit { deposit_intent: DepositIntent },\n    GetPendingDepositIntents,\n    StartSigningSession { hex_message: String },\n    Spend { amount_sat: u64, address_to: String },\n}\n\n#[derive(Clone, Debug, serde::Serialize, serde::Deserialize)]\npub enum SelfResponse {\n    GetFrostPublicKeyResponse { public_key: Option\u003cString\u003e },\n    CreateDepositResponse { success: bool },\n    GetPendingDepositIntentsResponse { intents: Vec\u003cDepositIntent\u003e },\n    StartSigningSessionResponse { sign_id: u64 },\n    SpendRequestSent { sighash: String },\n}\n\n#[derive(NetworkBehaviour)]\npub struct MyBehaviour {\n    pub gossipsub: gossipsub::Behaviour,\n    pub mdns: mdns::tokio::Behaviour,\n    pub request_response: cbor::Behaviour\u003cDirectMessage, ()\u003e,\n}\n\n#[derive(Clone, Debug)]\npub enum NetworkMessage {\n    SendBroadcast {\n        topic: gossipsub::IdentTopic,\n        message: Vec\u003cu8\u003e,\n    },\n    SendPrivateMessage(PeerId, DirectMessage),\n    SendSelfRequest {\n        request: SelfRequest,\n        response_channel: Option\u003cmpsc::UnboundedSender\u003cSelfResponse\u003e\u003e,\n    },\n}\n\npub type NetworkResponseFuture =\n    Pin\u003cBox\u003cdyn Future\u003cOutput = Result\u003cSelfResponse, NetworkError\u003e\u003e + Send\u003e\u003e;\n\n#[derive(Debug, Clone)]\npub struct NetworkHandle {\n    peer_id: PeerId,\n    tx: mpsc::UnboundedSender\u003cNetworkMessage\u003e,\n}\n\npub trait Network: Clone + Debug + Sync + Send {\n    fn peer_id(\u0026self) -\u003e PeerId;\n    fn send_broadcast(\n        \u0026self,\n        topic: gossipsub::IdentTopic,\n        message: Vec\u003cu8\u003e,\n    ) -\u003e Result\u003c(), NetworkError\u003e;\n    fn send_private_message(\n        \u0026self,\n        peer_id: PeerId,\n        request: DirectMessage,\n    ) -\u003e Result\u003c(), NetworkError\u003e;\n    fn send_self_request(\n        \u0026self,\n        request: SelfRequest,\n        sync: bool,\n    ) -\u003e Result\u003cOption\u003cNetworkResponseFuture\u003e, NetworkError\u003e;\n}\n\nimpl Network for NetworkHandle {\n    fn peer_id(\u0026self) -\u003e PeerId {\n        self.peer_id\n    }\n\n    fn send_broadcast(\n        \u0026self,\n        topic: gossipsub::IdentTopic,\n        message: Vec\u003cu8\u003e,\n    ) -\u003e Result\u003c(), NetworkError\u003e {\n        let network_message = NetworkMessage::SendBroadcast { topic, message };\n        self.tx\n            .send(network_message)\n            .map_err(|e| NetworkError::SendError(e.to_string()))\n    }\n\n    fn send_private_message(\n        \u0026self,\n        peer_id: PeerId,\n        request: DirectMessage,\n    ) -\u003e Result\u003c(), NetworkError\u003e {\n        let network_message = NetworkMessage::SendPrivateMessage(peer_id, request);\n        self.tx\n            .send(network_message)\n            .map_err(|e| NetworkError::SendError(e.to_string()))\n    }\n\n    fn send_self_request(\n        \u0026self,\n        request: SelfRequest,\n        sync: bool,\n    ) -\u003e Result\u003cOption\u003cNetworkResponseFuture\u003e, NetworkError\u003e {\n        if sync {\n            let (tx, mut rx) = unbounded_channel::\u003cSelfResponse\u003e();\n\n            let network_message = NetworkMessage::SendSelfRequest {\n                request,\n                response_channel: Some(tx),\n            };\n\n            self.tx\n                .send(network_message)\n                .map_err(|e| NetworkError::SendError(e.to_string()))?;\n\n            Ok(Some(Box::pin(async move {\n                rx.recv().await.ok_or(NetworkError::RecvError)\n            })))\n        } else {\n            let network_message = NetworkMessage::SendSelfRequest {\n                request,\n                response_channel: None,\n            };\n\n            self.tx\n                .send(network_message)\n                .map_err(|e| NetworkError::SendError(e.to_string()))?;\n\n            Ok(None)\n        }\n    }\n}\n\n#[derive(Debug, Clone)]\npub enum NetworkEvent {\n    SelfRequest {\n        request: SelfRequest,\n        response_channel: Option\u003cmpsc::UnboundedSender\u003cSelfResponse\u003e\u003e,\n    },\n    Subscribed {\n        peer_id: PeerId,\n        topic: gossipsub::TopicHash,\n    },\n    GossipsubMessage(gossipsub::Message),\n    MessageEvent((PeerId, DirectMessage)),\n    PeersConnected(Vec\u003c(PeerId, Multiaddr)\u003e),\n    PeersDisconnected(Vec\u003c(PeerId, Multiaddr)\u003e),\n    Unknown,\n}\n\npub struct SwarmManager {\n    pub inner: Swarm\u003cMyBehaviour\u003e,\n\n    pub network_manager_rx: mpsc::UnboundedReceiver\u003cNetworkMessage\u003e,\n    pub network_events: broadcast::Sender\u003cNetworkEvent\u003e,\n\n    pub allowed_peers: Vec\u003cPeerId\u003e,\n    pub peers_to_names: BTreeMap\u003cPeerId, String\u003e,\n\n    pub live_peers: HashSet\u003cPeerId\u003e,\n\n    pub round1_topic: gossipsub::IdentTopic,\n    pub start_dkg_topic: gossipsub::IdentTopic,\n    pub deposit_intents_topic: gossipsub::IdentTopic,\n}\n\nimpl SwarmManager {\n    pub fn new(\n        mut swarm: Swarm\u003cMyBehaviour\u003e,\n        peer_data: Vec\u003cPeerData\u003e,\n    ) -\u003e Result\u003c(Self, NetworkHandle), NodeError\u003e {\n        let (send_commands, receiving_commands) = unbounded_channel::\u003cNetworkMessage\u003e();\n\n        let (network_events_emitter, _) = broadcast::channel::\u003cNetworkEvent\u003e(100);\n\n        let network_handle = NetworkHandle {\n            peer_id: *swarm.local_peer_id(),\n            tx: send_commands,\n        };\n\n        // Read full lines from stdin\n        let round1_topic = gossipsub::IdentTopic::new(\"round1_topic\");\n        swarm\n            .behaviour_mut()\n            .gossipsub\n            .subscribe(\u0026round1_topic)\n            .map_err(|e| NodeError::Error(e.to_string()))?;\n\n        let allowed_peers: Vec\u003cPeerId\u003e = peer_data\n            .iter()\n            .map(|peer| peer.public_key.parse().unwrap())\n            .collect();\n\n        let peers_to_names: BTreeMap\u003cPeerId, String\u003e = peer_data\n            .iter()\n            .map(|peer| (peer.public_key.parse().unwrap(), peer.name.clone()))\n            .collect();\n\n        let start_dkg_topic = gossipsub::IdentTopic::new(\"start-dkg\");\n        swarm\n            .behaviour_mut()\n            .gossipsub\n            .subscribe(\u0026start_dkg_topic)\n            .map_err(|e| NodeError::Error(e.to_string()))?;\n\n        let deposit_intents_topic = gossipsub::IdentTopic::new(\"deposit-intents\");\n        swarm\n            .behaviour_mut()\n            .gossipsub\n            .subscribe(\u0026deposit_intents_topic)\n            .map_err(|e| NodeError::Error(e.to_string()))?;\n\n        Ok((\n            Self {\n                round1_topic,\n                live_peers: HashSet::new(),\n                start_dkg_topic,\n                deposit_intents_topic,\n                inner: swarm,\n                network_manager_rx: receiving_commands,\n                network_events: network_events_emitter,\n                allowed_peers,\n                peers_to_names,\n            },\n            network_handle,\n        ))\n    }\n\n    pub fn peer_name(\u0026self, peer_id: \u0026PeerId) -\u003e String {\n        self.peers_to_names\n            .get(peer_id)\n            .unwrap_or(\u0026peer_id.to_string())\n            .clone()\n    }\n\n    pub async fn start(\u0026mut self) {\n        info!(\"Starting swarm manager\");\n        loop {\n            tokio::select! {\n                send_message = self.network_manager_rx.recv() =\u003e match send_message {\n                    Some(NetworkMessage::SendBroadcast { topic, message }) =\u003e {\n                        let _ = self.inner\n                            .behaviour_mut()\n                            .gossipsub\n                            .publish(topic, message);\n                    }\n                    Some(NetworkMessage::SendPrivateMessage(peer_id, request)) =\u003e {\n                        self.inner\n                            .behaviour_mut()\n                            .request_response\n                            .send_request(\u0026peer_id, request);\n                    }\n                    Some(NetworkMessage::SendSelfRequest { request, response_channel }) =\u003e {\n                        self.network_events.send(NetworkEvent::SelfRequest { request, response_channel } ).unwrap();\n                    }\n                    _ =\u003e {\n                    }\n                },\n                event = self.inner.select_next_some() =\u003e {\n                    match event {\n                        SwarmEvent::Behaviour(MyBehaviourEvent::Mdns(mdns::Event::Discovered(list))) =\u003e {\n                            let mut peers_connected = vec![];\n                            for (peer_id, multiaddr) in list {\n                                if self.allowed_peers.contains(\u0026peer_id) {\n                                    info!(\"Discovered peer: {}\", self.peer_name(\u0026peer_id));\n                                    peers_connected.push((peer_id, multiaddr));\n                                    self.live_peers.insert(peer_id);\n                                    self.inner.behaviour_mut().gossipsub.add_explicit_peer(\u0026peer_id);\n                                }\n                            }\n                            self.network_events.send(NetworkEvent::PeersConnected(peers_connected)).unwrap();\n                        },\n                        SwarmEvent::Behaviour(MyBehaviourEvent::Mdns(mdns::Event::Expired(list))) =\u003e {\n                            for (peer_id, _multiaddr) in list.clone() {\n                                if self.allowed_peers.contains(\u0026peer_id) {\n                                    info!(\"Peer expired: {}\", self.peer_name(\u0026peer_id));\n                                    self.live_peers.retain(|p| p != \u0026peer_id);\n                                    self.inner.behaviour_mut().gossipsub.remove_explicit_peer(\u0026peer_id);\n                                }\n                            }\n                            self.network_events.send(NetworkEvent::PeersDisconnected(list)).unwrap();\n                        },\n                        SwarmEvent::Behaviour(MyBehaviourEvent::Gossipsub(gossipsub::Event::Message {\n                            message,\n                            ..\n                        })) =\u003e {\n                            self.network_events.send(NetworkEvent::GossipsubMessage(message.clone())).unwrap();\n                        },\n                        SwarmEvent::Behaviour(MyBehaviourEvent::RequestResponse(Event::Message {\n                            peer,\n                            message: Message::Request { request, .. },\n                            ..\n                        }) ) =\u003e {\n                            self.network_events.send(NetworkEvent::MessageEvent((peer, request))).unwrap();\n                        },\n                        SwarmEvent::Behaviour(MyBehaviourEvent::Gossipsub(gossipsub::Event::Subscribed { peer_id, topic })) =\u003e {\n                            self.network_events.send(NetworkEvent::Subscribed { peer_id, topic }).unwrap();\n                        },\n                        _ =\u003e {\n                            // self.network_events.send(NetworkEvent::SwarmEvent(event)).unwrap();\n                        }\n                    }\n                }\n\n            }\n        }\n    }\n}\n\npub fn build_swarm(\n    keypair: Keypair,\n    peer_data: Vec\u003cPeerData\u003e,\n) -\u003e Result\u003c(NetworkHandle, SwarmManager), NodeError\u003e {\n    let mut swarm = libp2p::SwarmBuilder::with_existing_identity(keypair)\n        .with_tokio()\n        .with_tcp(\n            tcp::Config::default(),\n            noise::Config::new,\n            yamux::Config::default,\n        )\n        .map_err(|e| NodeError::Error(format!(\"Failed to add tcp {}\", e)))?\n        .with_quic()\n        .with_behaviour(|key| {\n            // To content-address message, we can take the hash of message and use it as an ID.\n            let message_id_fn = |message: \u0026gossipsub::Message| {\n                let mut s = DefaultHasher::new();\n                message.data.hash(\u0026mut s);\n                gossipsub::MessageId::from(s.finish().to_string())\n            };\n\n            let gossipsub_config = gossipsub::ConfigBuilder::default()\n                .heartbeat_interval(Duration::from_secs(10)) // This is set to aid debugging by not cluttering the log space\n                .validation_mode(gossipsub::ValidationMode::Strict) // This sets the kind of message validation. The default is Strict (enforce message signing)\n                .message_id_fn(message_id_fn) // content-address messages. No two messages of the same content will be propagated.\n                .mesh_n_low(1) // Minimum number of peers in mesh network (default is 4)\n                .mesh_n_high(12) // Maximum number of peers in mesh network\n                .mesh_n(3) // Target number of peers in mesh network (default is 6)\n                .mesh_outbound_min(1) // Minimum outbound connections (default is 2)\n                .gossip_lazy(3) // Number of peers to gossip to (default is 6)\n                .flood_publish(true) // Always flood publish messages to all peers, regardless of mesh\n                .build()\n                .map_err(io::Error::other)?; // Temporary hack because `build` does not return a proper `std::error::Error`.\n\n            let gossipsub = gossipsub::Behaviour::new(\n                gossipsub::MessageAuthenticity::Signed(key.clone()),\n                gossipsub_config,\n            )?;\n\n            let mdns =\n                mdns::tokio::Behaviour::new(mdns::Config::default(), key.public().to_peer_id())?;\n\n            let request_response = cbor::Behaviour::new(\n                [(\n                    StreamProtocol::new(\"/direct-message/1.0.0\"),\n                    request_response::ProtocolSupport::Full,\n                )],\n                request_response::Config::default(),\n            );\n\n            Ok(MyBehaviour {\n                gossipsub,\n                mdns,\n                request_response,\n            })\n        })\n        .map_err(|e| NodeError::Error(format!(\"Failed to add behaviour {}\", e)))?\n        .with_swarm_config(|c| c.with_idle_connection_timeout(Duration::from_secs(60)))\n        .build();\n\n    swarm\n        .listen_on(\n            \"/ip4/0.0.0.0/udp/0/quic-v1\"\n                .parse()\n                .expect(\"Failed to deserialize message\"),\n        )\n        .map_err(|e| NodeError::Error(format!(\"Failed to listen on quic {}\", e)))?;\n\n    swarm\n        .listen_on(\n            \"/ip4/0.0.0.0/tcp/0\"\n                .parse()\n                .expect(\"Failed to deserialize message\"),\n        )\n        .map_err(|e| NodeError::Error(format!(\"Failed to listen on tcp {}\", e)))?;\n\n    let (swarm_manager, network) = SwarmManager::new(swarm, peer_data)\n        .map_err(|e| NodeError::Error(format!(\"Failed to create swarm manager: {}\", e)))?;\n\n    Ok((network, swarm_manager))\n}\n","traces":[{"line":129,"address":[9637136],"length":1,"stats":{"Line":0}},{"line":130,"address":[8432785],"length":1,"stats":{"Line":0}},{"line":133,"address":[9637184],"length":1,"stats":{"Line":0}},{"line":138,"address":[9637208],"length":1,"stats":{"Line":0}},{"line":139,"address":[9637269],"length":1,"stats":{"Line":0}},{"line":141,"address":[7573906,7573888],"length":1,"stats":{"Line":0}},{"line":144,"address":[6826992],"length":1,"stats":{"Line":0}},{"line":149,"address":[8433008],"length":1,"stats":{"Line":0}},{"line":150,"address":[6827084],"length":1,"stats":{"Line":0}},{"line":152,"address":[7282272,7282295],"length":1,"stats":{"Line":0}},{"line":155,"address":[8433104,8434287,8434308],"length":1,"stats":{"Line":0}},{"line":160,"address":[6827185,6828272],"length":1,"stats":{"Line":0}},{"line":161,"address":[6827421,6827729],"length":1,"stats":{"Line":0}},{"line":165,"address":[9638146],"length":1,"stats":{"Line":0}},{"line":168,"address":[10178808,10178936,10178743],"length":1,"stats":{"Line":0}},{"line":170,"address":[9638408],"length":1,"stats":{"Line":0}},{"line":172,"address":[9638469],"length":1,"stats":{"Line":0}},{"line":173,"address":[10978677,10978776,10978725,10978879],"length":1,"stats":{"Line":0}},{"line":181,"address":[8433566,8433462,8433655,8433378],"length":1,"stats":{"Line":0}},{"line":183,"address":[10178414],"length":1,"stats":{"Line":0}},{"line":185,"address":[6827645],"length":1,"stats":{"Line":0}},{"line":224,"address":[9641889,9638768,9641592],"length":1,"stats":{"Line":0}},{"line":228,"address":[9638867,9638986],"length":1,"stats":{"Line":0}},{"line":230,"address":[9639085,9639010],"length":1,"stats":{"Line":0}},{"line":233,"address":[6828833],"length":1,"stats":{"Line":0}},{"line":238,"address":[9639359],"length":1,"stats":{"Line":0}},{"line":239,"address":[6831359,6829106,6829179,6829337],"length":1,"stats":{"Line":0}},{"line":243,"address":[9639641],"length":1,"stats":{"Line":0}},{"line":245,"address":[6829388],"length":1,"stats":{"Line":0}},{"line":247,"address":[7283408,7283451],"length":1,"stats":{"Line":0}},{"line":250,"address":[9639874,9639949],"length":1,"stats":{"Line":0}},{"line":252,"address":[7283520,7283564],"length":1,"stats":{"Line":0}},{"line":255,"address":[8435510],"length":1,"stats":{"Line":0}},{"line":256,"address":[8435785,8437040,8435655,8435585],"length":1,"stats":{"Line":0}},{"line":260,"address":[10180797],"length":1,"stats":{"Line":0}},{"line":262,"address":[8435824],"length":1,"stats":{"Line":0}},{"line":263,"address":[10181134,10180911,10180976],"length":1,"stats":{"Line":0}},{"line":267,"address":[10423248,10423266],"length":1,"stats":{"Line":0}},{"line":269,"address":[8436793],"length":1,"stats":{"Line":0}},{"line":270,"address":[9641017],"length":1,"stats":{"Line":0}},{"line":271,"address":[8436101],"length":1,"stats":{"Line":0}},{"line":272,"address":[9640721],"length":1,"stats":{"Line":0}},{"line":273,"address":[6830456],"length":1,"stats":{"Line":0}},{"line":274,"address":[9640824],"length":1,"stats":{"Line":0}},{"line":275,"address":[6830520],"length":1,"stats":{"Line":0}},{"line":276,"address":[8436330],"length":1,"stats":{"Line":0}},{"line":277,"address":[8436343],"length":1,"stats":{"Line":0}},{"line":278,"address":[6830604],"length":1,"stats":{"Line":0}},{"line":279,"address":[9640972],"length":1,"stats":{"Line":0}},{"line":281,"address":[6830927],"length":1,"stats":{"Line":0}},{"line":285,"address":[9642137,9642131,9641936],"length":1,"stats":{"Line":0}},{"line":286,"address":[9641986,9642041,9642099],"length":1,"stats":{"Line":0}},{"line":288,"address":[6831676],"length":1,"stats":{"Line":0}},{"line":292,"address":[10981271,10980468,10980128,10980500,10982868,10980174],"length":1,"stats":{"Line":0}},{"line":293,"address":[10423818,10423704,10424120],"length":1,"stats":{"Line":0}},{"line":294,"address":[10983706],"length":1,"stats":{"Line":0}},{"line":295,"address":[7582289],"length":1,"stats":{"Line":0}},{"line":366,"address":[9642192,9644139,9644184],"length":1,"stats":{"Line":0}},{"line":370,"address":[9642428,9644145,9642872,9642244,9642598,9642336,9642479],"length":1,"stats":{"Line":0}},{"line":373,"address":[10182867],"length":1,"stats":{"Line":0}},{"line":377,"address":[10434214,10434192],"length":1,"stats":{"Line":0}},{"line":379,"address":[10993143,10991184,10993180],"length":1,"stats":{"Line":0}},{"line":381,"address":[7296720,7294880],"length":1,"stats":{"Line":0}},{"line":382,"address":[7296758],"length":1,"stats":{"Line":0}},{"line":383,"address":[7296773],"length":1,"stats":{"Line":0}},{"line":384,"address":[10993300],"length":1,"stats":{"Line":0}},{"line":387,"address":[7294896,7295379,7294999,7295042],"length":1,"stats":{"Line":0}},{"line":388,"address":[7294918],"length":1,"stats":{"Line":0}},{"line":389,"address":[7295034],"length":1,"stats":{"Line":0}},{"line":398,"address":[10991938,10993212,10991388,10991823],"length":1,"stats":{"Line":0}},{"line":400,"address":[10992114,10992236,10993178],"length":1,"stats":{"Line":0}},{"line":401,"address":[7587742],"length":1,"stats":{"Line":0}},{"line":402,"address":[7587801],"length":1,"stats":{"Line":0}},{"line":406,"address":[10435591,10435662],"length":1,"stats":{"Line":0}},{"line":408,"address":[10992876],"length":1,"stats":{"Line":0}},{"line":410,"address":[7588375],"length":1,"stats":{"Line":0}},{"line":411,"address":[7296226],"length":1,"stats":{"Line":0}},{"line":413,"address":[10436080],"length":1,"stats":{"Line":0}},{"line":416,"address":[7588707],"length":1,"stats":{"Line":0}},{"line":417,"address":[10436191],"length":1,"stats":{"Line":0}},{"line":418,"address":[10436217],"length":1,"stats":{"Line":0}},{"line":422,"address":[7296903,7296864],"length":1,"stats":{"Line":0}},{"line":423,"address":[7589360,7589373],"length":1,"stats":{"Line":0}},{"line":426,"address":[9644082,9643152,9643304],"length":1,"stats":{"Line":0}},{"line":428,"address":[10183600,10183528],"length":1,"stats":{"Line":0}},{"line":432,"address":[7297351,7297312],"length":1,"stats":{"Line":0}},{"line":434,"address":[9643428,9643580,9644080],"length":1,"stats":{"Line":0}},{"line":436,"address":[9643349],"length":1,"stats":{"Line":0}},{"line":440,"address":[9643548],"length":1,"stats":{"Line":0}},{"line":442,"address":[9644066,9643852,9643625],"length":1,"stats":{"Line":0}},{"line":443,"address":[7590086,7590064],"length":1,"stats":{"Line":0}},{"line":445,"address":[8439210],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":92},{"path":["/","home","vidyootsenthil","Documents","TheValut-nameTBD","crates","node","src","wallet.rs"],"content":"use bitcoin::absolute::LockTime;\nuse bitcoin::consensus::encode::serialize;\nuse bitcoin::hashes::Hash;\nuse bitcoin::transaction::{OutPoint, Version};\nuse bitcoin::witness::Witness;\nuse bitcoin::{Amount, ScriptBuf, Transaction, TxIn, TxOut, hashes::sha256};\n\nuse crate::db::Db;\nuse crate::{Network, NodeState};\n\n/// Very simple demonstration UTXO representation (key-path Taproot assumed)\n#[derive(Debug, Clone)]\npub struct Utxo {\n    pub outpoint: OutPoint,\n    pub value: Amount,\n    pub script_pubkey: ScriptBuf,\n}\n\n/// Wallet that only tracks a list of local UTXOs and is able to construct a\n/// single-input spending transaction that possibly creates a change output. No\n/// fee calculation is performed – this is purely for demonstration purposes.\n#[derive(Debug, Default)]\npub struct SimpleWallet {\n    pub utxos: Vec\u003cUtxo\u003e,\n    pub address: Option\u003cbitcoin::Address\u003e,\n}\n\nimpl SimpleWallet {\n    pub fn new(address: \u0026bitcoin::Address) -\u003e Self {\n        Self {\n            address: Some(address.clone()),\n            utxos: vec![\n                Utxo {\n                    outpoint: OutPoint {\n                        txid: bitcoin::Txid::from_slice(\u0026[0u8; 32]).expect(\"Failed to create UTXO\"),\n                        vout: 0,\n                    },\n                    value: Amount::from_sat(100_000),\n                    script_pubkey: address.script_pubkey(),\n                },\n                Utxo {\n                    outpoint: OutPoint {\n                        txid: bitcoin::Txid::from_slice(\u0026[1u8; 32]).expect(\"Failed to create UTXO\"),\n                        vout: 0,\n                    },\n                    value: Amount::from_sat(50_000),\n                    script_pubkey: address.script_pubkey(),\n                },\n                Utxo {\n                    outpoint: OutPoint {\n                        txid: bitcoin::Txid::from_slice(\u0026[2u8; 32]).expect(\"Failed to create UTXO\"),\n                        vout: 0,\n                    },\n                    value: Amount::from_sat(20_000),\n                    script_pubkey: address.script_pubkey(),\n                },\n            ],\n        }\n    }\n\n    pub fn create_spend(\n        \u0026mut self,\n        amount_sat: u64,\n        address: \u0026bitcoin::Address,\n    ) -\u003e Result\u003c(Transaction, [u8; 32]), String\u003e {\n        let pos = self\n            .utxos\n            .iter()\n            .position(|u| u.value.to_sat() \u003e= amount_sat)\n            .ok_or_else(|| {\n                \"No single UTXO large enough – coin selection not implemented\".to_string()\n            })?;\n\n        let utxo = self.utxos.remove(pos);\n        let change_sat = utxo.value.to_sat() - amount_sat;\n\n        let input = TxIn {\n            previous_output: utxo.outpoint,\n            script_sig: ScriptBuf::new(),\n            sequence: bitcoin::Sequence::ZERO,\n            witness: Witness::new(),\n        };\n\n        let recipient_output = TxOut {\n            value: Amount::from_sat(amount_sat),\n            script_pubkey: address.script_pubkey(),\n        };\n\n        let mut outputs = vec![recipient_output];\n\n        // Add change output if needed\n        if change_sat \u003e 0 {\n            outputs.push(TxOut {\n                value: Amount::from_sat(change_sat),\n                script_pubkey: ScriptBuf::new(),\n            });\n        }\n\n        let tx = Transaction {\n            version: Version::TWO,\n            lock_time: LockTime::ZERO,\n            input: vec![input],\n            output: outputs,\n        };\n\n        let sighash = sha256::Hash::hash(\u0026serialize(\u0026tx));\n        Ok((tx, sighash.to_byte_array()))\n    }\n}\n\n#[derive(Debug)]\npub struct PendingSpend {\n    pub tx: Transaction,\n}\n\nimpl\u003cN: Network, D: Db\u003e NodeState\u003cN, D\u003e {\n    pub fn get_frost_public_key(\u0026self) -\u003e Option\u003cString\u003e {\n        self.pubkey_package.as_ref().map(|p| {\n            format!(\"{:?}\", p.verifying_key())\n                .replace(\"VerifyingKey(\", \"\")\n                .replace(\")\", \"\")\n                .replace(\"\\\\\", \"\")\n                .replace(\"\\\"\", \"\")\n        })\n    }\n}\n","traces":[{"line":29,"address":[6381801,6381807,6380528],"length":1,"stats":{"Line":0}},{"line":31,"address":[5414830],"length":1,"stats":{"Line":0}},{"line":32,"address":[9632997,9633858,9633589,9634108,9632957,9633293],"length":1,"stats":{"Line":0}},{"line":61,"address":[9634144,9636366,9636460],"length":1,"stats":{"Line":0}},{"line":66,"address":[9634200,9634402],"length":1,"stats":{"Line":0}},{"line":69,"address":[12047328,12047346],"length":1,"stats":{"Line":0}},{"line":70,"address":[12047376],"length":1,"stats":{"Line":0}},{"line":71,"address":[6070732],"length":1,"stats":{"Line":0}},{"line":74,"address":[5416376],"length":1,"stats":{"Line":0}},{"line":75,"address":[5416396,5416560,5416465],"length":1,"stats":{"Line":0}},{"line":78,"address":[6382257],"length":1,"stats":{"Line":0}},{"line":79,"address":[6382311],"length":1,"stats":{"Line":0}},{"line":81,"address":[6382346],"length":1,"stats":{"Line":0}},{"line":85,"address":[5416784],"length":1,"stats":{"Line":0}},{"line":86,"address":[6382609],"length":1,"stats":{"Line":0}},{"line":89,"address":[6382691,6382749],"length":1,"stats":{"Line":0}},{"line":92,"address":[9124522],"length":1,"stats":{"Line":0}},{"line":93,"address":[9635387],"length":1,"stats":{"Line":0}},{"line":94,"address":[6382990],"length":1,"stats":{"Line":0}},{"line":95,"address":[9635375],"length":1,"stats":{"Line":0}},{"line":102,"address":[9124538,9124714],"length":1,"stats":{"Line":0}},{"line":106,"address":[9635901,9635833],"length":1,"stats":{"Line":0}},{"line":107,"address":[9125267],"length":1,"stats":{"Line":0}},{"line":117,"address":[7524544],"length":1,"stats":{"Line":2}},{"line":118,"address":[5704240],"length":1,"stats":{"Line":4}},{"line":119,"address":[],"length":0,"stats":{"Line":10}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":2}}],"covered":4,"coverable":30},{"path":["/","home","vidyootsenthil","Documents","TheValut-nameTBD","crates","protocol","src","block.rs"],"content":"use std::time::{SystemTime, UNIX_EPOCH};\n\nuse bincode::{Decode, Encode};\nuse serde::{Deserialize, Serialize};\nuse sha2::{Digest, Sha256};\nuse types::errors::NodeError;\n\nuse crate::transaction::Transaction;\n\npub type BlockHash = [u8; 32];\npub type StateRoot = [u8; 32];\n\n/// Block header containing all metadata\n#[derive(Debug, Clone, Encode, Decode, Serialize, Deserialize, PartialEq)]\npub struct BlockHeader {\n    /// Version of the block structure\n    pub version: u32,\n\n    /// Hash of the previous block\n    pub previous_block_hash: BlockHash,\n\n    /// Merkle root of the transactions in the block\n    pub state_root: StateRoot,\n\n    /// Unix timestamp when block was created\n    pub timestamp: u64,\n\n    /// Block height/number in the chain\n    pub height: u64,\n\n    /// Proposer of this block (for PoS/PoA)\n    pub proposer: Vec\u003cu8\u003e,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize, Encode, Decode)]\npub struct GenesisBlock {\n    pub version: u32,\n    pub timestamp: u64,\n    pub initial_state: GenesisState,\n    pub extra_data: Vec\u003cu8\u003e,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize, Encode, Decode)]\npub struct GenesisState {\n    pub validators: Vec\u003cValidatorInfo\u003e,\n    pub vault_pub_key: Vec\u003cu8\u003e,\n    pub initial_balances: Vec\u003c(String, u64)\u003e,\n    pub chain_config: ChainConfig,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize, Encode, Decode)]\npub struct ValidatorInfo {\n    pub pub_key: Vec\u003cu8\u003e,\n    pub stake: u64,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize, Encode, Decode)]\npub struct ChainConfig {\n    pub min_signers: u16,\n    pub max_signers: u16,\n    pub min_stake: u64,\n    pub block_time_seconds: u64,\n    pub max_block_size: u64,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize, Encode, Decode)]\npub struct Block {\n    pub header: BlockHeader,\n    pub body: BlockBody,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize, Encode, Decode)]\npub struct BlockBody {\n    pub transactions: Vec\u003cTransaction\u003e,\n}\n\nimpl BlockBody {\n    pub fn new(transactions: Vec\u003cTransaction\u003e) -\u003e Self {\n        Self { transactions }\n    }\n}\n\nimpl BlockHeader {\n    pub fn calculate_hash(\u0026self) -\u003e BlockHash {\n        let mut hasher = Sha256::new();\n\n        hasher.update(self.version.to_le_bytes());\n        hasher.update(self.previous_block_hash);\n        hasher.update(self.state_root);\n        hasher.update(self.timestamp.to_le_bytes());\n        hasher.update(self.height.to_le_bytes());\n        hasher.update(\u0026self.proposer);\n\n        let result = hasher.finalize();\n        let mut hash = [0u8; 32];\n        hash.copy_from_slice(\u0026result);\n        hash\n    }\n}\n\nimpl Block {\n    /// Create a new block\n    pub fn new(\n        previous_block_hash: BlockHash,\n        state_root: StateRoot,\n        height: u64,\n        transactions: Vec\u003cTransaction\u003e,\n        proposer: Vec\u003cu8\u003e,\n        timestamp: u64,\n    ) -\u003e Self {\n        let header = BlockHeader {\n            version: 1,\n            previous_block_hash,\n            state_root,\n            timestamp,\n            height,\n            proposer,\n        };\n\n        Block {\n            header,\n            body: BlockBody { transactions },\n        }\n    }\n\n    pub fn hash(\u0026self) -\u003e BlockHash {\n        self.header.calculate_hash()\n    }\n\n    pub fn serialize(\u0026self) -\u003e Result\u003cVec\u003cu8\u003e, NodeError\u003e {\n        bincode::encode_to_vec(self, bincode::config::standard())\n            .map_err(|e| NodeError::Error(format!(\"Failed to serialize block: {}\", e)))\n    }\n\n    pub fn deserialize(data: \u0026[u8]) -\u003e Result\u003cSelf, NodeError\u003e {\n        let (block, _): (Self, _) =\n            bincode::decode_from_slice(data, bincode::config::standard())\n                .map_err(|e| NodeError::Error(format!(\"Failed to deserialize block: {}\", e)))?;\n        Ok(block)\n    }\n}\n\nimpl GenesisBlock {\n    /// Create a new genesis block\n    pub fn new(\n        validators: Vec\u003cValidatorInfo\u003e,\n        chain_config: ChainConfig,\n        vault_pub_key: Vec\u003cu8\u003e,\n    ) -\u003e Self {\n        GenesisBlock {\n            version: 1,\n            timestamp: SystemTime::now()\n                .duration_since(UNIX_EPOCH)\n                .unwrap()\n                .as_secs(),\n            initial_state: GenesisState {\n                validators,\n                vault_pub_key,\n                initial_balances: vec![],\n                chain_config,\n            },\n            extra_data: b\"Genesis Block\".to_vec(),\n        }\n    }\n\n    pub fn to_block(\u0026self) -\u003e Block {\n        let mut hasher = Sha256::new();\n        hasher.update(b\"GENESIS\");\n        hasher.update(self.timestamp.to_le_bytes());\n        let state_bytes =\n            bincode::encode_to_vec(\u0026self.initial_state, bincode::config::standard()).unwrap();\n        hasher.update(\u0026state_bytes);\n        let result = hasher.finalize();\n        let mut state_root = [0u8; 32];\n        state_root.copy_from_slice(\u0026result);\n\n        Block::new(\n            [0u8; 32], // No previous block\n            state_root,\n            0,      // Height 0\n            vec![], // No transactions in genesis\n            self.initial_state\n                .validators\n                .first()\n                .map(|v| v.pub_key.clone())\n                .unwrap_or_default(),\n            self.timestamp,\n        )\n    }\n\n    /// Get hash of genesis block\n    pub fn hash(\u0026self) -\u003e BlockHash {\n        self.to_block().hash()\n    }\n}\n","traces":[{"line":78,"address":[17702944],"length":1,"stats":{"Line":0}},{"line":84,"address":[17702976],"length":1,"stats":{"Line":1}},{"line":85,"address":[17703005],"length":1,"stats":{"Line":1}},{"line":87,"address":[17317196],"length":1,"stats":{"Line":1}},{"line":88,"address":[14714989],"length":1,"stats":{"Line":1}},{"line":89,"address":[2464353],"length":1,"stats":{"Line":1}},{"line":90,"address":[17317403],"length":1,"stats":{"Line":1}},{"line":91,"address":[14715203],"length":1,"stats":{"Line":1}},{"line":92,"address":[17317547],"length":1,"stats":{"Line":1}},{"line":94,"address":[2464575],"length":1,"stats":{"Line":1}},{"line":95,"address":[14715331],"length":1,"stats":{"Line":1}},{"line":96,"address":[17317623],"length":1,"stats":{"Line":1}},{"line":97,"address":[14715414],"length":1,"stats":{"Line":1}},{"line":103,"address":[17703568],"length":1,"stats":{"Line":1}},{"line":122,"address":[17317897],"length":1,"stats":{"Line":1}},{"line":126,"address":[14715744],"length":1,"stats":{"Line":1}},{"line":127,"address":[17703857],"length":1,"stats":{"Line":1}},{"line":130,"address":[14254144],"length":1,"stats":{"Line":0}},{"line":131,"address":[17318088],"length":1,"stats":{"Line":0}},{"line":132,"address":[2626144,2626174],"length":1,"stats":{"Line":0}},{"line":135,"address":[17703968],"length":1,"stats":{"Line":0}},{"line":136,"address":[14254480],"length":1,"stats":{"Line":0}},{"line":138,"address":[17785920,17785942],"length":1,"stats":{"Line":0}},{"line":139,"address":[17704252],"length":1,"stats":{"Line":0}},{"line":145,"address":[14254544,14255277,14255221],"length":1,"stats":{"Line":2}},{"line":152,"address":[17318496,17318598],"length":1,"stats":{"Line":3}},{"line":156,"address":[14254928],"length":1,"stats":{"Line":1}},{"line":162,"address":[17704791],"length":1,"stats":{"Line":2}},{"line":166,"address":[17319232,17320107,17320101],"length":1,"stats":{"Line":2}},{"line":167,"address":[17705086],"length":1,"stats":{"Line":1}},{"line":168,"address":[14255374],"length":1,"stats":{"Line":2}},{"line":169,"address":[14255395],"length":1,"stats":{"Line":1}},{"line":170,"address":[14255469],"length":1,"stats":{"Line":2}},{"line":172,"address":[17319469],"length":1,"stats":{"Line":1}},{"line":173,"address":[17319524],"length":1,"stats":{"Line":2}},{"line":174,"address":[14717385],"length":1,"stats":{"Line":1}},{"line":175,"address":[17319676],"length":1,"stats":{"Line":2}},{"line":178,"address":[2466706],"length":1,"stats":{"Line":1}},{"line":179,"address":[14717493],"length":1,"stats":{"Line":2}},{"line":181,"address":[14717525],"length":1,"stats":{"Line":1}},{"line":182,"address":[14717549,14717629],"length":1,"stats":{"Line":3}},{"line":185,"address":[17786176,17786192],"length":1,"stats":{"Line":3}},{"line":187,"address":[17705802],"length":1,"stats":{"Line":2}},{"line":192,"address":[2467174,2467056,2467168],"length":1,"stats":{"Line":0}},{"line":193,"address":[2467090],"length":1,"stats":{"Line":0}}],"covered":35,"coverable":45},{"path":["/","home","vidyootsenthil","Documents","TheValut-nameTBD","crates","protocol","src","chain_state.rs"],"content":"use std::collections::HashMap;\n\nuse bincode::{Decode, Encode};\nuse serde::{Deserialize, Serialize};\nuse types::errors::NodeError;\n\n#[derive(Debug, Clone, Serialize, Deserialize, Encode, Decode)]\npub struct Account {\n    pub address: String,\n    pub balance: u64,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize, Encode, Decode)]\npub struct ChainState {\n    // address -\u003e account\n    accounts: HashMap\u003cString, Account\u003e,\n    block_height: u64,\n}\n\nimpl Default for ChainState {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n\n// TODO: implement periodic flushing of chain state to rocksdb\nimpl ChainState {\n    pub fn new() -\u003e Self {\n        Self {\n            accounts: HashMap::new(),\n            block_height: 0,\n        }\n    }\n\n    pub fn new_with_accounts(accounts: HashMap\u003cString, Account\u003e, block_height: u64) -\u003e Self {\n        Self {\n            accounts,\n            block_height,\n        }\n    }\n\n    pub fn get_account(\u0026self, address: \u0026str) -\u003e Option\u003c\u0026Account\u003e {\n        self.accounts.get(address)\n    }\n\n    pub fn upsert_account(\u0026mut self, address: \u0026str, account: Account) {\n        self.accounts.insert(address.to_string(), account);\n    }\n\n    pub fn get_block_height(\u0026self) -\u003e u64 {\n        self.block_height\n    }\n\n    pub fn serialize(\u0026self) -\u003e Result\u003cVec\u003cu8\u003e, NodeError\u003e {\n        bincode::encode_to_vec(self, bincode::config::standard())\n            .map_err(|e| NodeError::Error(e.to_string()))\n    }\n\n    pub fn deserialize(data: \u0026[u8]) -\u003e Result\u003cSelf, NodeError\u003e {\n        let (chain_state, _): (Self, _) =\n            bincode::decode_from_slice(data, bincode::config::standard())\n                .map_err(|e| NodeError::Error(e.to_string()))?;\n        Ok(chain_state)\n    }\n}\n","traces":[{"line":21,"address":[14727440],"length":1,"stats":{"Line":0}},{"line":22,"address":[2490040],"length":1,"stats":{"Line":0}},{"line":28,"address":[14265824],"length":1,"stats":{"Line":1}},{"line":30,"address":[14265838],"length":1,"stats":{"Line":1}},{"line":35,"address":[2490144],"length":1,"stats":{"Line":8}},{"line":42,"address":[14727616],"length":1,"stats":{"Line":5}},{"line":43,"address":[14727634],"length":1,"stats":{"Line":1}},{"line":46,"address":[14266180,14266209,14266000],"length":1,"stats":{"Line":4}},{"line":47,"address":[14727689,14727756],"length":1,"stats":{"Line":6}},{"line":50,"address":[17330144],"length":1,"stats":{"Line":0}},{"line":51,"address":[14727877],"length":1,"stats":{"Line":0}},{"line":54,"address":[2490464],"length":1,"stats":{"Line":0}},{"line":55,"address":[17330184],"length":1,"stats":{"Line":0}},{"line":56,"address":[17372576,17372594],"length":1,"stats":{"Line":0}},{"line":59,"address":[14727968],"length":1,"stats":{"Line":0}},{"line":60,"address":[14266552],"length":1,"stats":{"Line":0}},{"line":62,"address":[2490688],"length":1,"stats":{"Line":0}},{"line":63,"address":[2490800],"length":1,"stats":{"Line":0}}],"covered":7,"coverable":18},{"path":["/","home","vidyootsenthil","Documents","TheValut-nameTBD","crates","protocol","src","executor.rs"],"content":"use std::collections::HashMap;\n\nuse bitcoin::{Txid, hashes::Hash};\n\nuse types::errors::NodeError;\n\nuse crate::{\n    chain_state::{Account, ChainState},\n    oracle::Oracle,\n    transaction::{Operation, Transaction},\n};\n\npub struct TransactionExecutor\u003cO: Oracle\u003e {\n    pub oracle: O,\n    pub allowance_list: HashMap\u003cString, u64\u003e,\n    pub stack: Vec\u003cVec\u003cu8\u003e\u003e,\n    pub error: Option\u003cNodeError\u003e,\n    pub new_chain_state: ChainState,\n}\n\nimpl\u003cO: Oracle\u003e TransactionExecutor\u003cO\u003e {\n    pub fn new(oracle: O) -\u003e Self {\n        Self {\n            oracle,\n            allowance_list: HashMap::new(),\n            stack: Vec::new(),\n            error: None,\n            new_chain_state: ChainState::new(),\n        }\n    }\n\n    pub async fn execute_transaction(\n        \u0026mut self,\n        transaction: Transaction,\n        chain_state: ChainState,\n    ) -\u003e Result\u003cChainState, NodeError\u003e {\n        self.new_chain_state = chain_state.clone();\n        for operation in transaction.operations {\n            match operation {\n                Operation::OpPush { value } =\u003e {\n                    self.push_to_stack(value);\n                }\n                Operation::OpCheckOracle =\u003e {\n                    self.op_check_oracle().await?;\n                }\n                Operation::OpIncrementBalance =\u003e {\n                    self.op_increment_balance().await?;\n                }\n            }\n        }\n        Ok(self.new_chain_state.clone())\n    }\n\n    pub fn push_to_stack(\u0026mut self, value: Vec\u003cu8\u003e) {\n        self.stack.push(value);\n    }\n\n    pub fn pop_from_stack(\u0026mut self) -\u003e Option\u003cVec\u003cu8\u003e\u003e {\n        self.stack.pop()\n    }\n\n    pub fn signal_error(\u0026mut self, error: NodeError) -\u003e NodeError {\n        self.stack.push(0u64.to_be_bytes().to_vec());\n        self.error = Some(error.clone());\n        error\n    }\n\n    pub async fn op_check_oracle(\u0026mut self) -\u003e Result\u003c(), NodeError\u003e {\n        let tx_hash = self\n            .pop_from_stack()\n            .ok_or_else(|| self.signal_error(NodeError::Error(\"Missing tx hash\".to_string())))?;\n\n        let tx_hash = Txid::from_slice(\u0026tx_hash)\n            .map_err(|e| self.signal_error(NodeError::Error(e.to_string())))?;\n\n        let address = self\n            .pop_from_stack()\n            .ok_or_else(|| self.signal_error(NodeError::Error(\"Missing address\".to_string())))?;\n\n        let address = String::from_utf8(address)\n            .map_err(|e| self.signal_error(NodeError::Error(e.to_string())))?;\n\n        let amount = self\n            .pop_from_stack()\n            .ok_or_else(|| self.signal_error(NodeError::Error(\"Missing amount\".to_string())))?;\n\n        let amount = u64::from_be_bytes(\n            amount\n                .try_into()\n                .map_err(|_| self.signal_error(NodeError::Error(\"Invalid amount\".to_string())))?,\n        );\n\n        let verified = self\n            .oracle\n            .validate_transaction(\u0026address, amount, tx_hash)\n            .await\n            .map_err(|e| self.signal_error(e))?;\n\n        if verified {\n            let current_allowance = self.allowance_list.get(\u0026address).copied().unwrap_or(0);\n            self.allowance_list\n                .insert(address, current_allowance + amount);\n\n            self.push_to_stack(1u64.to_be_bytes().to_vec());\n        } else {\n            self.push_to_stack(0u64.to_be_bytes().to_vec());\n        }\n\n        Ok(())\n    }\n\n    pub async fn op_increment_balance(\u0026mut self) -\u003e Result\u003c(), NodeError\u003e {\n        let address = self\n            .pop_from_stack()\n            .ok_or_else(|| self.signal_error(NodeError::Error(\"Missing address\".to_string())))?;\n\n        let amount = self\n            .pop_from_stack()\n            .ok_or_else(|| self.signal_error(NodeError::Error(\"Missing amount\".to_string())))?;\n\n        let address = String::from_utf8(address)\n            .map_err(|e| self.signal_error(NodeError::Error(e.to_string())))?;\n\n        let amount = u64::from_be_bytes(\n            amount\n                .try_into()\n                .map_err(|_| self.signal_error(NodeError::Error(\"Invalid amount\".to_string())))?,\n        );\n\n        let allowed = {\n            let allowance = self.allowance_list.get(\u0026address).copied().unwrap_or(0);\n            allowance \u003e= amount\n        };\n\n        if !allowed {\n            return Err(self.signal_error(NodeError::Error(\"Insufficient allowance\".to_string())));\n        }\n\n        // Deduct from allowance\n        let current_allowance = self.allowance_list.get(\u0026address).copied().unwrap_or(0);\n        self.allowance_list\n            .insert(address.clone(), current_allowance - amount);\n\n        let mut account = self\n            .new_chain_state\n            .get_account(\u0026address)\n            .cloned()\n            .unwrap_or(Account {\n                address: address.clone(),\n                balance: 0,\n            });\n\n        account.balance += amount;\n\n        self.new_chain_state.upsert_account(\u0026address, account);\n\n        // Push success to stack\n        self.push_to_stack(1u64.to_be_bytes().to_vec());\n\n        Ok(())\n    }\n}\n","traces":[{"line":22,"address":[],"length":0,"stats":{"Line":1}},{"line":25,"address":[6271631],"length":1,"stats":{"Line":6}},{"line":26,"address":[],"length":0,"stats":{"Line":3}},{"line":28,"address":[],"length":0,"stats":{"Line":3}},{"line":32,"address":[6265616],"length":1,"stats":{"Line":1}},{"line":37,"address":[6266098,6265941,6266071],"length":1,"stats":{"Line":6}},{"line":38,"address":[],"length":0,"stats":{"Line":11}},{"line":39,"address":[],"length":0,"stats":{"Line":6}},{"line":40,"address":[],"length":0,"stats":{"Line":3}},{"line":41,"address":[],"length":0,"stats":{"Line":7}},{"line":43,"address":[],"length":0,"stats":{"Line":5}},{"line":44,"address":[],"length":0,"stats":{"Line":11}},{"line":46,"address":[],"length":0,"stats":{"Line":1}},{"line":47,"address":[],"length":0,"stats":{"Line":5}},{"line":51,"address":[],"length":0,"stats":{"Line":4}},{"line":54,"address":[6260944],"length":1,"stats":{"Line":3}},{"line":55,"address":[],"length":0,"stats":{"Line":3}},{"line":58,"address":[],"length":0,"stats":{"Line":5}},{"line":59,"address":[6260993],"length":1,"stats":{"Line":3}},{"line":62,"address":[6260560,6260924],"length":1,"stats":{"Line":1}},{"line":63,"address":[],"length":0,"stats":{"Line":2}},{"line":64,"address":[],"length":0,"stats":{"Line":1}},{"line":65,"address":[],"length":0,"stats":{"Line":1}},{"line":68,"address":[],"length":0,"stats":{"Line":15}},{"line":69,"address":[],"length":0,"stats":{"Line":6}},{"line":71,"address":[],"length":0,"stats":{"Line":5}},{"line":73,"address":[],"length":0,"stats":{"Line":11}},{"line":74,"address":[6261731,6265229,6261653,6265200],"length":1,"stats":{"Line":5}},{"line":76,"address":[],"length":0,"stats":{"Line":10}},{"line":78,"address":[],"length":0,"stats":{"Line":3}},{"line":80,"address":[],"length":0,"stats":{"Line":6}},{"line":81,"address":[],"length":0,"stats":{"Line":5}},{"line":83,"address":[],"length":0,"stats":{"Line":8}},{"line":85,"address":[],"length":0,"stats":{"Line":4}},{"line":88,"address":[],"length":0,"stats":{"Line":7}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[6264912,6262881,6262976,6264936],"length":1,"stats":{"Line":4}},{"line":93,"address":[],"length":0,"stats":{"Line":22}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":4}},{"line":96,"address":[],"length":0,"stats":{"Line":10}},{"line":97,"address":[],"length":0,"stats":{"Line":5}},{"line":99,"address":[],"length":0,"stats":{"Line":2}},{"line":100,"address":[6264164,6263988],"length":1,"stats":{"Line":5}},{"line":101,"address":[6264224,6264341],"length":1,"stats":{"Line":4}},{"line":102,"address":[],"length":0,"stats":{"Line":3}},{"line":104,"address":[],"length":0,"stats":{"Line":2}},{"line":106,"address":[],"length":0,"stats":{"Line":2}},{"line":109,"address":[],"length":0,"stats":{"Line":1}},{"line":112,"address":[],"length":0,"stats":{"Line":4}},{"line":113,"address":[6268125,6268313,6268233,6270978],"length":1,"stats":{"Line":2}},{"line":115,"address":[6271472,6271491,6268281],"length":1,"stats":{"Line":0}},{"line":117,"address":[6268438,6268518,6270922,6268598],"length":1,"stats":{"Line":2}},{"line":119,"address":[6268566,6271203,6271184],"length":1,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":2}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[6269246,6270842,6269147,6269016],"length":1,"stats":{"Line":2}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[6271296,6269214,6271320],"length":1,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":1}},{"line":132,"address":[6269499],"length":1,"stats":{"Line":1}},{"line":135,"address":[],"length":0,"stats":{"Line":1}},{"line":136,"address":[6269595,6269521],"length":1,"stats":{"Line":2}},{"line":140,"address":[],"length":0,"stats":{"Line":6}},{"line":141,"address":[],"length":0,"stats":{"Line":2}},{"line":142,"address":[],"length":0,"stats":{"Line":6}},{"line":144,"address":[],"length":0,"stats":{"Line":9}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":1}},{"line":148,"address":[],"length":0,"stats":{"Line":1}},{"line":149,"address":[],"length":0,"stats":{"Line":1}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":2}},{"line":155,"address":[],"length":0,"stats":{"Line":6}},{"line":158,"address":[],"length":0,"stats":{"Line":1}},{"line":160,"address":[],"length":0,"stats":{"Line":5}}],"covered":67,"coverable":77},{"path":["/","home","vidyootsenthil","Documents","TheValut-nameTBD","crates","protocol","src","lib.rs"],"content":"pub mod block;\npub mod chain_state;\npub mod executor;\npub mod oracle;\npub mod proposal;\npub mod transaction;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","vidyootsenthil","Documents","TheValut-nameTBD","crates","protocol","src","oracle.rs"],"content":"use bitcoin::Txid;\nuse esplora_client::{AsyncClient, Builder};\nuse types::errors::NodeError;\n\n#[async_trait::async_trait]\npub trait Oracle {\n    async fn validate_transaction(\n        \u0026self,\n        address: \u0026str,\n        amount: u64,\n        tx_hash: Txid,\n    ) -\u003e Result\u003cbool, NodeError\u003e;\n}\n\npub struct BitcoinOracle {\n    pub esplora_client: AsyncClient,\n}\n\nimpl Default for BitcoinOracle {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n\nimpl BitcoinOracle {\n    pub fn new() -\u003e Self {\n        const BLOCKSTREAM_API_URL: \u0026str = \"https://blockstream.info/api\";\n        let builder = Builder::new(BLOCKSTREAM_API_URL);\n        let async_client = builder.build_async().unwrap();\n\n        Self {\n            esplora_client: async_client,\n        }\n    }\n}\n\n#[async_trait::async_trait]\nimpl Oracle for BitcoinOracle {\n    async fn validate_transaction(\n        \u0026self,\n        _address: \u0026str,\n        amount: u64,\n        tx_hash: Txid,\n    ) -\u003e Result\u003cbool, NodeError\u003e {\n        let tx = self\n            .esplora_client\n            .get_tx_info(\u0026tx_hash)\n            .await\n            .map_err(|e| NodeError::Error(e.to_string()))?;\n\n        let tx = tx.ok_or(NodeError::Error(\"Transaction not found\".to_string()))?;\n\n        if !tx.status.confirmed {\n            return Err(NodeError::Error(\"Transaction not confirmed\".to_string()));\n        }\n\n        let mut total_output = 0;\n        for output in tx.vout {\n            total_output += output.value;\n        }\n\n        if total_output != amount {\n            return Err(NodeError::Error(\n                \"Transaction output value mismatch\".to_string(),\n            ));\n        }\n\n        Ok(true)\n    }\n}\n","traces":[{"line":20,"address":[2619616],"length":1,"stats":{"Line":0}},{"line":21,"address":[2619624],"length":1,"stats":{"Line":0}},{"line":26,"address":[2619648],"length":1,"stats":{"Line":0}},{"line":28,"address":[2619665],"length":1,"stats":{"Line":0}},{"line":29,"address":[2619688],"length":1,"stats":{"Line":0}},{"line":45,"address":[2489898,2487863,2488229,2488139,2488105,2487798],"length":1,"stats":{"Line":0}},{"line":47,"address":[14938569],"length":1,"stats":{"Line":0}},{"line":48,"address":[17624119],"length":1,"stats":{"Line":0}},{"line":49,"address":[17543024,17541289,17543042],"length":1,"stats":{"Line":0}},{"line":51,"address":[2488609,2488360,2488417,2489844,2489826],"length":1,"stats":{"Line":0}},{"line":53,"address":[14939598],"length":1,"stats":{"Line":0}},{"line":54,"address":[17542037,17541880],"length":1,"stats":{"Line":0}},{"line":57,"address":[14477991],"length":1,"stats":{"Line":0}},{"line":58,"address":[2489043,2489170,2488815],"length":1,"stats":{"Line":0}},{"line":59,"address":[17853671,17854100,17854130],"length":1,"stats":{"Line":0}},{"line":62,"address":[17542444],"length":1,"stats":{"Line":0}},{"line":63,"address":[17853888],"length":1,"stats":{"Line":0}},{"line":64,"address":[2489384],"length":1,"stats":{"Line":0}},{"line":68,"address":[2489339],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":19},{"path":["/","home","vidyootsenthil","Documents","TheValut-nameTBD","crates","protocol","src","proposal.rs"],"content":"use types::errors::NodeError;\n\nuse crate::{block::BlockBody, transaction::Transaction};\n\npub struct ProposedBlock {\n    block_body: BlockBody,\n}\n\nimpl Default for ProposedBlock {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n\nimpl ProposedBlock {\n    pub fn new() -\u003e Self {\n        Self {\n            block_body: BlockBody::new(vec![]),\n        }\n    }\n\n    pub fn add_transaction(\u0026mut self, transaction: Transaction) -\u003e Result\u003c(), NodeError\u003e {\n        self.block_body.transactions.push(transaction);\n        Ok(())\n    }\n}\n","traces":[{"line":10,"address":[2603200],"length":1,"stats":{"Line":0}},{"line":11,"address":[2603208],"length":1,"stats":{"Line":0}},{"line":16,"address":[2603232],"length":1,"stats":{"Line":0}},{"line":18,"address":[2603246],"length":1,"stats":{"Line":0}},{"line":22,"address":[2603312],"length":1,"stats":{"Line":0}},{"line":23,"address":[2603355],"length":1,"stats":{"Line":0}},{"line":24,"address":[2603377],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":7},{"path":["/","home","vidyootsenthil","Documents","TheValut-nameTBD","crates","protocol","src","transaction.rs"],"content":"use bincode::{Decode, Encode};\nuse serde::{Deserialize, Serialize};\nuse sha2::{Digest, Sha256};\n\npub type TransactionId = [u8; 32];\n\n#[derive(Debug, Clone, Serialize, Deserialize, Encode, Decode, PartialEq)]\npub struct Transaction {\n    pub version: u32,\n    pub timestamp: u64,\n    pub r#type: TransactionType,\n    pub operations: Vec\u003cOperation\u003e,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize, Encode, Decode, PartialEq)]\npub enum TransactionType {\n    Deposit,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize, Encode, Decode, PartialEq)]\npub enum Operation {\n    /// Push a value to the stack in bytes\n    /// Data types:\n    ///    - Numbers: u64\n    ///    - Strings: utf-8 encoded string\n    ///    - Booleans: u8 (0 or 1)\n    ///    - Tx Hash: [u8; 32]\n    OpPush { value: Vec\u003cu8\u003e },\n    /// Check if the transaction is on the Bitcoin network. Modifies allowance list to allow the address to spend the amount.\n    /// Pops from the stack:\n    ///   - 0: The tx hash\n    ///   - 1: The address\n    ///   - 2: The amount\n    ///\n    /// Pushes to the stack:\n    ///   - 0: The result (0 or 1)\n    OpCheckOracle,\n    /// Increment the balance of the address on the stack. Checks the allowance list to see if the address is allowed to spend the amount.\n    /// Pops from the stack:\n    ///   - 0: The address\n    ///   - 1: The amount\n    ///\n    /// Pushes to the stack:\n    ///   - 0: The result (0 or 1)\n    OpIncrementBalance,\n}\n\nimpl Transaction {\n    pub fn new(r#type: TransactionType, operations: Vec\u003cOperation\u003e) -\u003e Self {\n        Transaction {\n            version: 1,\n            timestamp: std::time::SystemTime::now()\n                .duration_since(std::time::UNIX_EPOCH)\n                .unwrap()\n                .as_secs(),\n            r#type,\n            operations,\n        }\n    }\n\n    pub fn id(\u0026self) -\u003e TransactionId {\n        let mut hasher = Sha256::new();\n        hasher.update(self.version.to_le_bytes());\n        hasher.update(self.timestamp.to_le_bytes());\n\n        for op in \u0026self.operations {\n            let op_bytes = bincode::encode_to_vec(op, bincode::config::standard()).unwrap();\n            hasher.update(\u0026op_bytes);\n        }\n\n        let result = hasher.finalize();\n        let mut id = [0u8; 32];\n        id.copy_from_slice(\u0026result);\n        id\n    }\n}\n","traces":[{"line":49,"address":[17797574,17797280],"length":1,"stats":{"Line":8}},{"line":52,"address":[17797372,17797302],"length":1,"stats":{"Line":17}},{"line":61,"address":[17797600,17798218,17798224],"length":1,"stats":{"Line":0}},{"line":62,"address":[14505614],"length":1,"stats":{"Line":0}},{"line":63,"address":[2614141],"length":1,"stats":{"Line":0}},{"line":64,"address":[17797712],"length":1,"stats":{"Line":0}},{"line":66,"address":[14967439,14967417],"length":1,"stats":{"Line":0}},{"line":67,"address":[17797881],"length":1,"stats":{"Line":0}},{"line":68,"address":[14967588],"length":1,"stats":{"Line":0}},{"line":71,"address":[17569879],"length":1,"stats":{"Line":0}},{"line":72,"address":[17798020],"length":1,"stats":{"Line":0}},{"line":73,"address":[2614518],"length":1,"stats":{"Line":0}},{"line":74,"address":[2614580],"length":1,"stats":{"Line":0}}],"covered":2,"coverable":13},{"path":["/","home","vidyootsenthil","Documents","TheValut-nameTBD","crates","types","src","errors.rs"],"content":"use std::error::Error;\n\nuse derive_more::Display;\n\n#[derive(Debug, Display, Clone)]\npub enum NodeError {\n    Error(String),\n}\n\n#[derive(Debug)]\npub enum NetworkError {\n    SendError(String),\n    RecvError,\n}\n\nimpl From\u003crocksdb::Error\u003e for NodeError {\n    fn from(e: rocksdb::Error) -\u003e Self {\n        NodeError::Error(e.to_string())\n    }\n}\n\nimpl Error for NodeError {}\n","traces":[{"line":17,"address":[624896,625011],"length":1,"stats":{"Line":0}},{"line":18,"address":[624969,624920],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":2},{"path":["/","home","vidyootsenthil","Documents","TheValut-nameTBD","crates","types","src","lib.rs"],"content":"pub mod errors;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","vidyootsenthil","Documents","TheValut-nameTBD","tests","src","config.rs"],"content":"#[cfg(test)]\nmod config_test {\n    use node::NodeConfig;\n\n    #[test]\n    fn test_config_deserialization() {\n        let json_str = r#\"{\n            \"allowed_peers\": [\n                {\n                    \"public_key\": \"12D3KooWRdtE2nFybk8eMyp3D9B4NvunUYqpN6JDvBcVPTcrDsbF\",\n                    \"name\": \"node-four\"\n                }\n            ],\n            \"key_data\": {\n                \"public_key_b58\": \"12D3KooWQDHzW448RmDoUz1KbMfuD4XqeojRJDsxqUZSEYo7FSUz\",\n                \"encrypted_private_key_b64\": \"EnCF8bEe3tVyMV0EUIK29bOMNjH7gT7mx4ATyBr4WSdphw5ETfm1YdQHDAg+CzBBjt7K2FSbwv8Qkj1y3N4jTU/FkGHggfkwDDl5XkDc5rXi2BW/\",\n                \"encryption_params\": {\n                    \"kdf\": \"argon2id\",\n                    \"salt_b64\": \"TnErEFlx9F1BeU8mJcFzKQ\",\n                    \"iv_b64\": \"hybTge0qoPaxNUhP\"\n                }\n            }\n        }\"#;\n\n        let config: NodeConfig = serde_json::from_str(json_str).expect(\"Failed to deserialize\");\n        assert_eq!(config.allowed_peers.len(), 1);\n        assert_eq!(\n            config.key_data.public_key_b58,\n            \"12D3KooWQDHzW448RmDoUz1KbMfuD4XqeojRJDsxqUZSEYo7FSUz\"\n        );\n        assert!(config.dkg_keys.is_none());\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","vidyootsenthil","Documents","TheValut-nameTBD","tests","src","deposit","mod.rs"],"content":"#[cfg(test)]\nmod deposit_tests {\n    use std::str::FromStr;\n\n    use crate::mocks::network::MockNodeCluster;\n    use bitcoin::Address;\n    use node::{\n        db::Db,\n        grpc::{\n            grpc_handler::node_proto::{CreateDepositIntentRequest, CreateDepositIntentResponse},\n            grpc_operator,\n        },\n    };\n    use tokio::sync::mpsc::unbounded_channel;\n\n    #[tokio::test]\n    async fn deposit_intent_creates_valid_address_and_persists_on_node() {\n        let mut cluster = MockNodeCluster::new_with_keys(2, 2, 2).await;\n        cluster.setup().await;\n\n        let node_peer = *cluster.nodes.keys().next().unwrap();\n        let amount_sat = 50_000;\n        let (tx, mut rx) = unbounded_channel::\u003cCreateDepositIntentResponse\u003e();\n        let network = cluster.networks.get(\u0026node_peer).unwrap().clone();\n\n        tokio::spawn(async move {\n            let response = grpc_operator::create_deposit_intent(\n                \u0026network,\n                CreateDepositIntentRequest {\n                    amount_satoshis: amount_sat,\n                },\n            )\n            .await\n            .expect(\"Failed to create deposit intent\");\n            tx.send(response).unwrap();\n        });\n\n        cluster.run_n_iterations(10).await;\n\n        let response = rx.recv().await.unwrap();\n        let node = cluster.nodes.get(\u0026node_peer).unwrap();\n        let db = \u0026node.db;\n\n        // retrieve the first deposit intent stored\n        let intent_opt = db\n            .get_deposit_intent(\u0026response.deposit_tracking_id)\n            .unwrap();\n\n        assert!(intent_opt.is_some(), \"deposit intent not stored\");\n        let intent = intent_opt.unwrap();\n\n        // parse address and validate\n        let addr = Address::from_str(\u0026intent.deposit_address).unwrap();\n        assert!(addr.is_valid_for_network(bitcoin::Network::Signet));\n    }\n\n    #[tokio::test]\n    async fn deposit_intent_creates_valid_address_and_persists_on_node_and_is_broadcasted() {\n        let mut cluster = MockNodeCluster::new_with_keys(2, 2, 2).await;\n        cluster.setup().await;\n\n        let node_peer = *cluster.nodes.keys().next().unwrap();\n        let amount_sat = 50_000;\n        let network = cluster.networks.get(\u0026node_peer).unwrap().clone();\n        let (tx, mut rx) = unbounded_channel::\u003cCreateDepositIntentResponse\u003e();\n\n        tokio::spawn(async move {\n            let response = grpc_operator::create_deposit_intent(\n                \u0026network,\n                CreateDepositIntentRequest {\n                    amount_satoshis: amount_sat,\n                },\n            )\n            .await\n            .expect(\"Failed to create deposit intent\");\n            tx.send(response).unwrap();\n        });\n\n        cluster.run_n_iterations(10).await;\n\n        let response = rx.recv().await.unwrap();\n\n        for (_, node) in cluster.nodes.iter() {\n            let intent_opt = node\n                .db\n                .get_deposit_intent(\u0026response.deposit_tracking_id)\n                .unwrap();\n            assert!(intent_opt.is_some(), \"deposit intent not stored\");\n            let intent = intent_opt.unwrap();\n            assert_eq!(intent.deposit_address, response.deposit_address);\n        }\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","vidyootsenthil","Documents","TheValut-nameTBD","tests","src","dkg","mod.rs"],"content":"#[cfg(test)]\nmod dkg_test {\n    use crate::mocks::network::MockNodeCluster;\n    use bincode;\n    use env_logger;\n    use log::info;\n    use node::db::Db;\n    use node::swarm_manager::DirectMessage;\n    use node::swarm_manager::NetworkEvent;\n    use protocol::block::{ChainConfig, ValidatorInfo};\n    use sha2::{Digest, Sha256};\n\n    fn setup() {\n        let _ = env_logger::builder().is_test(true).try_init();\n    }\n\n    #[tokio::test]\n    async fn peers_send_start_dkg_at_startup() {\n        setup();\n        let mut cluster = MockNodeCluster::new(2, 2, 2).await;\n        cluster.setup().await;\n        info!(\"Ran setup\");\n\n        cluster.run_n_iterations(1).await;\n        info!(\"Ran 1 iterations\");\n\n        for (_, node) in cluster.nodes.iter() {\n            assert_eq!(node.peers.len(), 1);\n        }\n\n        for (peer, sender) in cluster.senders.iter() {\n            info!(\n                \"Peer {} has {} pending events\",\n                peer,\n                sender.pending_events.len()\n            );\n        }\n\n        cluster.tear_down().await;\n        info!(\"Ran teardown\");\n    }\n\n    #[tokio::test]\n    async fn test_dkg_round1_broadcasts() {\n        setup();\n        let mut cluster = MockNodeCluster::new(3, 2, 3).await;\n\n        cluster.setup().await;\n        info!(\"Started DKG Round1 test with {} nodes\", cluster.nodes.len());\n\n        // Run exactly one iteration to trigger DKG start and round1\n        cluster.run_n_iterations(1).await;\n\n        // Count the different types of messages that were generated\n        let mut start_dkg_broadcasts = 0;\n        let mut round1_broadcasts = 0;\n        let mut other_messages = 0;\n\n        // Check all pending events across all networks\n        for (from_peer, sender) in cluster.senders.iter() {\n            let pending_events = \u0026sender.pending_events;\n            info!(\n                \"Peer {} has {} pending events\",\n                from_peer,\n                pending_events.len()\n            );\n\n            for event in pending_events.iter() {\n                match \u0026event {\n                    NetworkEvent::GossipsubMessage(msg) =\u003e {\n                        let topic_str = format!(\"{:?}\", msg.topic);\n                        let data_str = String::from_utf8_lossy(\u0026msg.data);\n\n                        if topic_str.contains(\"start-dkg\") {\n                            start_dkg_broadcasts += 1;\n                        } else if data_str.contains(\"Round1\") || topic_str.contains(\"round1\") {\n                            round1_broadcasts += 1;\n                        } else {\n                            other_messages += 1;\n                        }\n                    }\n                    _ =\u003e {\n                        other_messages += 1;\n                        info!(\"  Other event from {}: {:?}\", from_peer, event);\n                    }\n                }\n            }\n        }\n\n        info!(\"Message count summary:\");\n        info!(\"  Start-DKG broadcasts: {}\", start_dkg_broadcasts);\n        info!(\"  Round1 broadcasts: {}\", round1_broadcasts);\n        info!(\"  Other messages: {}\", other_messages);\n\n        // Verify each peer sent a start-dkg broadcast\n        assert!(\n            start_dkg_broadcasts \u003e= cluster.nodes.len(),\n            \"Expected at least {} start-dkg broadcasts, got {}\",\n            cluster.nodes.len(),\n            start_dkg_broadcasts\n        );\n\n        // After DKG starts, we expect round1 broadcasts from each peer\n        // Note: This might happen in the same iteration or the next one\n        info!(\"✅ DKG Round1 broadcast verification completed\");\n        cluster.tear_down().await;\n    }\n\n    #[tokio::test]\n    async fn test_dkg_round2_private_requests() {\n        setup();\n        let mut cluster = MockNodeCluster::new(3, 2, 3).await;\n\n        cluster.setup().await;\n        info!(\"Started DKG Round2 test with {} nodes\", cluster.nodes.len());\n\n        // Run several iterations to allow round1 to complete\n        let mut round1_complete = false;\n        let mut round2_private_requests = 0;\n\n        for iteration in 1..=10 {\n            info!(\"--- Iteration {} ---\", iteration);\n            cluster.run_n_iterations(1).await;\n\n            // Check for round2 private messages in the pending events\n            let mut current_round2_requests = 0;\n\n            for (_, sender) in cluster.senders.iter() {\n                let pending_events = \u0026sender.pending_events;\n                info!(\"  {} pending events\", pending_events.len());\n                for event in pending_events.iter() {\n                    match \u0026event {\n                        NetworkEvent::GossipsubMessage(msg) =\u003e {\n                            let data_str = String::from_utf8_lossy(\u0026msg.data);\n                            // This is a broadcast\n                            if data_str.contains(\"Round1\") {\n                                info!(\"  Still processing Round1 broadcasts\");\n                            }\n                        }\n                        NetworkEvent::MessageEvent((_, direct_message)) =\u003e {\n                            info!(\"  Found MessageEvent\");\n                            if let DirectMessage::Round2Package(_) = direct_message {\n                                info!(\"  Found Round2 private request\");\n                                current_round2_requests += 1;\n                            }\n                        }\n                        _ =\u003e {\n                            info!(\"  Other event: {:?}\", event);\n                        }\n                    }\n                }\n            }\n\n            if current_round2_requests \u003e 0 {\n                round2_private_requests += current_round2_requests;\n                round1_complete = true;\n                info!(\n                    \"  Found {} Round2 private requests in iteration {}\",\n                    current_round2_requests, iteration\n                );\n            }\n\n            // If we've seen round2 requests, we can verify our expectations\n            if round1_complete \u0026\u0026 round2_private_requests \u003e 0 {\n                break;\n            }\n        }\n\n        info!(\"Round2 private request summary:\");\n        info!(\"  Round1 complete: {}\", round1_complete);\n        info!(\"  Round2 private requests: {}\", round2_private_requests);\n\n        // Verify that round2 private requests were sent after round1\n        assert!(\n            round1_complete,\n            \"Round1 should complete and trigger Round2 private requests\"\n        );\n\n        assert!(\n            round2_private_requests \u003e 0,\n            \"Expected Round2 private requests after Round1 completion, got {}\",\n            round2_private_requests\n        );\n\n        info!(\"✅ DKG Round2 private request verification completed\");\n        cluster.tear_down().await;\n    }\n\n    #[tokio::test]\n    async fn test_dkg_completion() {\n        setup();\n        let mut cluster = MockNodeCluster::new(3, 2, 3).await;\n        cluster.setup().await;\n        info!(\"Started DKG test with {} nodes\", cluster.nodes.len());\n\n        // Keep running iterations until no events are left\n        let mut iteration_count = 0;\n        let max_iterations = 100; // Safety limit to prevent infinite loops\n\n        loop {\n            iteration_count += 1;\n\n            if iteration_count \u003e max_iterations {\n                panic!(\"DKG test exceeded maximum iterations ({})\", max_iterations);\n            }\n\n            // Run one iteration\n            cluster.run_n_iterations(1).await;\n\n            // Check if there are any pending events across all senders\n            let mut total_pending_events = 0;\n            for (_, sender) in cluster.senders.iter() {\n                total_pending_events += sender.pending_events.len();\n            }\n\n            // Also check network pending events\n            for (_, network) in cluster.networks.iter() {\n                let pending_events = network.pending_events.lock().unwrap();\n                total_pending_events += pending_events.len();\n            }\n\n            info!(\n                \"Iteration {}: {} total pending events\",\n                iteration_count, total_pending_events\n            );\n\n            if total_pending_events == 0 {\n                info!(\n                    \"No more pending events after {} iterations\",\n                    iteration_count\n                );\n                break;\n            }\n        }\n\n        // Verify that each node has DKG public and private key pairs\n        for (peer_id, node) in cluster.nodes.iter() {\n            assert!(\n                node.pubkey_package.is_some(),\n                \"Node {} should have a public key package after DKG completion\",\n                peer_id\n            );\n            assert!(\n                node.private_key_package.is_some(),\n                \"Node {} should have a private key package after DKG completion\",\n                peer_id\n            );\n            info!(\"✅ Node {} has both DKG public and private keys\", peer_id);\n        }\n\n        info!(\n            \"🎉 DKG completed successfully on all {} nodes!\",\n            cluster.nodes.len()\n        );\n        cluster.tear_down().await;\n    }\n\n    #[tokio::test]\n    async fn test_dkg_completes_within_5_iterations() {\n        setup();\n        let mut cluster = MockNodeCluster::new(3, 2, 3).await;\n        cluster.setup().await;\n        info!(\n            \"Started DKG completion test (within 5 iterations) with {} nodes\",\n            cluster.nodes.len()\n        );\n\n        let max_iterations = 5;\n        cluster.run_n_iterations(max_iterations).await;\n        info!(\"Ran {} iterations\", max_iterations);\n\n        for (peer_id, node) in cluster.nodes.iter() {\n            assert!(\n                node.pubkey_package.is_some(),\n                \"Node {} should have a public key package after {} iterations\",\n                peer_id,\n                max_iterations\n            );\n            assert!(\n                node.private_key_package.is_some(),\n                \"Node {} should have a private key package after {} iterations\",\n                peer_id,\n                max_iterations\n            );\n        }\n\n        info!(\n            \"🎉 DKG completed successfully on all {} nodes within {} iterations\",\n            cluster.nodes.len(),\n            max_iterations\n        );\n        cluster.tear_down().await;\n    }\n\n    #[tokio::test]\n    #[ignore] // ignoring because it takes a long time to run\n    async fn test_dkg_completion_256_nodes() {\n        setup();\n        let start_time = std::time::Instant::now();\n        let mut cluster = MockNodeCluster::new(256, 171, 256).await;\n        cluster.setup().await;\n        info!(\"Started DKG test with {} nodes\", cluster.nodes.len());\n\n        // Keep running iterations until no events are left\n        let mut iteration_count = 0;\n        let max_iterations = 200; // Safety limit to prevent infinite loops\n\n        loop {\n            iteration_count += 1;\n\n            if iteration_count \u003e max_iterations {\n                panic!(\"DKG test exceeded maximum iterations ({})\", max_iterations);\n            }\n\n            // Run one iteration\n            cluster.run_n_iterations(1).await;\n\n            // Check if there are any pending events across all senders\n            let mut total_pending_events = 0;\n            for (_, sender) in cluster.senders.iter() {\n                total_pending_events += sender.pending_events.len();\n            }\n\n            // Also check network pending events\n            for (_, network) in cluster.networks.iter() {\n                let pending_events = network.pending_events.lock().unwrap();\n                total_pending_events += pending_events.len();\n            }\n\n            info!(\n                \"Iteration {}: {} total pending events\",\n                iteration_count, total_pending_events\n            );\n\n            if total_pending_events == 0 {\n                info!(\n                    \"No more pending events after {} iterations\",\n                    iteration_count\n                );\n                break;\n            }\n        }\n\n        // Verify that each node has DKG public and private key pairs\n        for (peer_id, node) in cluster.nodes.iter() {\n            assert!(\n                node.pubkey_package.is_some(),\n                \"Node {} should have a public key package after DKG completion\",\n                peer_id\n            );\n            assert!(\n                node.private_key_package.is_some(),\n                \"Node {} should have a private key package after DKG completion\",\n                peer_id\n            );\n            info!(\"✅ Node {} has both DKG public and private keys\", peer_id);\n        }\n\n        let duration = start_time.elapsed();\n        info!(\"DKG completion for 256 nodes took: {:?}\", duration);\n\n        assert!(\n            duration \u003c std::time::Duration::from_secs(300),\n            \"DKG for 256 nodes took too long: {:?}\",\n            duration\n        );\n\n        info!(\n            \"🎉 DKG completed successfully on all {} nodes!\",\n            cluster.nodes.len()\n        );\n        cluster.tear_down().await;\n    }\n\n    #[tokio::test]\n    async fn test_genesis_block_contains_dkg_metadata() {\n        setup();\n        let mut cluster = MockNodeCluster::new(3, 2, 3).await;\n        cluster.setup().await;\n        info!(\n            \"Started genesis block DKG metadata test with {} nodes\",\n            cluster.nodes.len()\n        );\n\n        cluster.run_n_iterations(10).await;\n\n        for (peer_id, node) in cluster.nodes.iter() {\n            let genesis_block_from_db = node.db.get_block_by_height(0).unwrap().unwrap();\n\n            let dkg_pub_key = node.pubkey_package.clone().unwrap();\n            let mut validators: Vec\u003cValidatorInfo\u003e = node\n                .peers\n                .iter()\n                .map(|p| ValidatorInfo {\n                    pub_key: p.to_bytes(),\n                    stake: 100,\n                })\n                .collect();\n\n            validators.sort_by(|a, b| a.pub_key.cmp(\u0026b.pub_key));\n\n            let chain_config = ChainConfig {\n                min_signers: node.min_signers,\n                max_signers: node.max_signers,\n                min_stake: 100,\n                block_time_seconds: 10,\n                max_block_size: 1000,\n            };\n\n            let expected_initial_state = protocol::block::GenesisState {\n                validators,\n                vault_pub_key: dkg_pub_key.serialize().unwrap(),\n                initial_balances: vec![],\n                chain_config,\n            };\n\n            let mut hasher = Sha256::new();\n            hasher.update(b\"GENESIS\");\n            hasher.update(genesis_block_from_db.header.timestamp.to_le_bytes());\n            let state_bytes =\n                bincode::encode_to_vec(\u0026expected_initial_state, bincode::config::standard())\n                    .unwrap();\n            hasher.update(\u0026state_bytes);\n            let mut expected_state_root = [0u8; 32];\n            expected_state_root.copy_from_slice(\u0026hasher.finalize());\n\n            assert_eq!(\n                genesis_block_from_db.header.state_root, expected_state_root,\n                \"Node {} should have the correct genesis block state root\",\n                peer_id\n            );\n            info!(\"Genesis block metadata verified for node {}\", peer_id);\n        }\n\n        info!(\"Genesis block metadata verified for all nodes!\");\n        cluster.tear_down().await;\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","vidyootsenthil","Documents","TheValut-nameTBD","tests","src","esplora_client","mod.rs"],"content":"#[cfg(test)]\nmod esplora_client_test {\n    use bitcoin::{Address, Network};\n    use clients::{EsploraApiClient, WindowedConfirmedTransactionProvider};\n    use esplora_client::Builder;\n    use std::str::FromStr;\n\n    #[tokio::test]\n    async fn test_get_confirmed_transactions() {\n        let client = EsploraApiClient::new(\n            Builder::new(\"https://blockstream.info/api\")\n                .build_async()\n                .unwrap(),\n            100,\n            None,\n        );\n        let address = Address::from_str(\"bc1qezwz3yt46nsgzcwlg0dsw680nryjpq5u8pvzts\")\n            .unwrap()\n            .require_network(Network::Bitcoin)\n            .unwrap();\n        let transactions = client\n            .get_confirmed_transactions(vec![address.clone()], 899900, 899930)\n            .await\n            .unwrap();\n\n        let correct_txs = [\n            \"99c024e891c3110297513a1bc8c6f36948b36461096e664be72c3ac96e958c5c\",\n            \"1d0249929acaf31c2c6b6e6f9c72f44bd663a426cb146afe0b7bbaa66e0bc0df\",\n            \"fdcd9cf8d660e359a6ab2993d649276fca60be01c2b4327f95ad2527cbe3db08\",\n            \"3fd280c3ccc13f0f88433f0ce95aeebacc249565c8e8b671005302de0616babe\",\n            \"a8705186a9d6b5063484a8029b0e2c4064e3e2723ea61ea10b6bc38d0abbc77a\",\n        ];\n\n        assert_eq!(transactions.len(), correct_txs.len());\n\n        for tx in transactions {\n            assert!(correct_txs.contains(\u0026tx.compute_txid().to_string().as_str()));\n        }\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","vidyootsenthil","Documents","TheValut-nameTBD","tests","src","lib.rs"],"content":"pub mod deposit;\npub mod dkg;\npub mod esplora_client;\npub mod mocks;\npub mod protocol;\npub mod signing;\npub mod util;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","vidyootsenthil","Documents","TheValut-nameTBD","tests","src","mocks","db.rs"],"content":"use std::collections::HashMap;\n\nuse node::db::Db;\nuse node::deposit_intents::DepositIntent;\nuse protocol::{\n    block::{Block, BlockHash},\n    chain_state::ChainState,\n};\nuse types::errors::NodeError;\n\npub struct MockDb {\n    pub blocks: HashMap\u003cBlockHash, Block\u003e,\n    pub chain_state: ChainState,\n    pub height_map: HashMap\u003cu64, BlockHash\u003e,\n    pub tip_block_hash: Option\u003cBlockHash\u003e,\n    pub deposit_intents: HashMap\u003cString, DepositIntent\u003e,\n}\n\nimpl Default for MockDb {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n\nimpl MockDb {\n    pub fn new() -\u003e Self {\n        Self {\n            blocks: HashMap::new(),\n            chain_state: ChainState::new(),\n            height_map: HashMap::new(),\n            tip_block_hash: None,\n            deposit_intents: HashMap::new(),\n        }\n    }\n}\n\nimpl Db for MockDb {\n    fn get_block_by_height(\u0026self, height: u64) -\u003e Result\u003cOption\u003cBlock\u003e, NodeError\u003e {\n        let block_hash = self.height_map.get(\u0026height).cloned();\n        Ok(block_hash.and_then(|hash| self.blocks.get(\u0026hash).cloned()))\n    }\n\n    fn get_block_by_hash(\u0026self, hash: BlockHash) -\u003e Result\u003cOption\u003cBlock\u003e, NodeError\u003e {\n        Ok(self.blocks.get(\u0026hash).cloned())\n    }\n\n    fn get_tip_block_hash(\u0026self) -\u003e Result\u003cOption\u003cBlockHash\u003e, NodeError\u003e {\n        Ok(self.tip_block_hash)\n    }\n\n    fn insert_chain_state(\u0026mut self, chain_state: ChainState) -\u003e Result\u003c(), NodeError\u003e {\n        self.chain_state = chain_state;\n        Ok(())\n    }\n\n    fn get_chain_state(\u0026self) -\u003e Result\u003cOption\u003cChainState\u003e, NodeError\u003e {\n        Ok(Some(self.chain_state.clone()))\n    }\n\n    fn insert_block(\u0026mut self, block: Block) -\u003e Result\u003c(), NodeError\u003e {\n        self.blocks.insert(block.hash(), block.clone());\n        self.height_map.insert(block.header.height, block.hash());\n        self.tip_block_hash = Some(block.hash());\n        Ok(())\n    }\n\n    fn insert_deposit_intent(\u0026mut self, intent: DepositIntent) -\u003e Result\u003c(), NodeError\u003e {\n        self.deposit_intents\n            .insert(intent.deposit_tracking_id.clone(), intent);\n        Ok(())\n    }\n\n    fn get_deposit_intent(\u0026self, tracking_id: \u0026str) -\u003e Result\u003cOption\u003cDepositIntent\u003e, NodeError\u003e {\n        Ok(self.deposit_intents.get(tracking_id).cloned())\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","vidyootsenthil","Documents","TheValut-nameTBD","tests","src","mocks","mod.rs"],"content":"pub mod db;\npub mod network;\npub mod oracle;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","vidyootsenthil","Documents","TheValut-nameTBD","tests","src","mocks","network.rs"],"content":"use std::{\n    collections::BTreeMap,\n    path::PathBuf,\n    sync::{Arc, Mutex},\n    time::Duration,\n};\n\nuse frost_secp256k1::Identifier;\nuse node::{\n    NodeState,\n    swarm_manager::{DirectMessage, Network, NetworkEvent, NetworkResponseFuture, SelfResponse},\n};\nuse tokio::sync::{broadcast, mpsc::unbounded_channel};\nuse types::errors::{self, NetworkError};\n\n// Import MockDb from our mocks module\nuse crate::mocks::db::MockDb;\n\nuse crate::util::local_dkg::perform_distributed_key_generation;\n\n#[derive(Debug)]\npub struct SenderToNode {\n    pub pending_events: Vec\u003cNetworkEvent\u003e,\n    events_emitter_tx: broadcast::Sender\u003cNetworkEvent\u003e,\n}\n\nimpl SenderToNode {\n    fn new(events_emitter_tx: broadcast::Sender\u003cNetworkEvent\u003e) -\u003e Self {\n        Self {\n            pending_events: Vec::new(),\n            events_emitter_tx,\n        }\n    }\n\n    fn queue(\u0026mut self, event: NetworkEvent) {\n        self.pending_events.push(event);\n    }\n\n    fn flush(\u0026mut self) {\n        for event in self.pending_events.drain(..) {\n            self.events_emitter_tx.send(event).unwrap();\n        }\n    }\n}\n\n#[derive(Debug)]\npub struct PendingNetworkEvent {\n    pub from_peer: libp2p::PeerId,\n    pub event: NetworkEvent,\n    pub target_peers: Vec\u003clibp2p::PeerId\u003e, // Empty vec means broadcast to all\n}\n\n#[derive(Debug, Clone)]\n#[allow(dead_code)]\npub struct MockNetwork {\n    pub peer: libp2p::PeerId,\n    pub events_emitter_tx: broadcast::Sender\u003cNetworkEvent\u003e,\n    pub pending_events: Arc\u003cMutex\u003cVec\u003cPendingNetworkEvent\u003e\u003e\u003e,\n}\n\nimpl MockNetwork {\n    pub fn new(events_emitter_tx: broadcast::Sender\u003cNetworkEvent\u003e, peer: libp2p::PeerId) -\u003e Self {\n        Self {\n            events_emitter_tx,\n            peer,\n            pending_events: Arc::new(Mutex::new(Vec::new())),\n        }\n    }\n}\n\nimpl Network for MockNetwork {\n    fn peer_id(\u0026self) -\u003e libp2p::PeerId {\n        self.peer\n    }\n\n    fn send_broadcast(\n        \u0026self,\n        topic: libp2p::gossipsub::IdentTopic,\n        message: Vec\u003cu8\u003e,\n    ) -\u003e Result\u003c(), errors::NetworkError\u003e {\n        let gossip_message = libp2p::gossipsub::Message {\n            source: Some(self.peer),\n            data: message,\n            sequence_number: None,\n            topic: topic.hash(),\n        };\n\n        // Queue the event instead of sending immediately\n        let pending_event = PendingNetworkEvent {\n            from_peer: self.peer,\n            event: NetworkEvent::GossipsubMessage(gossip_message),\n            target_peers: Vec::new(), // Empty means broadcast to all\n        };\n\n        println!(\"Queuing broadcast event: {:?}\", pending_event);\n\n        self.pending_events.lock().unwrap().push(pending_event);\n        Ok(())\n    }\n\n    fn send_private_message(\n        \u0026self,\n        peer_id: libp2p::PeerId,\n        request: node::swarm_manager::DirectMessage,\n    ) -\u003e Result\u003c(), errors::NetworkError\u003e {\n        // For mock purposes, we'll create a simplified message event\n        // In a real implementation, this would use proper request-response channels\n        let pending_event = PendingNetworkEvent {\n            from_peer: self.peer,\n            event: NetworkEvent::MessageEvent((self.peer_id(), request)),\n            target_peers: vec![peer_id],\n        };\n\n        self.pending_events.lock().unwrap().push(pending_event);\n        Ok(())\n    }\n\n    #[allow(unused_variables)]\n    fn send_self_request(\n        \u0026self,\n        request: node::swarm_manager::SelfRequest,\n        sync: bool,\n    ) -\u003e Result\u003cOption\u003cNetworkResponseFuture\u003e, errors::NetworkError\u003e {\n        if sync {\n            let (tx, mut rx) = unbounded_channel::\u003cSelfResponse\u003e();\n\n            let network_message = NetworkEvent::SelfRequest {\n                request,\n                response_channel: Some(tx),\n            };\n\n            self.events_emitter_tx\n                .send(network_message)\n                .map_err(|e| NetworkError::SendError(e.to_string()))?;\n\n            Ok(Some(Box::pin(async move {\n                rx.recv().await.ok_or(NetworkError::RecvError)\n            })))\n        } else {\n            let network_message = NetworkEvent::SelfRequest {\n                request,\n                response_channel: None,\n            };\n\n            self.events_emitter_tx\n                .send(network_message)\n                .map_err(|e| NetworkError::SendError(e.to_string()))?;\n\n            Ok(None)\n        }\n    }\n}\n\npub struct MockNodeCluster {\n    pub nodes: BTreeMap\u003clibp2p::PeerId, NodeState\u003cMockNetwork, MockDb\u003e\u003e,\n    pub senders: BTreeMap\u003clibp2p::PeerId, SenderToNode\u003e,\n    pub networks: BTreeMap\u003clibp2p::PeerId, MockNetwork\u003e,\n}\n\nimpl MockNodeCluster {\n    pub async fn new(peers: u32, min_signers: u16, max_signers: u16) -\u003e Self {\n        let mut path = PathBuf::new();\n        path.push(\"config.json\");\n\n        let mut config_path = PathBuf::new();\n        config_path.push(\"config.toml\");\n\n        let node_config = node::NodeConfig::new(path.clone(), config_path, None, \"test-password\")\n            .expect(\"Failed to create node config\");\n\n        let mut nodes = BTreeMap::new();\n        let mut senders = BTreeMap::new();\n        let mut networks = BTreeMap::new();\n\n        for _i in 0..peers {\n            let peer_id = libp2p::PeerId::random();\n            let Ok((node, network)) =\n                create_node_network(peer_id, node_config.clone(), min_signers, max_signers)\n            else {\n                panic!(\"Failed to create node network\");\n            };\n\n            nodes.insert(peer_id, node);\n            senders.insert(\n                peer_id,\n                SenderToNode::new(network.events_emitter_tx.clone()),\n            );\n            networks.insert(peer_id, network);\n        }\n\n        Self {\n            nodes,\n            senders,\n            networks,\n        }\n    }\n\n    pub async fn setup(\u0026mut self) {\n        // Set environment variable for testing\n        #[allow(clippy::missing_safety_doc)]\n        unsafe {\n            std::env::set_var(\"KEY_PASSWORD\", \"test-password\");\n        }\n\n        let peers: Vec\u003clibp2p::PeerId\u003e = self.nodes.keys().cloned().collect();\n        for (receipient_peer, sender) in self.senders.iter_mut() {\n            sender.queue(NetworkEvent::PeersConnected(\n                peers\n                    .iter()\n                    .filter(|peer_id| *peer_id != receipient_peer)\n                    .map(|peer_id| (*peer_id, libp2p::Multiaddr::empty()))\n                    .collect(),\n            ));\n\n            for peer_id in peers.iter().filter(|peer_id| *peer_id != receipient_peer) {\n                sender.queue(NetworkEvent::Subscribed {\n                    peer_id: *peer_id,\n                    topic: libp2p::gossipsub::IdentTopic::new(\"start-dkg\").hash(),\n                });\n            }\n\n            sender.flush();\n        }\n    }\n\n    pub async fn tear_down(\u0026mut self) {\n        let peers: Vec\u003clibp2p::PeerId\u003e = self.nodes.keys().cloned().collect();\n        for (_, sender) in self.senders.iter_mut() {\n            sender.queue(NetworkEvent::PeersDisconnected(\n                peers\n                    .iter()\n                    .map(|peer_id| (*peer_id, libp2p::Multiaddr::empty()))\n                    .collect(),\n            ));\n        }\n    }\n\n    pub async fn run_n_iterations(\u0026mut self, iterations: u32) {\n        for _ in 0..iterations {\n            // Flush all messages\n            for (_, sender) in self.senders.iter_mut() {\n                sender.flush();\n            }\n\n            // Poll Nodes\n            for (_, node) in self.nodes.iter_mut() {\n                loop {\n                    let more = node.try_poll().await.expect(\"Failed to poll node\");\n                    if !more {\n                        break;\n                    }\n                }\n            }\n\n            // Process any network events generated during polling\n            self.process_network_events().await;\n            tokio::time::sleep(Duration::from_millis(100)).await;\n        }\n    }\n\n    // Process network events that were generated during node polling\n    async fn process_network_events(\u0026mut self) {\n        // Collect all pending events from all networks\n        let mut all_pending_events = Vec::new();\n\n        for (_, network) in self.networks.iter() {\n            let mut pending_events = network.pending_events.lock().unwrap();\n            all_pending_events.extend(pending_events.drain(..));\n        }\n\n        // Process each pending event\n        for pending_event in all_pending_events {\n            self.forward_event_to_peers(pending_event).await;\n        }\n    }\n\n    // Forward a single event to the appropriate target peers\n    async fn forward_event_to_peers(\u0026mut self, pending_event: PendingNetworkEvent) {\n        if pending_event.target_peers.is_empty() {\n            // Broadcast to all peers except the sender\n            let target_peers: Vec\u003clibp2p::PeerId\u003e = self\n                .senders\n                .keys()\n                .filter(|peer_id| **peer_id != pending_event.from_peer)\n                .cloned()\n                .collect();\n\n            for target_peer in target_peers {\n                if let Some(sender) = self.senders.get_mut(\u0026target_peer) {\n                    // We need to recreate the event for each peer since NetworkEvent doesn't implement Clone\n                    let event = match \u0026pending_event.event {\n                        NetworkEvent::GossipsubMessage(msg) =\u003e {\n                            NetworkEvent::GossipsubMessage(libp2p::gossipsub::Message {\n                                source: msg.source,\n                                data: msg.data.clone(),\n                                sequence_number: msg.sequence_number,\n                                topic: msg.topic.clone(),\n                            })\n                        }\n                        NetworkEvent::SelfRequest { request, .. } =\u003e NetworkEvent::SelfRequest {\n                            request: request.clone(),\n                            response_channel: None,\n                        },\n                        NetworkEvent::Subscribed { peer_id, topic } =\u003e NetworkEvent::Subscribed {\n                            peer_id: *peer_id,\n                            topic: topic.clone(),\n                        },\n                        NetworkEvent::MessageEvent((peer, message)) =\u003e {\n                            NetworkEvent::MessageEvent((*peer, message.clone()))\n                        }\n                        NetworkEvent::PeersConnected(items) =\u003e {\n                            NetworkEvent::PeersConnected(items.clone())\n                        }\n                        NetworkEvent::PeersDisconnected(items) =\u003e {\n                            NetworkEvent::PeersDisconnected(items.clone())\n                        }\n                        _ =\u003e {\n                            panic!(\"Unexpected event type: {:?}\", pending_event.event);\n                        }\n                    };\n                    sender.queue(event);\n                }\n            }\n        } else {\n            // Send to specific target peers\n            for target_peer in pending_event.target_peers {\n                if let Some(sender) = self.senders.get_mut(\u0026target_peer) {\n                    // Recreate the event for the target peer\n                    let event = match \u0026pending_event.event {\n                        NetworkEvent::SelfRequest { request, .. } =\u003e NetworkEvent::SelfRequest {\n                            request: request.clone(),\n                            response_channel: None,\n                        },\n                        NetworkEvent::GossipsubMessage(msg) =\u003e {\n                            NetworkEvent::GossipsubMessage(libp2p::gossipsub::Message {\n                                source: msg.source,\n                                data: msg.data.clone(),\n                                sequence_number: msg.sequence_number,\n                                topic: msg.topic.clone(),\n                            })\n                        }\n                        NetworkEvent::PeersConnected(items) =\u003e {\n                            NetworkEvent::PeersConnected(items.clone())\n                        }\n                        NetworkEvent::PeersDisconnected(items) =\u003e {\n                            NetworkEvent::PeersDisconnected(items.clone())\n                        }\n                        NetworkEvent::Subscribed { peer_id, topic } =\u003e NetworkEvent::Subscribed {\n                            peer_id: *peer_id,\n                            topic: topic.clone(),\n                        },\n                        NetworkEvent::MessageEvent((peer, message)) =\u003e {\n                            NetworkEvent::MessageEvent((*peer, message.clone()))\n                        }\n                        _ =\u003e {\n                            continue;\n                        }\n                    };\n                    sender.queue(event);\n                }\n            }\n        }\n    }\n\n    // Methods to send various types of network events for testing\n    pub fn send_broadcast_to_all(\n        \u0026mut self,\n        topic: libp2p::gossipsub::IdentTopic,\n        message: Vec\u003cu8\u003e,\n    ) {\n        let gossip_message = libp2p::gossipsub::Message {\n            source: None, // Simulate external broadcast\n            data: message,\n            sequence_number: None,\n            topic: topic.hash(),\n        };\n\n        for (_, sender) in self.senders.iter_mut() {\n            sender.queue(NetworkEvent::GossipsubMessage(gossip_message.clone()));\n        }\n    }\n\n    pub fn send_private_request_to_peer(\n        \u0026mut self,\n        _from_peer: libp2p::PeerId,\n        to_peer: libp2p::PeerId,\n        request: DirectMessage,\n    ) {\n        if let Some(sender) = self.senders.get_mut(\u0026to_peer) {\n            sender.queue(NetworkEvent::GossipsubMessage(libp2p::gossipsub::Message {\n                source: Some(_from_peer),\n                data: format!(\"private_request:{:?}\", request).into_bytes(),\n                sequence_number: None,\n                topic: libp2p::gossipsub::TopicHash::from_raw(\"private_request\"),\n            }));\n        }\n    }\n\n    pub fn send_self_request_to_peer(\n        \u0026mut self,\n        peer_id: libp2p::PeerId,\n        request: node::swarm_manager::SelfRequest,\n    ) {\n        if let Some(sender) = self.senders.get_mut(\u0026peer_id) {\n            sender.queue(NetworkEvent::SelfRequest {\n                request,\n                response_channel: None,\n            });\n        }\n    }\n\n    pub fn simulate_peer_disconnect(\u0026mut self, peer_id: libp2p::PeerId) {\n        for (recipient_peer, sender) in self.senders.iter_mut() {\n            if *recipient_peer != peer_id {\n                sender.queue(NetworkEvent::PeersDisconnected(vec![(\n                    peer_id,\n                    libp2p::Multiaddr::empty(),\n                )]));\n            }\n        }\n    }\n\n    pub fn simulate_peer_reconnect(\u0026mut self, peer_id: libp2p::PeerId) {\n        for (recipient_peer, sender) in self.senders.iter_mut() {\n            if *recipient_peer != peer_id {\n                sender.queue(NetworkEvent::PeersConnected(vec![(\n                    peer_id,\n                    libp2p::Multiaddr::empty(),\n                )]));\n            }\n        }\n    }\n\n    // Helper method to get peer IDs for testing\n    pub fn get_peer_ids(\u0026self) -\u003e Vec\u003clibp2p::PeerId\u003e {\n        self.nodes.keys().cloned().collect()\n    }\n\n    pub async fn new_with_keys(peers: u32, min_signers: u16, max_signers: u16) -\u003e Self {\n        let mut cluster = Self::new(peers, min_signers, max_signers).await;\n        let identifiers: Vec\u003cIdentifier\u003e = cluster\n            .nodes\n            .keys()\n            .map(node::peer_id_to_identifier)\n            .collect();\n\n        // Run offline DKG once and distribute keys\n        let dkg_out =\n            perform_distributed_key_generation(identifiers, max_signers, min_signers).unwrap();\n\n        for (peer_id, node) in cluster.nodes.iter_mut() {\n            let id = node::peer_id_to_identifier(peer_id);\n            let key_pkg = dkg_out\n                .key_packages\n                .get(\u0026id)\n                .expect(\"missing key package\")\n                .clone();\n            node.private_key_package = Some(key_pkg);\n            node.pubkey_package = Some(dkg_out.pubkey_package.clone());\n        }\n\n        cluster\n    }\n}\n\npub fn create_node_network(\n    peer_id: libp2p::PeerId,\n    node_config: node::NodeConfig,\n    min_signers: u16,\n    max_signers: u16,\n) -\u003e Result\u003c(NodeState\u003cMockNetwork, MockDb\u003e, MockNetwork), errors::NodeError\u003e {\n    let (events_emitter_tx, _) = broadcast::channel::\u003cNetworkEvent\u003e(256);\n    let (deposit_intent_tx, _) = broadcast::channel::\u003cString\u003e(100);\n\n    let network = MockNetwork {\n        events_emitter_tx: events_emitter_tx.clone(),\n        peer: peer_id,\n        pending_events: Arc::new(Mutex::new(Vec::new())),\n    };\n\n    let mock_db = MockDb::new();\n\n    let nodes_state = NodeState::new_from_config(\n        network.clone(),\n        min_signers,\n        max_signers,\n        node_config,\n        mock_db,\n        events_emitter_tx,\n        deposit_intent_tx,\n    )?;\n\n    Ok((nodes_state, network))\n}\n\n#[cfg(test)]\nmod node_tests {\n    use super::*;\n\n    #[tokio::test]\n    async fn peers_can_connect() {\n        let mut cluster = MockNodeCluster::new(2, 2, 2).await;\n        cluster.setup().await;\n        println!(\"Ran setup\");\n        cluster.run_n_iterations(1).await;\n        println!(\"Ran 1 iterations\");\n\n        for (_, node) in cluster.nodes.iter() {\n            assert_eq!(node.peers.len(), 1);\n        }\n\n        cluster.tear_down().await;\n        println!(\"Ran teardown\");\n    }\n\n    #[tokio::test]\n    async fn network_events_are_processed_correctly() {\n        let mut cluster = MockNodeCluster::new(3, 2, 3).await;\n        cluster.setup().await;\n\n        // Get peer IDs for testing\n        let peer_ids = cluster.get_peer_ids();\n        let first_peer = peer_ids[0];\n        let second_peer = peer_ids[1];\n\n        // Manually trigger some network events by calling network methods directly\n        {\n            let first_network = cluster.networks.get(\u0026first_peer).unwrap();\n\n            // Test broadcast\n            let topic = libp2p::gossipsub::IdentTopic::new(\"test-topic\");\n            first_network\n                .send_broadcast(topic, b\"broadcast message\".to_vec())\n                .unwrap();\n\n            // Check that events are queued\n            let pending_events = first_network.pending_events.lock().unwrap();\n            assert_eq!(pending_events.len(), 1, \"Should have 2 pending events\");\n        }\n\n        // Process the events\n        cluster.process_network_events().await;\n\n        // Check that events are cleared from the network after processing\n        {\n            let first_network = cluster.networks.get(\u0026first_peer).unwrap();\n            let pending_events = first_network.pending_events.lock().unwrap();\n            assert_eq!(\n                pending_events.len(),\n                0,\n                \"Pending events should be cleared after processing\"\n            );\n        }\n\n        // Check that events were queued in the appropriate senders\n        let second_sender = cluster.senders.get(\u0026second_peer).unwrap();\n        assert!(\n            !second_sender.pending_events.is_empty(),\n            \"Second peer should have received events\"\n        );\n\n        println!(\"Network event processing works correctly!\");\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","vidyootsenthil","Documents","TheValut-nameTBD","tests","src","mocks","oracle.rs"],"content":"use std::collections::HashMap;\n\nuse bitcoin::Txid;\nuse protocol::oracle::Oracle;\nuse types::errors::NodeError;\n\npub struct MockOracle {\n    // Map of tx_hash -\u003e (address, amount, is_valid)\n    pub transactions: HashMap\u003cString, (String, u64, bool)\u003e,\n}\n\nimpl Default for MockOracle {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n\nimpl MockOracle {\n    pub fn new() -\u003e Self {\n        Self {\n            transactions: HashMap::new(),\n        }\n    }\n\n    pub fn add_transaction(\u0026mut self, tx_hash: Txid, address: String, amount: u64, is_valid: bool) {\n        self.transactions\n            .insert(tx_hash.to_string(), (address, amount, is_valid));\n    }\n}\n\n#[async_trait::async_trait]\nimpl Oracle for MockOracle {\n    async fn validate_transaction(\n        \u0026self,\n        address: \u0026str,\n        amount: u64,\n        tx_hash: Txid,\n    ) -\u003e Result\u003cbool, NodeError\u003e {\n        let tx_hash_str = tx_hash.to_string();\n\n        match self.transactions.get(\u0026tx_hash_str) {\n            Some((expected_address, expected_amount, is_valid)) =\u003e {\n                if expected_address != address {\n                    return Err(NodeError::Error(format!(\n                        \"Address mismatch: expected {}, got {}\",\n                        expected_address, address\n                    )));\n                }\n\n                if *expected_amount != amount {\n                    return Err(NodeError::Error(format!(\n                        \"Amount mismatch: expected {}, got {}\",\n                        expected_amount, amount\n                    )));\n                }\n\n                Ok(*is_valid)\n            }\n            None =\u003e Err(NodeError::Error(\"Transaction not found\".to_string())),\n        }\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","vidyootsenthil","Documents","TheValut-nameTBD","tests","src","protocol","block.rs"],"content":"#[cfg(test)]\nmod block_test {\n    use protocol::block::Block;\n\n    #[test]\n    fn test_block_creation_and_hashing() {\n        let block = Block::new([0u8; 32], [0u8; 32], 1, vec![], vec![1, 2, 3], 0);\n\n        let hash1 = block.hash();\n        let hash2 = block.hash();\n        assert_eq!(hash1, hash2); // Hash should be deterministic\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","vidyootsenthil","Documents","TheValut-nameTBD","tests","src","protocol","deposits.rs"],"content":"#[cfg(test)]\nmod deposit_test {\n    use bitcoin::{Txid, hashes::Hash};\n    use std::collections::HashMap;\n\n    use crate::mocks::oracle::MockOracle;\n    use protocol::{\n        chain_state::{Account, ChainState},\n        executor::TransactionExecutor,\n        transaction::{Operation, Transaction, TransactionType},\n    };\n\n    fn get_test_chain_state() -\u003e ChainState {\n        let accounts = HashMap::from([\n            (\n                \"1\".to_string(),\n                Account {\n                    balance: 0,\n                    address: \"1\".to_string(),\n                },\n            ),\n            (\n                \"2\".to_string(),\n                Account {\n                    balance: 100,\n                    address: \"2\".to_string(),\n                },\n            ),\n            (\n                \"3\".to_string(),\n                Account {\n                    balance: 200,\n                    address: \"3\".to_string(),\n                },\n            ),\n        ]);\n        ChainState::new_with_accounts(accounts, 0)\n    }\n\n    fn create_test_tx_hash() -\u003e Txid {\n        Txid::from_slice(\u0026[1u8; 32]).unwrap()\n    }\n\n    fn create_mock_oracle(transactions: Vec\u003c(Txid, String, u64, bool)\u003e) -\u003e MockOracle {\n        let mut mock_oracle = MockOracle::new();\n        for (tx_hash, address, amount, is_valid) in transactions {\n            mock_oracle.add_transaction(tx_hash, address, amount, is_valid);\n        }\n        mock_oracle\n    }\n\n    #[tokio::test]\n    async fn test_execute_deposit_transaction() {\n        let accounts = HashMap::from([(\n            \"1\".to_string(),\n            Account {\n                balance: 0,\n                address: \"1\".to_string(),\n            },\n        )]);\n        let chain_state = ChainState::new_with_accounts(accounts, 0);\n\n        // Setup mock oracle\n        let tx_hash = create_test_tx_hash();\n        let mock_oracle = create_mock_oracle(vec![(tx_hash, \"1\".to_string(), 100, true)]);\n\n        let transaction = Transaction::new(\n            TransactionType::Deposit,\n            vec![\n                // First, validate the transaction with oracle\n                // OpCheckOracle pops: tx_hash, address, amount\n                // So we push in reverse: amount, address, tx_hash\n                Operation::OpPush {\n                    value: 100u64.to_be_bytes().to_vec(),\n                },\n                Operation::OpPush {\n                    value: \"1\".as_bytes().to_vec(),\n                },\n                Operation::OpPush {\n                    value: tx_hash.as_byte_array().to_vec(),\n                },\n                Operation::OpCheckOracle,\n                // Then increment the balance\n                // OpIncrementBalance pops: address, amount\n                // So we push in reverse: amount, address\n                Operation::OpPush {\n                    value: 100u64.to_be_bytes().to_vec(),\n                },\n                Operation::OpPush {\n                    value: \"1\".as_bytes().to_vec(),\n                },\n                Operation::OpIncrementBalance,\n            ],\n        );\n\n        let mut executor = TransactionExecutor::new(mock_oracle);\n        let result_state = executor\n            .execute_transaction(transaction, chain_state)\n            .await\n            .unwrap();\n        assert_eq!(result_state.get_account(\"1\").unwrap().balance, 100);\n    }\n\n    #[tokio::test]\n    async fn test_execute_deposit_transaction_with_multiple_deposits() {\n        let chain_state = get_test_chain_state();\n\n        // Setup mock oracle with multiple transactions\n        let tx_hash1 = Txid::from_slice(\u0026[1u8; 32]).unwrap();\n        let tx_hash2 = Txid::from_slice(\u0026[2u8; 32]).unwrap();\n        let tx_hash3 = Txid::from_slice(\u0026[3u8; 32]).unwrap();\n        let tx_hash4 = Txid::from_slice(\u0026[4u8; 32]).unwrap();\n\n        let mock_oracle = create_mock_oracle(vec![\n            (tx_hash1, \"1\".to_string(), 100, true),\n            (tx_hash2, \"2\".to_string(), 200, true),\n            (tx_hash3, \"1\".to_string(), 100, true),\n            (tx_hash4, \"3\".to_string(), 300, true),\n        ]);\n\n        let transaction = Transaction::new(\n            TransactionType::Deposit,\n            vec![\n                // First deposit to account 1\n                Operation::OpPush {\n                    value: 100u64.to_be_bytes().to_vec(),\n                },\n                Operation::OpPush {\n                    value: \"1\".as_bytes().to_vec(),\n                },\n                Operation::OpPush {\n                    value: tx_hash1.as_byte_array().to_vec(),\n                },\n                Operation::OpCheckOracle,\n                Operation::OpPush {\n                    value: 100u64.to_be_bytes().to_vec(),\n                },\n                Operation::OpPush {\n                    value: \"1\".as_bytes().to_vec(),\n                },\n                Operation::OpIncrementBalance,\n                // Second deposit to account 2\n                Operation::OpPush {\n                    value: 200u64.to_be_bytes().to_vec(),\n                },\n                Operation::OpPush {\n                    value: \"2\".as_bytes().to_vec(),\n                },\n                Operation::OpPush {\n                    value: tx_hash2.as_byte_array().to_vec(),\n                },\n                Operation::OpCheckOracle,\n                Operation::OpPush {\n                    value: 200u64.to_be_bytes().to_vec(),\n                },\n                Operation::OpPush {\n                    value: \"2\".as_bytes().to_vec(),\n                },\n                Operation::OpIncrementBalance,\n                // Third deposit to account 1 again\n                Operation::OpPush {\n                    value: 100u64.to_be_bytes().to_vec(),\n                },\n                Operation::OpPush {\n                    value: \"1\".as_bytes().to_vec(),\n                },\n                Operation::OpPush {\n                    value: tx_hash3.as_byte_array().to_vec(),\n                },\n                Operation::OpCheckOracle,\n                Operation::OpPush {\n                    value: 100u64.to_be_bytes().to_vec(),\n                },\n                Operation::OpPush {\n                    value: \"1\".as_bytes().to_vec(),\n                },\n                Operation::OpIncrementBalance,\n                // Fourth deposit to account 3\n                Operation::OpPush {\n                    value: 300u64.to_be_bytes().to_vec(),\n                },\n                Operation::OpPush {\n                    value: \"3\".as_bytes().to_vec(),\n                },\n                Operation::OpPush {\n                    value: tx_hash4.as_byte_array().to_vec(),\n                },\n                Operation::OpCheckOracle,\n                Operation::OpPush {\n                    value: 300u64.to_be_bytes().to_vec(),\n                },\n                Operation::OpPush {\n                    value: \"3\".as_bytes().to_vec(),\n                },\n                Operation::OpIncrementBalance,\n            ],\n        );\n\n        let mut executor = TransactionExecutor::new(mock_oracle);\n        let result_state = executor\n            .execute_transaction(transaction, chain_state)\n            .await\n            .unwrap();\n        assert_eq!(result_state.get_account(\"1\").unwrap().balance, 200);\n        assert_eq!(result_state.get_account(\"2\").unwrap().balance, 300);\n        assert_eq!(result_state.get_account(\"3\").unwrap().balance, 500);\n    }\n\n    #[tokio::test]\n    async fn test_execute_deposit_transaction_with_zero_amount() {\n        let chain_state = get_test_chain_state();\n\n        let tx_hash = create_test_tx_hash();\n        let mock_oracle = create_mock_oracle(vec![(tx_hash, \"1\".to_string(), 0, true)]);\n\n        let transaction = Transaction::new(\n            TransactionType::Deposit,\n            vec![\n                Operation::OpPush {\n                    value: 0u64.to_be_bytes().to_vec(),\n                },\n                Operation::OpPush {\n                    value: \"1\".as_bytes().to_vec(),\n                },\n                Operation::OpPush {\n                    value: tx_hash.as_byte_array().to_vec(),\n                },\n                Operation::OpCheckOracle,\n                Operation::OpPush {\n                    value: 0u64.to_be_bytes().to_vec(),\n                },\n                Operation::OpPush {\n                    value: \"1\".as_bytes().to_vec(),\n                },\n                Operation::OpIncrementBalance,\n            ],\n        );\n\n        let mut executor = TransactionExecutor::new(mock_oracle);\n        let result = executor.execute_transaction(transaction, chain_state).await;\n        assert!(result.is_ok());\n        let result_state = result.unwrap();\n        assert_eq!(result_state.get_account(\"1\").unwrap().balance, 0);\n    }\n\n    #[tokio::test]\n    async fn test_execute_deposit_transaction_with_invalid_account() {\n        let chain_state = ChainState::new();\n\n        let tx_hash = create_test_tx_hash();\n        let mock_oracle = create_mock_oracle(vec![(tx_hash, \"1\".to_string(), 100, true)]);\n\n        let transaction = Transaction::new(\n            TransactionType::Deposit,\n            vec![\n                Operation::OpPush {\n                    value: 100u64.to_be_bytes().to_vec(),\n                },\n                Operation::OpPush {\n                    value: \"1\".as_bytes().to_vec(),\n                },\n                Operation::OpPush {\n                    value: tx_hash.as_byte_array().to_vec(),\n                },\n                Operation::OpCheckOracle,\n                Operation::OpPush {\n                    value: 100u64.to_be_bytes().to_vec(),\n                },\n                Operation::OpPush {\n                    value: \"1\".as_bytes().to_vec(),\n                },\n                Operation::OpIncrementBalance,\n            ],\n        );\n\n        let mut executor = TransactionExecutor::new(mock_oracle);\n        let result = executor.execute_transaction(transaction, chain_state).await;\n        // Should succeed - account will be created if it doesn't exist\n        assert!(result.is_ok());\n        assert_eq!(result.unwrap().get_account(\"1\").unwrap().balance, 100);\n    }\n\n    #[tokio::test]\n    async fn test_execute_deposit_transaction_oracle_validation_fails() {\n        let chain_state = get_test_chain_state();\n\n        let tx_hash = create_test_tx_hash();\n        // Set validation to fail\n        let mock_oracle = create_mock_oracle(vec![(tx_hash, \"1\".to_string(), 100, false)]);\n\n        let transaction = Transaction::new(\n            TransactionType::Deposit,\n            vec![\n                Operation::OpPush {\n                    value: 100u64.to_be_bytes().to_vec(),\n                },\n                Operation::OpPush {\n                    value: \"1\".as_bytes().to_vec(),\n                },\n                Operation::OpPush {\n                    value: tx_hash.as_byte_array().to_vec(),\n                },\n                Operation::OpCheckOracle,\n                Operation::OpPush {\n                    value: 100u64.to_be_bytes().to_vec(),\n                },\n                Operation::OpPush {\n                    value: \"1\".as_bytes().to_vec(),\n                },\n                Operation::OpIncrementBalance,\n            ],\n        );\n\n        let mut executor = TransactionExecutor::new(mock_oracle);\n        let result = executor.execute_transaction(transaction, chain_state).await;\n        // Should fail because allowance won't be granted\n        assert!(result.is_err());\n    }\n\n    #[tokio::test]\n    async fn test_execute_deposit_transaction_wrong_amount_in_oracle() {\n        let chain_state = get_test_chain_state();\n\n        let tx_hash = create_test_tx_hash();\n        // Oracle expects 200 but we'll try to validate 100\n        let mock_oracle = create_mock_oracle(vec![(tx_hash, \"1\".to_string(), 200, true)]);\n\n        let transaction = Transaction::new(\n            TransactionType::Deposit,\n            vec![\n                Operation::OpPush {\n                    value: 100u64.to_be_bytes().to_vec(),\n                },\n                Operation::OpPush {\n                    value: \"1\".as_bytes().to_vec(),\n                },\n                Operation::OpPush {\n                    value: tx_hash.as_byte_array().to_vec(),\n                },\n                Operation::OpCheckOracle,\n            ],\n        );\n\n        let mut executor = TransactionExecutor::new(mock_oracle);\n        let result = executor.execute_transaction(transaction, chain_state).await;\n        assert!(result.is_err());\n    }\n\n    #[tokio::test]\n    async fn test_execute_deposit_transaction_without_oracle_check() {\n        let chain_state = get_test_chain_state();\n\n        // Empty oracle since we're not checking any transactions\n        let mock_oracle = create_mock_oracle(vec![]);\n\n        // Try to increment balance without checking oracle first\n        let transaction = Transaction::new(\n            TransactionType::Deposit,\n            vec![\n                Operation::OpPush {\n                    value: 100u64.to_be_bytes().to_vec(),\n                },\n                Operation::OpPush {\n                    value: \"1\".as_bytes().to_vec(),\n                },\n                Operation::OpIncrementBalance,\n            ],\n        );\n\n        let mut executor = TransactionExecutor::new(mock_oracle);\n        let result = executor.execute_transaction(transaction, chain_state).await;\n        // Should fail due to insufficient allowance\n        assert!(result.is_err());\n    }\n\n    #[tokio::test]\n    async fn test_partial_allowance_spending() {\n        let chain_state = get_test_chain_state();\n\n        let tx_hash = create_test_tx_hash();\n        // Oracle validates 100\n        let mock_oracle = create_mock_oracle(vec![(tx_hash, \"1\".to_string(), 100, true)]);\n\n        let transaction = Transaction::new(\n            TransactionType::Deposit,\n            vec![\n                // Validate 100\n                Operation::OpPush {\n                    value: 100u64.to_be_bytes().to_vec(),\n                },\n                Operation::OpPush {\n                    value: \"1\".as_bytes().to_vec(),\n                },\n                Operation::OpPush {\n                    value: tx_hash.as_byte_array().to_vec(),\n                },\n                Operation::OpCheckOracle,\n                // Try to spend 50\n                Operation::OpPush {\n                    value: 50u64.to_be_bytes().to_vec(),\n                },\n                Operation::OpPush {\n                    value: \"1\".as_bytes().to_vec(),\n                },\n                Operation::OpIncrementBalance,\n                // Try to spend another 60 (should fail)\n                Operation::OpPush {\n                    value: 60u64.to_be_bytes().to_vec(),\n                },\n                Operation::OpPush {\n                    value: \"1\".as_bytes().to_vec(),\n                },\n                Operation::OpIncrementBalance,\n            ],\n        );\n\n        let mut executor = TransactionExecutor::new(mock_oracle);\n        let result = executor.execute_transaction(transaction, chain_state).await;\n        // Should fail on the second increment\n        assert!(result.is_err());\n    }\n\n    #[tokio::test]\n    async fn test_multiple_oracle_validations_same_account() {\n        let chain_state = get_test_chain_state();\n\n        let tx_hash1 = Txid::from_slice(\u0026[1u8; 32]).unwrap();\n        let tx_hash2 = Txid::from_slice(\u0026[2u8; 32]).unwrap();\n\n        let mock_oracle = create_mock_oracle(vec![\n            (tx_hash1, \"1\".to_string(), 100, true),\n            (tx_hash2, \"1\".to_string(), 50, true),\n        ]);\n\n        let transaction = Transaction::new(\n            TransactionType::Deposit,\n            vec![\n                // First validation\n                Operation::OpPush {\n                    value: 100u64.to_be_bytes().to_vec(),\n                },\n                Operation::OpPush {\n                    value: \"1\".as_bytes().to_vec(),\n                },\n                Operation::OpPush {\n                    value: tx_hash1.as_byte_array().to_vec(),\n                },\n                Operation::OpCheckOracle,\n                // Second validation\n                Operation::OpPush {\n                    value: 50u64.to_be_bytes().to_vec(),\n                },\n                Operation::OpPush {\n                    value: \"1\".as_bytes().to_vec(),\n                },\n                Operation::OpPush {\n                    value: tx_hash2.as_byte_array().to_vec(),\n                },\n                Operation::OpCheckOracle,\n                // Now we should have 150 allowance, spend it all\n                Operation::OpPush {\n                    value: 150u64.to_be_bytes().to_vec(),\n                },\n                Operation::OpPush {\n                    value: \"1\".as_bytes().to_vec(),\n                },\n                Operation::OpIncrementBalance,\n            ],\n        );\n\n        let mut executor = TransactionExecutor::new(mock_oracle);\n        let result_state = executor\n            .execute_transaction(transaction, chain_state)\n            .await\n            .unwrap();\n        assert_eq!(result_state.get_account(\"1\").unwrap().balance, 150);\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","vidyootsenthil","Documents","TheValut-nameTBD","tests","src","protocol","mod.rs"],"content":"pub mod block;\npub mod deposits;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","vidyootsenthil","Documents","TheValut-nameTBD","tests","src","signing","mod.rs"],"content":"#[cfg(test)]\npub mod signing_tests {\n    use crate::mocks::network::MockNodeCluster;\n    use node::swarm_manager::{DirectMessage, NetworkEvent, SelfRequest};\n    use rand::RngCore;\n\n    #[tokio::test]\n    async fn signing_flow_completes_and_produces_shares() {\n        let peers = 3;\n        let min_signers = 2;\n        let max_signers = 3;\n\n        // Build cluster with pre-generated FROST keys – no DKG needed\n        let mut cluster = MockNodeCluster::new_with_keys(peers, min_signers, max_signers).await;\n        cluster.setup().await;\n\n        // ── start signing ──\n        let initiator = *cluster.nodes.keys().next().unwrap();\n        let mut msg = [0u8; 32];\n        rand::rng().fill_bytes(\u0026mut msg);\n        let hex_msg = hex::encode(msg);\n\n        cluster.send_self_request_to_peer(\n            initiator,\n            SelfRequest::StartSigningSession {\n                hex_message: hex_msg,\n            },\n        );\n\n        // ── drive the network and count messages ──\n        let (mut req, mut comm, mut pack, mut share) = (0, 0, 0, 0);\n        for _ in 0..100 {\n            cluster.run_n_iterations(1).await;\n\n            // count DirectMessage traffic still queued in the mock senders\n            for sender in cluster.senders.values() {\n                for ev in \u0026sender.pending_events {\n                    if let NetworkEvent::MessageEvent((_, dm)) = ev {\n                        match dm {\n                            DirectMessage::SignRequest { .. } =\u003e req += 1,\n                            DirectMessage::Commitments { .. } =\u003e comm += 1,\n                            DirectMessage::SignPackage { .. } =\u003e pack += 1,\n                            DirectMessage::SignatureShare { .. } =\u003e share += 1,\n                            _ =\u003e {}\n                        }\n                    }\n                }\n            }\n            // // break once no messages are left in either channel\n            if cluster\n                .senders\n                .values()\n                .all(|s| s.pending_events.is_empty())\n                \u0026\u0026 cluster\n                    .networks\n                    .values()\n                    .all(|n| n.pending_events.lock().unwrap().is_empty())\n            {\n                break;\n            }\n        }\n\n        // ── explicit assertions ──\n        assert!(req \u003e= min_signers as usize - 1, \"missing SignRequest(s)\");\n        assert!(comm \u003e= min_signers as usize - 1, \"missing Commitments\");\n        assert!(pack \u003e= min_signers as usize - 1, \"missing SignPackage\");\n        assert!(share \u003e= min_signers as usize - 1, \"missing SignatureShare\");\n\n        // protocol should be finished – no pending spends\n        for node in cluster.nodes.values() {\n            let signing_state = node\n                .handlers\n                .iter()\n                .find_map(|h| h.downcast_ref::\u003cnode::signing::SigningState\u003e());\n            assert!(\n                signing_state.unwrap().active_signing.is_none(),\n                \"node still has pending signing {:?}\",\n                node.peer_id\n            );\n        }\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","vidyootsenthil","Documents","TheValut-nameTBD","tests","src","util","local_dkg.rs"],"content":"use frost_secp256k1 as frost;\nuse frost_secp256k1::keys::{KeyPackage, PublicKeyPackage};\nuse std::collections::BTreeMap;\n\n/// Result of DKG process containing key packages for all participants\n#[derive(Debug, Clone)]\npub struct DkgResult {\n    /// Key packages for each participant (contains their secret shares)\n    pub key_packages: BTreeMap\u003cfrost::Identifier, KeyPackage\u003e,\n    /// Public key package (same for all participants)\n    pub pubkey_package: PublicKeyPackage,\n}\n\n/// Error types for DKG operations\n#[derive(Debug)]\npub enum DkgError {\n    FrostError(frost::Error),\n    InvalidParticipant(String),\n    CommunicationError(String),\n}\n\nimpl std::fmt::Display for DkgError {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        match self {\n            DkgError::FrostError(e) =\u003e write!(f, \"FROST error: {}\", e),\n            DkgError::InvalidParticipant(msg) =\u003e write!(f, \"Invalid participant: {}\", msg),\n            DkgError::CommunicationError(msg) =\u003e write!(f, \"Communication error: {}\", msg),\n        }\n    }\n}\n\nimpl std::error::Error for DkgError {}\n\nimpl From\u003cfrost::Error\u003e for DkgError {\n    fn from(e: frost::Error) -\u003e Self {\n        DkgError::FrostError(e)\n    }\n}\n\n/// Perform a full dealer-less DKG entirely in-memory.\npub fn perform_distributed_key_generation(\n    peers: Vec\u003cfrost::Identifier\u003e,\n    max_signers: u16,\n    min_signers: u16,\n) -\u003e Result\u003cDkgResult, DkgError\u003e {\n    use frost::keys::dkg::{round1, round2};\n\n    if min_signers == 0 || max_signers == 0 || min_signers \u003e max_signers {\n        return Err(DkgError::InvalidParticipant(\n            \"Invalid signer parameters\".to_string(),\n        ));\n    }\n    let rng = frost::rand_core::OsRng;\n\n    // Round1 secret/package maps\n    let mut r1_secret: BTreeMap\u003c_, round1::SecretPackage\u003e = BTreeMap::new();\n    let mut r1_pkg_sent: BTreeMap\u003c_, BTreeMap\u003c_, round1::Package\u003e\u003e = BTreeMap::new();\n\n    for id in peers.clone() {\n        let (sec, pkg) = frost::keys::dkg::part1(id, max_signers, min_signers, rng)?;\n        r1_secret.insert(id, sec);\n        // broadcast pkg to others\n        for recv_id in peers.clone() {\n            if recv_id == id {\n                continue;\n            }\n            r1_pkg_sent\n                .entry(recv_id)\n                .or_default()\n                .insert(id, pkg.clone());\n        }\n    }\n\n    // Round2\n    let mut r2_secret: BTreeMap\u003c_, round2::SecretPackage\u003e = BTreeMap::new();\n    let mut r2_pkg_sent: BTreeMap\u003c_, BTreeMap\u003c_, round2::Package\u003e\u003e = BTreeMap::new();\n\n    for id in peers.clone() {\n        let sec1 = r1_secret.get(\u0026id).unwrap().clone();\n        let r1_recv = r1_pkg_sent.get(\u0026id).unwrap();\n        let (sec2, pkgs2) = frost::keys::dkg::part2(sec1, r1_recv)?;\n        r2_secret.insert(id, sec2);\n        for (recv_id, pkg) in pkgs2 {\n            r2_pkg_sent.entry(recv_id).or_default().insert(id, pkg);\n        }\n    }\n\n    // Round3, build key packages\n    let mut key_pkgs = BTreeMap::new();\n    let mut group_pub: Option\u003cPublicKeyPackage\u003e = None;\n\n    for id in peers {\n        let sec2 = r2_secret.get(\u0026id).unwrap();\n        let r1_recv = r1_pkg_sent.get(\u0026id).unwrap();\n        let r2_recv = r2_pkg_sent.get(\u0026id).unwrap();\n        let (key_pkg, pub_pkg) = frost::keys::dkg::part3(sec2, r1_recv, r2_recv)?;\n        if group_pub.is_none() {\n            group_pub = Some(pub_pkg.clone());\n        }\n        key_pkgs.insert(id, key_pkg);\n    }\n\n    Ok(DkgResult {\n        key_packages: key_pkgs,\n        pubkey_package: group_pub.expect(\"pubkey package\"),\n    })\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","vidyootsenthil","Documents","TheValut-nameTBD","tests","src","util","mod.rs"],"content":"pub mod local_dkg;\n","traces":[],"covered":0,"coverable":0}]};
        var previousData = {"files":[{"path":["/","home","vidyootsenthil","Documents","TheValut-nameTBD","bin","cli","src","errors.rs"],"content":"use derive_more::Display;\n\n#[derive(Debug, Display)]\npub enum KeygenError {\n    #[display(\"Password mismatch\")]\n    PasswordMismatch,\n\n    #[display(\"Failed to create directory.\")]\n    DirectoryCreation(String),\n\n    #[display(\"Io error: {}\", _0)]\n    Io(std::io::Error),\n\n    #[display(\"Failed to encode key.\")]\n    KeyEncoding(String),\n\n    #[display(\"Failed to encrypt key.\")]\n    Encryption(String),\n\n    #[display(\"Failed to create directory.\")]\n    KeyFileNotFound(String),\n}\n\n#[derive(Debug)]\n#[allow(dead_code, clippy::enum_variant_names, clippy::large_enum_variant)]\npub enum CliError {\n    KeygenError(KeygenError),\n    RpcError(tonic::Status),\n    NodeError(String),\n}\n\nimpl From\u003cKeygenError\u003e for CliError {\n    fn from(error: KeygenError) -\u003e Self {\n        CliError::KeygenError(error)\n    }\n}\n","traces":[{"line":33,"address":[5867216],"length":1,"stats":{"Line":0}},{"line":34,"address":[5867219],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":2},{"path":["/","home","vidyootsenthil","Documents","TheValut-nameTBD","bin","cli","src","main.rs"],"content":"mod errors;\nmod rpc_client;\n\nuse aes_gcm::{\n    aead::{Aead, KeyInit},\n    Aes256Gcm, Key, Nonce,\n};\nuse argon2::{\n    password_hash::{\n        rand_core::{OsRng, RngCore},\n        SaltString,\n    },\n    Argon2,\n};\nuse base64::{engine::general_purpose::STANDARD as BASE64, Engine as _};\nuse clap::{Parser, Subcommand};\nuse directories::ProjectDirs;\nuse libp2p::identity::Keypair;\nuse rpc_client::{rpc_create_deposit_intent, rpc_spend, rpc_start_signing};\nuse std::{fs, path::PathBuf};\n\nuse crate::{\n    errors::{CliError, KeygenError},\n    rpc_client::rpc_get_pending_deposit_intents,\n};\nuse node::{\n    key_manager::get_config, start_node::start_node, EncryptionParams, KeyData, NodeConfig,\n};\nuse types::errors::NodeError;\n\nstruct VaultConfigPath {\n    key_file_path: PathBuf,\n    config_file_path: PathBuf,\n}\n\nfn get_key_file_path() -\u003e Result\u003cVaultConfigPath, KeygenError\u003e {\n    let proj_dirs = ProjectDirs::from(\"\", \"\", \"TheVault\").ok_or_else(|| {\n        KeygenError::DirectoryCreation(\"Failed to determine project directory\".into())\n    })?;\n\n    let config_dir = proj_dirs.config_dir();\n    fs::create_dir_all(config_dir).map_err(|e| KeygenError::DirectoryCreation(e.to_string()))?;\n\n    Ok(VaultConfigPath {\n        key_file_path: config_dir.join(\"config.json\"),\n        config_file_path: config_dir.join(\"config.yaml\"),\n    })\n}\n\nfn get_log_file_path() -\u003e Result\u003cPathBuf, KeygenError\u003e {\n    let proj_dirs = ProjectDirs::from(\"\", \"\", \"TheVault\").ok_or_else(|| {\n        KeygenError::DirectoryCreation(\"Failed to determine project directory\".into())\n    })?;\n\n    let log_dir = proj_dirs.config_dir();\n    let path = log_dir.join(\"node.log\");\n    Ok(path)\n}\n\nfn generate_key(password: \u0026str, salt: \u0026SaltString) -\u003e Result\u003cVec\u003cu8\u003e, KeygenError\u003e {\n    let argon2 = Argon2::default();\n    let password_bytes = password.as_bytes();\n    let mut key = vec![0u8; 32];\n\n    argon2\n        .hash_password_into(password_bytes, salt.as_str().as_bytes(), \u0026mut key)\n        .map_err(|e| KeygenError::Encryption(e.to_string()))?;\n    Ok(key)\n}\n\nfn encrypt_private_key(\n    keypair: \u0026Keypair,\n    password: \u0026str,\n) -\u003e Result\u003c(String, EncryptionParams), KeygenError\u003e {\n    let salt = SaltString::generate(\u0026mut OsRng);\n    let key = generate_key(password, \u0026salt)?;\n\n    let mut nonce_bytes = [0u8; 12];\n    OsRng.fill_bytes(\u0026mut nonce_bytes);\n    let nonce = Nonce::from_slice(\u0026nonce_bytes);\n\n    let private_key_bytes = keypair\n        .to_protobuf_encoding()\n        .map_err(|e| KeygenError::KeyEncoding(e.to_string()))?;\n\n    let cipher = Aes256Gcm::new(Key::\u003cAes256Gcm\u003e::from_slice(\u0026key));\n\n    let ciphertext = cipher\n        .encrypt(nonce, private_key_bytes.as_ref())\n        .map_err(|e| KeygenError::Encryption(e.to_string()))?;\n\n    let params = EncryptionParams {\n        kdf: \"argon2id\".to_string(),\n        salt_b64: salt.to_string(),\n        iv_b64: BASE64.encode(nonce_bytes),\n    };\n\n    Ok((BASE64.encode(ciphertext), params))\n}\n\nfn get_password() -\u003e Result\u003cString, KeygenError\u003e {\n    let password = rpassword::prompt_password(\"Enter password: \").map_err(KeygenError::Io)?;\n\n    let confirm = rpassword::prompt_password(\"Confirm password: \").map_err(KeygenError::Io)?;\n\n    if password != confirm {\n        return Err(KeygenError::PasswordMismatch);\n    }\n\n    Ok(password)\n}\n\n#[derive(Parser)]\n#[command(name = \"keygen\")]\n#[command(about = \"Generate public and private key pairs for the Vault.\")]\n#[command(version = \"0.0.1\")]\nstruct Cli {\n    #[command(subcommand)]\n    command: Commands,\n}\n\n#[derive(Subcommand)]\nenum Commands {\n    /// Generate a new keypair and save it to a file set by the --output flag\n    Setup {\n        #[arg(short, long)]\n        output_dir: Option\u003cString\u003e,\n        #[arg(short, long)]\n        file_name: Option\u003cString\u003e,\n    },\n    /// Run the node and connect to the network\n    Run {\n        #[arg(short, long)]\n        key_file_path: Option\u003cString\u003e,\n        #[arg(short, long)]\n        config_file_path: Option\u003cString\u003e,\n        #[arg(short, long)]\n        grpc_port: Option\u003cu16\u003e,\n        #[arg(short, long)]\n        log_file: Option\u003cString\u003e,\n        #[arg(short = 'n', long)]\n        max_signers: Option\u003cu16\u003e,\n        #[arg(short = 't', long)]\n        min_signers: Option\u003cu16\u003e,\n    },\n    Spend {\n        amount: u64,\n        address_to: String,\n        #[arg(short, long)]\n        endpoint: Option\u003cString\u003e,\n    },\n    StartSigning {\n        hex_message: String,\n        #[arg(short, long)]\n        endpoint: Option\u003cString\u003e,\n    },\n    Deposit {\n        amount: u64,\n        #[arg(short, long)]\n        endpoint: Option\u003cString\u003e,\n    },\n    GetPendingDepositIntents {\n        #[arg(short, long)]\n        endpoint: Option\u003cString\u003e,\n    },\n}\n\n#[tokio::main]\n#[allow(clippy::result_large_err)]\nasync fn main() -\u003e Result\u003c(), CliError\u003e {\n    let cli = Cli::parse();\n\n    match cli.command {\n        Commands::Setup {\n            output_dir,\n            file_name,\n        } =\u003e {\n            setup_config(output_dir, file_name).map_err(|e| {\n                println!(\"Keygen Error: {}\", e);\n                CliError::KeygenError(e)\n            })?;\n        }\n        Commands::Run {\n            key_file_path,\n            config_file_path,\n            grpc_port,\n            log_file,\n            max_signers,\n            min_signers,\n        } =\u003e {\n            start_node_cli(\n                key_file_path,\n                config_file_path,\n                grpc_port,\n                log_file,\n                max_signers,\n                min_signers,\n            )\n            .await\n            .map_err(|e| CliError::NodeError(e.to_string()))?;\n        }\n        Commands::Spend {\n            amount,\n            endpoint,\n            address_to,\n        } =\u003e {\n            rpc_spend(endpoint, amount, address_to)\n                .await\n                .map_err(CliError::RpcError)?;\n        }\n        Commands::StartSigning {\n            hex_message,\n            endpoint,\n        } =\u003e {\n            rpc_start_signing(endpoint, hex_message)\n                .await\n                .map_err(CliError::RpcError)?;\n        }\n        Commands::Deposit { amount, endpoint } =\u003e {\n            let response = rpc_create_deposit_intent(endpoint, amount)\n                .await\n                .map_err(CliError::RpcError)?;\n\n            println!(\"Deposit intent created: {:?}\", response);\n        }\n        Commands::GetPendingDepositIntents { endpoint } =\u003e {\n            rpc_get_pending_deposit_intents(endpoint)\n                .await\n                .map_err(CliError::RpcError)?;\n        }\n    }\n\n    Ok(())\n}\n\nfn setup_config(output_dir: Option\u003cString\u003e, file_name: Option\u003cString\u003e) -\u003e Result\u003c(), KeygenError\u003e {\n    let keypair = Keypair::generate_ed25519();\n    let public_key_b58 = keypair.public().to_peer_id().to_base58();\n\n    let user_password = get_password()?;\n\n    let (encrypted_private_key, encryption_params) = encrypt_private_key(\u0026keypair, \u0026user_password)?;\n\n    let key_data = KeyData {\n        public_key_b58: public_key_b58.clone(),\n        encrypted_private_key_b64: encrypted_private_key,\n        encryption_params,\n    };\n\n    let paths = if let Some(output) = output_dir {\n        let path = PathBuf::from(output);\n        if path.is_dir() {\n            VaultConfigPath {\n                key_file_path: path.join(format!(\n                    \"{}.json\",\n                    file_name.clone().unwrap_or(\"key\".to_string())\n                )),\n                config_file_path: path.join(format!(\n                    \"{}.yaml\",\n                    file_name.clone().unwrap_or(\"config\".to_string())\n                )),\n            }\n        } else {\n            return Err(KeygenError::KeyFileNotFound(\n                \"Output path is a file, not a directory. Please provide a directory path.\"\n                    .to_string(),\n            ));\n        }\n    } else {\n        get_key_file_path()?\n    };\n\n    let mut config = NodeConfig::new(\n        paths.key_file_path.clone(),\n        paths.config_file_path.clone(),\n        get_log_file_path().ok(),\n        \u0026user_password,\n    )\n    .map_err(|e| KeygenError::KeyFileNotFound(e.to_string()))?;\n\n    config.set_key_data(key_data);\n\n    config\n        .save_to_file()\n        .map_err(|e| KeygenError::KeyFileNotFound(e.to_string()))?;\n\n    println!(\n        \"Key data has been saved to {} with the peer id {}. To modify the allowed peers and other configurations, edit the config file here: {}\",\n        paths.key_file_path.display(),\n        public_key_b58,\n        paths.config_file_path.display()\n    );\n\n    Ok(())\n}\n\nasync fn start_node_cli(\n    key_file_path: Option\u003cString\u003e,\n    config_file_path: Option\u003cString\u003e,\n    grpc_port: Option\u003cu16\u003e,\n    log_file: Option\u003cString\u003e,\n    max_signers: Option\u003cu16\u003e,\n    min_signers: Option\u003cu16\u003e,\n) -\u003e Result\u003c(), NodeError\u003e {\n    let config = match get_config(key_file_path.clone(), config_file_path.clone()) {\n        Ok(config) =\u003e config,\n        Err(e) =\u003e {\n            return Err(NodeError::Error(format!(\"Failed to get config: {}\", e)));\n        }\n    };\n\n    start_node(\n        max_signers,\n        min_signers,\n        config,\n        grpc_port,\n        log_file.map(PathBuf::from),\n    )\n    .await?;\n    Ok(())\n}\n\n#[cfg(test)]\nmod tests;\n","traces":[{"line":36,"address":[5680567,5680548,5679712],"length":1,"stats":{"Line":0}},{"line":37,"address":[5897760],"length":1,"stats":{"Line":0}},{"line":38,"address":[5897774],"length":1,"stats":{"Line":0}},{"line":41,"address":[5680096,5680024],"length":1,"stats":{"Line":0}},{"line":42,"address":[5680128],"length":1,"stats":{"Line":0}},{"line":44,"address":[5680410],"length":1,"stats":{"Line":0}},{"line":45,"address":[5680287],"length":1,"stats":{"Line":0}},{"line":46,"address":[5680329],"length":1,"stats":{"Line":0}},{"line":50,"address":[5681102,5680592,5681096],"length":1,"stats":{"Line":0}},{"line":51,"address":[5680609,5680802],"length":1,"stats":{"Line":0}},{"line":52,"address":[5898030],"length":1,"stats":{"Line":0}},{"line":55,"address":[5680904,5680976],"length":1,"stats":{"Line":0}},{"line":56,"address":[5680992],"length":1,"stats":{"Line":0}},{"line":57,"address":[5681029],"length":1,"stats":{"Line":0}},{"line":60,"address":[5681120,5681739,5681745],"length":1,"stats":{"Line":4}},{"line":61,"address":[5681176],"length":1,"stats":{"Line":4}},{"line":62,"address":[5681203],"length":1,"stats":{"Line":4}},{"line":63,"address":[5681240],"length":1,"stats":{"Line":4}},{"line":65,"address":[5681453,5681592],"length":1,"stats":{"Line":4}},{"line":66,"address":[5681357,5681276],"length":1,"stats":{"Line":8}},{"line":67,"address":[5898132,5898112],"length":1,"stats":{"Line":0}},{"line":68,"address":[5681619],"length":1,"stats":{"Line":3}},{"line":71,"address":[5681760,5683776,5683684],"length":1,"stats":{"Line":4}},{"line":75,"address":[5681816],"length":1,"stats":{"Line":2}},{"line":76,"address":[5681853],"length":1,"stats":{"Line":3}},{"line":78,"address":[5682078],"length":1,"stats":{"Line":1}},{"line":79,"address":[5682101],"length":1,"stats":{"Line":1}},{"line":80,"address":[5682177],"length":1,"stats":{"Line":2}},{"line":82,"address":[5682224,5682354,5683774],"length":1,"stats":{"Line":2}},{"line":84,"address":[5682322],"length":1,"stats":{"Line":0}},{"line":86,"address":[5682443,5682526],"length":1,"stats":{"Line":4}},{"line":88,"address":[5682652,5682790],"length":1,"stats":{"Line":2}},{"line":89,"address":[5682566],"length":1,"stats":{"Line":2}},{"line":90,"address":[5898365,5898352],"length":1,"stats":{"Line":0}},{"line":93,"address":[5682887],"length":1,"stats":{"Line":2}},{"line":94,"address":[5682959],"length":1,"stats":{"Line":2}},{"line":95,"address":[5683024],"length":1,"stats":{"Line":2}},{"line":98,"address":[5683225,5683348],"length":1,"stats":{"Line":4}},{"line":101,"address":[5684573,5683792,5684591],"length":1,"stats":{"Line":0}},{"line":102,"address":[5683809],"length":1,"stats":{"Line":0}},{"line":104,"address":[5684125,5684579,5684037],"length":1,"stats":{"Line":0}},{"line":106,"address":[5684385,5684309],"length":1,"stats":{"Line":0}},{"line":107,"address":[5684485],"length":1,"stats":{"Line":0}},{"line":110,"address":[5684396],"length":1,"stats":{"Line":0}},{"line":170,"address":[5733475,5733481,5733008],"length":1,"stats":{"Line":0}},{"line":171,"address":[5901483],"length":1,"stats":{"Line":0}},{"line":173,"address":[5733169,5733350,5733239,5733109],"length":1,"stats":{"Line":0}},{"line":174,"address":[5901779],"length":1,"stats":{"Line":0}},{"line":178,"address":[5901835,5902580,5905472,5902482,5902618,5905710],"length":1,"stats":{"Line":0}},{"line":179,"address":[5905543,5905499],"length":1,"stats":{"Line":0}},{"line":180,"address":[5905612],"length":1,"stats":{"Line":0}},{"line":183,"address":[5902036,5902027,5902016],"length":1,"stats":{"Line":0}},{"line":199,"address":[5933105],"length":1,"stats":{"Line":0}},{"line":200,"address":[5905767,5903410,5905744],"length":1,"stats":{"Line":0}},{"line":202,"address":[5902114],"length":1,"stats":{"Line":0}},{"line":207,"address":[5903761,5902222,5902777,5903663,5903936,5903626],"length":1,"stats":{"Line":0}},{"line":208,"address":[5902770,5903455,5903628,5901552,5902807],"length":1,"stats":{"Line":0}},{"line":209,"address":[5933358,5933386],"length":1,"stats":{"Line":0}},{"line":211,"address":[5902264],"length":1,"stats":{"Line":0}},{"line":215,"address":[5904149,5904387,5902320,5904247,5904112,5902857],"length":1,"stats":{"Line":0}},{"line":216,"address":[5904114,5902887,5902850,5901573,5903941],"length":1,"stats":{"Line":0}},{"line":217,"address":[5904365,5904240],"length":1,"stats":{"Line":0}},{"line":219,"address":[5902330],"length":1,"stats":{"Line":0}},{"line":220,"address":[5904600,5902937,5904563,5904698,5905041,5902398],"length":1,"stats":{"Line":0}},{"line":221,"address":[5904565,5902930,5902967,5904392,5901594],"length":1,"stats":{"Line":0}},{"line":222,"address":[5904691],"length":1,"stats":{"Line":0}},{"line":224,"address":[5904950,5904899],"length":1,"stats":{"Line":0}},{"line":226,"address":[5902408],"length":1,"stats":{"Line":0}},{"line":227,"address":[5905460,5903017,5902456,5905352,5905217,5905254],"length":1,"stats":{"Line":0}},{"line":228,"address":[5903047,5905046,5901615,5903010,5905219],"length":1,"stats":{"Line":0}},{"line":229,"address":[5905438,5905345],"length":1,"stats":{"Line":0}},{"line":233,"address":[5733193,5733372],"length":1,"stats":{"Line":0}},{"line":236,"address":[5684624,5689780,5687554],"length":1,"stats":{"Line":0}},{"line":237,"address":[5684678],"length":1,"stats":{"Line":0}},{"line":238,"address":[5684821,5684889],"length":1,"stats":{"Line":0}},{"line":240,"address":[5685018,5689653,5684951],"length":1,"stats":{"Line":0}},{"line":242,"address":[5689632,5685190,5685289],"length":1,"stats":{"Line":0}},{"line":245,"address":[5685645],"length":1,"stats":{"Line":0}},{"line":250,"address":[5685945,5687781],"length":1,"stats":{"Line":0}},{"line":251,"address":[5686032],"length":1,"stats":{"Line":0}},{"line":252,"address":[5686106,5686186],"length":1,"stats":{"Line":0}},{"line":254,"address":[5686582,5686256],"length":1,"stats":{"Line":0}},{"line":258,"address":[5686895,5687146],"length":1,"stats":{"Line":0}},{"line":264,"address":[5686287],"length":1,"stats":{"Line":0}},{"line":265,"address":[5686217],"length":1,"stats":{"Line":0}},{"line":270,"address":[5687620,5689485,5686047],"length":1,"stats":{"Line":0}},{"line":274,"address":[5687826,5687544],"length":1,"stats":{"Line":0}},{"line":275,"address":[5687834,5687895],"length":1,"stats":{"Line":0}},{"line":276,"address":[5687972,5687911],"length":1,"stats":{"Line":0}},{"line":277,"address":[5687995],"length":1,"stats":{"Line":0}},{"line":279,"address":[5688242],"length":1,"stats":{"Line":0}},{"line":281,"address":[5688379],"length":1,"stats":{"Line":0}},{"line":283,"address":[5688719,5688578],"length":1,"stats":{"Line":0}},{"line":285,"address":[5688687],"length":1,"stats":{"Line":0}},{"line":287,"address":[5688752],"length":1,"stats":{"Line":0}},{"line":294,"address":[5689088],"length":1,"stats":{"Line":0}},{"line":297,"address":[5689824],"length":1,"stats":{"Line":0}},{"line":305,"address":[5900283,5899193,5899264,5899125],"length":1,"stats":{"Line":0}},{"line":306,"address":[5899495],"length":1,"stats":{"Line":0}},{"line":307,"address":[5899390],"length":1,"stats":{"Line":0}},{"line":308,"address":[5899422,5900008],"length":1,"stats":{"Line":0}},{"line":315,"address":[5899554],"length":1,"stats":{"Line":0}},{"line":317,"address":[5899584],"length":1,"stats":{"Line":0}},{"line":319,"address":[5899826,5900331,5900516,5899180,5899905,5900596],"length":1,"stats":{"Line":0}},{"line":320,"address":[5900675],"length":1,"stats":{"Line":0}}],"covered":21,"coverable":105},{"path":["/","home","vidyootsenthil","Documents","TheValut-nameTBD","bin","cli","src","rpc_client.rs"],"content":"use node::grpc::grpc_handler::node_proto::{\n    self, node_control_client::NodeControlClient, CreateDepositIntentResponse,\n    GetPendingDepositIntentsResponse, SpendFundsResponse, StartSigningResponse,\n};\nuse tonic::Status;\n\npub async fn rpc_spend(\n    endpoint: Option\u003cString\u003e,\n    amount: u64,\n    address_to: String,\n) -\u003e Result\u003cSpendFundsResponse, Status\u003e {\n    println!(\"Spending {} satoshis\", amount);\n\n    let mut client =\n        NodeControlClient::connect(endpoint.unwrap_or(\"http://[::1]:50051\".to_string()))\n            .await\n            .expect(\"Failed to connect\");\n\n    let spendfunds_response = client\n        .spend_funds(tonic::Request::new(node_proto::SpendFundsRequest {\n            amount_satoshis: amount,\n            address_to,\n        }))\n        .await?;\n\n    println!(\"Spent {:?} satoshis\", spendfunds_response);\n\n    Ok(spendfunds_response.into_inner())\n}\n\npub async fn rpc_start_signing(\n    endpoint: Option\u003cString\u003e,\n    hex_message: String,\n) -\u003e Result\u003cStartSigningResponse, Status\u003e {\n    println!(\"Starting signing session for message: {}\", hex_message);\n\n    let mut client =\n        NodeControlClient::connect(endpoint.unwrap_or(\"http://[::1]:50051\".to_string()))\n            .await\n            .expect(\"Failed to connect\");\n\n    let start_signing_response = client\n        .start_signing(tonic::Request::new(node_proto::StartSigningRequest {\n            hex_message,\n        }))\n        .await?;\n\n    Ok(start_signing_response.into_inner())\n}\n\npub async fn rpc_create_deposit_intent(\n    endpoint: Option\u003cString\u003e,\n    amount: u64,\n) -\u003e Result\u003cCreateDepositIntentResponse, Status\u003e {\n    println!(\"Creating deposit intent: {}\", amount);\n\n    let mut client =\n        NodeControlClient::connect(endpoint.unwrap_or(\"http://[::1]:50051\".to_string()))\n            .await\n            .expect(\"Failed to connect\");\n\n    let create_deposit_intent_response = client\n        .create_deposit_intent(tonic::Request::new(\n            node_proto::CreateDepositIntentRequest {\n                amount_satoshis: amount,\n            },\n        ))\n        .await?;\n\n    Ok(create_deposit_intent_response.into_inner())\n}\n\npub async fn rpc_get_pending_deposit_intents(\n    endpoint: Option\u003cString\u003e,\n) -\u003e Result\u003cGetPendingDepositIntentsResponse, Status\u003e {\n    let mut client =\n        NodeControlClient::connect(endpoint.unwrap_or(\"http://[::1]:50051\".to_string()))\n            .await\n            .expect(\"Failed to connect\");\n\n    let get_pending_deposit_intents_response = client\n        .get_pending_deposit_intents(tonic::Request::new(\n            node_proto::GetPendingDepositIntentsRequest {},\n        ))\n        .await?;\n\n    Ok(get_pending_deposit_intents_response.into_inner())\n}\n","traces":[{"line":7,"address":[6061120],"length":1,"stats":{"Line":0}},{"line":12,"address":[6079610,6079479],"length":1,"stats":{"Line":0}},{"line":14,"address":[6079679,6079897,6079759,6080180,6079951,6080201],"length":1,"stats":{"Line":0}},{"line":16,"address":[5934480],"length":1,"stats":{"Line":0}},{"line":19,"address":[6080440,6080689,6080470,6080244,6080726,6080801],"length":1,"stats":{"Line":0}},{"line":20,"address":[6080307],"length":1,"stats":{"Line":0}},{"line":21,"address":[6080261],"length":1,"stats":{"Line":0}},{"line":22,"address":[6080265],"length":1,"stats":{"Line":0}},{"line":24,"address":[5934498],"length":1,"stats":{"Line":0}},{"line":26,"address":[6080926,6080974],"length":1,"stats":{"Line":0}},{"line":28,"address":[6081043],"length":1,"stats":{"Line":0}},{"line":31,"address":[6061200],"length":1,"stats":{"Line":0}},{"line":35,"address":[6081797,6081669],"length":1,"stats":{"Line":0}},{"line":37,"address":[6082129,6082081,6082370,6081866,6082352,6081943],"length":1,"stats":{"Line":0}},{"line":39,"address":[5935821],"length":1,"stats":{"Line":0}},{"line":42,"address":[6082588,6082871,6082413,6082618,6082946,6082834],"length":1,"stats":{"Line":0}},{"line":43,"address":[6082463],"length":1,"stats":{"Line":0}},{"line":44,"address":[6082430],"length":1,"stats":{"Line":0}},{"line":46,"address":[6082836,6082611,6082648,6082939,6081742,6082672],"length":1,"stats":{"Line":0}},{"line":48,"address":[6083155,6083071],"length":1,"stats":{"Line":0}},{"line":51,"address":[6061264],"length":1,"stats":{"Line":0}},{"line":55,"address":[6083787,6083659],"length":1,"stats":{"Line":0}},{"line":57,"address":[6084071,6084119,6083856,6084342,6084360,6083933],"length":1,"stats":{"Line":0}},{"line":59,"address":[5936409],"length":1,"stats":{"Line":0}},{"line":62,"address":[6084792,6084539,6084403,6084509,6084867,6084755],"length":1,"stats":{"Line":0}},{"line":63,"address":[6084432],"length":1,"stats":{"Line":0}},{"line":65,"address":[6084420],"length":1,"stats":{"Line":0}},{"line":68,"address":[5936424],"length":1,"stats":{"Line":0}},{"line":70,"address":[6084992,6085076],"length":1,"stats":{"Line":0}},{"line":73,"address":[6061312],"length":1,"stats":{"Line":0}},{"line":76,"address":[6086098,6085860,6086080,6085513,6085815,6085636],"length":1,"stats":{"Line":0}},{"line":78,"address":[5936905],"length":1,"stats":{"Line":0}},{"line":81,"address":[6086486,6086598,6086240,6086523,6086270,6086141],"length":1,"stats":{"Line":0}},{"line":82,"address":[6086163],"length":1,"stats":{"Line":0}},{"line":85,"address":[5936920],"length":1,"stats":{"Line":0}},{"line":87,"address":[6087091,6086891],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":36},{"path":["/","home","vidyootsenthil","Documents","TheValut-nameTBD","bin","cli","src","tests.rs"],"content":"use super::*;\nuse assert_matches::assert_matches;\nuse std::fs;\nuse tempfile::tempdir;\n\n// Helper function to decrypt private key\nfn decrypt_private_key(\n    encrypted_key: \u0026str,\n    password: \u0026str,\n    params: \u0026EncryptionParams,\n) -\u003e Result\u003cVec\u003cu8\u003e, KeygenError\u003e {\n    let salt = SaltString::from_b64(\u0026params.salt_b64)\n        .map_err(|e| KeygenError::Encryption(e.to_string()))?;\n    let key = generate_key(password, \u0026salt)?;\n\n    let nonce_bytes = BASE64\n        .decode(\u0026params.iv_b64)\n        .map_err(|e| KeygenError::Encryption(e.to_string()))?;\n    let nonce = Nonce::from_slice(\u0026nonce_bytes);\n\n    let cipher = Aes256Gcm::new(Key::\u003cAes256Gcm\u003e::from_slice(\u0026key));\n\n    let ciphertext = BASE64\n        .decode(encrypted_key)\n        .map_err(|e| KeygenError::Encryption(e.to_string()))?;\n\n    cipher\n        .decrypt(nonce, ciphertext.as_ref())\n        .map_err(|e| KeygenError::Encryption(e.to_string()))\n}\n\n// Test helper to generate keypair without password prompt\nfn generate_test_keypair(output_path: Option\u003cPathBuf\u003e, password: \u0026str) -\u003e Result\u003c(), KeygenError\u003e {\n    let keypair = Keypair::generate_ed25519();\n    let public_key = keypair.public().encode_protobuf();\n    let public_key_b58 = bs58::encode(public_key).into_string();\n\n    let (encrypted_private_key, encryption_params) = encrypt_private_key(\u0026keypair, password)?;\n\n    let key_data = KeyData {\n        public_key_b58: public_key_b58.clone(),\n        encrypted_private_key_b64: encrypted_private_key,\n        encryption_params,\n    };\n\n    let json = serde_json::to_string_pretty(\u0026key_data)\n        .map_err(|e| KeygenError::Io(std::io::Error::other(e)))?;\n\n    let key_file_path = if let Some(path) = output_path {\n        if path.is_dir() {\n            path.join(\"config.json\")\n        } else {\n            path\n        }\n    } else {\n        get_key_file_path()?.key_file_path\n    };\n\n    fs::write(\u0026key_file_path, json).map_err(KeygenError::Io)?;\n    Ok(())\n}\n\n#[test]\nfn test_key_generation_and_encryption() {\n    let keypair = Keypair::generate_ed25519();\n    let password = \"test_password123\";\n\n    let (encrypted_key, params) = encrypt_private_key(\u0026keypair, password).unwrap();\n\n    assert_eq!(params.kdf, \"argon2id\");\n    assert!(!params.salt_b64.is_empty());\n    assert!(!params.iv_b64.is_empty());\n    assert!(!encrypted_key.is_empty());\n\n    // Verify we can decrypt with correct password\n    let decrypted = decrypt_private_key(\u0026encrypted_key, password, \u0026params).unwrap();\n    let original = keypair.to_protobuf_encoding().unwrap();\n    assert_eq!(decrypted, original);\n}\n\n#[test]\nfn test_decryption_with_wrong_password() {\n    let keypair = Keypair::generate_ed25519();\n    let password = \"correct_password\";\n    let wrong_password = \"wrong_password\";\n\n    let (encrypted_key, params) = encrypt_private_key(\u0026keypair, password).unwrap();\n\n    // Attempt decryption with wrong password should fail\n    let result = decrypt_private_key(\u0026encrypted_key, wrong_password, \u0026params);\n    assert!(result.is_err());\n}\n\n#[test]\nfn test_key_file_operations() {\n    let temp_dir = tempdir().unwrap();\n    let output_path = temp_dir.path().join(\"test_config.json\");\n\n    // Test key generation and file writing\n    let result = generate_test_keypair(Some(output_path.clone()), \"test_password123\");\n    assert!(result.is_ok());\n\n    // Verify file exists and contains valid JSON\n    let contents = fs::read_to_string(\u0026output_path).unwrap();\n    let key_data: KeyData = serde_json::from_str(\u0026contents).unwrap();\n\n    assert!(!key_data.public_key_b58.is_empty());\n    assert!(!key_data.encrypted_private_key_b64.is_empty());\n    assert_eq!(key_data.encryption_params.kdf, \"argon2id\");\n}\n\n#[test]\nfn test_invalid_directory() {\n    // Test with a non-existent directory\n    let result = generate_test_keypair(\n        Some(PathBuf::from(\"/nonexistent/path/config.json\")),\n        \"test_password123\",\n    );\n    assert_matches!(result, Err(KeygenError::Io(_)));\n}\n\n#[test]\nfn test_key_encoding() {\n    let keypair = Keypair::generate_ed25519();\n    let public_key = keypair.public().encode_protobuf();\n    let public_key_b58 = bs58::encode(public_key).into_string();\n\n    // Verify the public key is properly encoded\n    assert!(!public_key_b58.is_empty());\n    assert!(bs58::decode(\u0026public_key_b58).into_vec().is_ok());\n}\n\n#[test]\nfn test_encryption_params_serialization() {\n    let params = EncryptionParams {\n        kdf: \"argon2id\".to_string(),\n        salt_b64: \"test_salt\".to_string(),\n        iv_b64: \"test_iv\".to_string(),\n    };\n\n    let json = serde_json::to_string(\u0026params).unwrap();\n    let deserialized: EncryptionParams = serde_json::from_str(\u0026json).unwrap();\n\n    assert_eq!(params.kdf, deserialized.kdf);\n    assert_eq!(params.salt_b64, deserialized.salt_b64);\n    assert_eq!(params.iv_b64, deserialized.iv_b64);\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","vidyootsenthil","Documents","TheValut-nameTBD","bin","utxo-spend","src","main.rs"],"content":"use bip39::{Language, Mnemonic};\n#[allow(deprecated)]\nuse bitcoin::bip32::{DerivationPath, ExtendedPrivKey};\nuse bitcoin::consensus::encode::serialize;\nuse bitcoin::key::Secp256k1;\nuse bitcoin::transaction::OutPoint;\nuse bitcoin::witness::Witness;\nuse bitcoin::{Address, Amount, CompressedPublicKey, Network, PrivateKey, Transaction, Txid};\nuse esplora_client::Builder;\nuse node::wallet::SimpleWallet;\nuse std::str::FromStr;\n\n#[tokio::main]\nasync fn main() {\n    let (address, private_key) = generate_from_mnemonic(\n        \"promote aspect indoor neck stand lion wealth priority matrix nest broccoli feel\",\n    );\n    println!(\"Address: {}\", address);\n\n    let address_to =\n        Address::from_str(\"bc1pg520trs6vk0yplnx0mp5v7lrx2yyw00nqy8qmzdpevpz3knjz9fq2ps3jx\")\n            .unwrap()\n            .assume_checked();\n\n    let mut wallet = SimpleWallet::new(\u0026address);\n    wallet.utxos = get_utxos_for_address(\u0026address);\n\n    let (mut tx, sighash) = wallet.create_spend(1000, \u0026address_to).unwrap();\n    println!(\"Tx: {:?}\", tx);\n    println!(\"Sighash: {:?}\", sighash);\n\n    // Sign the transaction\n    sign_transaction(\u0026mut tx, \u0026private_key, \u0026sighash);\n\n    println!(\"Tx signed: {:?}\", tx);\n\n    // // Broadcast the transaction\n    broadcast_transaction(\u0026tx).await;\n}\n\nfn sign_transaction(tx: \u0026mut Transaction, private_key: \u0026PrivateKey, sighash: \u0026[u8; 32]) {\n    // For P2WPKH, we need to create a witness signature\n    let secp = Secp256k1::new();\n\n    // Create the signature (this is simplified - in practice you'd need proper sighash computation)\n    let message = bitcoin::secp256k1::Message::from_digest(*sighash);\n    let signature = secp.sign_ecdsa(\u0026message, \u0026private_key.inner);\n\n    // Create witness with signature + sighash type (0x01 = SIGHASH_ALL)\n    let mut sig_bytes = signature.serialize_der().to_vec();\n    sig_bytes.push(0x01); // SIGHASH_ALL\n\n    let compressed_pubkey = CompressedPublicKey::from_private_key(\u0026secp, private_key)\n        .expect(\"Failed to get compressed public key\");\n\n    let mut witness = Witness::new();\n    witness.push(sig_bytes);\n    witness.push(compressed_pubkey.to_bytes());\n\n    // Add witness to the first (and only) input\n    if let Some(input) = tx.input.first_mut() {\n        input.witness = witness;\n    }\n\n    println!(\"Transaction signed!\");\n}\n\nasync fn broadcast_transaction(tx: \u0026Transaction) {\n    // Create esplora client for testnet4\n    let builder = Builder::new(\"https://blockstream.info/testnet/api\");\n    let client = builder.build_async().unwrap();\n\n    // Serialize the transaction to raw bytes\n    let tx_bytes = serialize(tx);\n    let tx_hex = hex::encode(\u0026tx_bytes);\n\n    println!(\"Raw transaction: {}\", tx_hex);\n\n    // Broadcast the transaction\n    match client.broadcast(tx).await {\n        Ok(()) =\u003e {\n            println!(\"✅ Transaction broadcast successfully!\");\n            println!(\"Txid: {:?}\", tx.compute_txid());\n        }\n        Err(e) =\u003e {\n            println!(\"❌ Failed to broadcast transaction: {}\", e);\n        }\n    }\n}\n\npub fn get_utxos_for_address(address: \u0026Address) -\u003e Vec\u003cnode::wallet::Utxo\u003e {\n    let utxos = vec![node::wallet::Utxo {\n        outpoint: OutPoint::new(\n            Txid::from_str(\"f0d3f62a1a516e75ff5e5c4946a2d714a8a813167d79224b3a1ec0a241cf0e89\")\n                .unwrap(),\n            0,\n        ),\n        value: Amount::from_sat(50_000_000),\n        script_pubkey: address.script_pubkey(),\n    }];\n    utxos\n}\n\n#[allow(deprecated)]\npub fn generate_from_mnemonic(mnemonic: \u0026str) -\u003e (Address, PrivateKey) {\n    // Generate a new mnemonic (12 words)\n    let mnemonic = Mnemonic::parse_in_normalized(Language::English, mnemonic).unwrap();\n    println!(\"Mnemonic: {}\", mnemonic);\n\n    // Convert to seed\n    let seed = mnemonic.to_seed(\"\"); // Empty passphrase\n\n    // Create extended private key\n    let secp = Secp256k1::new();\n    let xprv = ExtendedPrivKey::new_master(Network::Testnet4, \u0026seed).unwrap();\n\n    // Derive key at standard path (m/84'/1'/0'/0/0 for signet P2WPKH)\n    let derivation_path = DerivationPath::from_str(\"m/84'/1'/0'/0/0\").unwrap();\n    let derived_xprv = xprv.derive_priv(\u0026secp, \u0026derivation_path).unwrap();\n\n    // Get the private key\n    let private_key = PrivateKey::new(derived_xprv.private_key, Network::Testnet4);\n    let compressed_public_key: CompressedPublicKey =\n        CompressedPublicKey::from_private_key(\u0026secp, \u0026private_key)\n            .expect(\"Failed to convert public key to compressed public key\");\n    let address = Address::p2wpkh(\u0026compressed_public_key, Network::Testnet4);\n\n    println!(\"Extended Private Key: {}\", xprv);\n    println!(\"Derived Private Key (WIF): {}\", private_key.to_wif());\n    println!(\"Address: {}\", address);\n    (address, private_key)\n}\n","traces":[{"line":14,"address":[5603378,5603384,5602976],"length":1,"stats":{"Line":0}},{"line":18,"address":[5591667],"length":1,"stats":{"Line":0}},{"line":20,"address":[5591756],"length":1,"stats":{"Line":0}},{"line":25,"address":[5591845],"length":1,"stats":{"Line":0}},{"line":26,"address":[5591933,5591868,5591953],"length":1,"stats":{"Line":0}},{"line":28,"address":[5592062],"length":1,"stats":{"Line":0}},{"line":29,"address":[5592307,5592232],"length":1,"stats":{"Line":0}},{"line":30,"address":[5592376],"length":1,"stats":{"Line":0}},{"line":33,"address":[5592472],"length":1,"stats":{"Line":0}},{"line":35,"address":[5592511],"length":1,"stats":{"Line":0}},{"line":38,"address":[5592737,5591520,5592607],"length":1,"stats":{"Line":0}},{"line":41,"address":[5600192,5601185,5601213],"length":1,"stats":{"Line":0}},{"line":43,"address":[5600238],"length":1,"stats":{"Line":0}},{"line":46,"address":[5600273],"length":1,"stats":{"Line":0}},{"line":47,"address":[5600356],"length":1,"stats":{"Line":0}},{"line":50,"address":[5600401],"length":1,"stats":{"Line":0}},{"line":51,"address":[5600470],"length":1,"stats":{"Line":0}},{"line":53,"address":[5600560],"length":1,"stats":{"Line":0}},{"line":56,"address":[5600617],"length":1,"stats":{"Line":0}},{"line":57,"address":[5600624],"length":1,"stats":{"Line":0}},{"line":58,"address":[5600736],"length":1,"stats":{"Line":0}},{"line":61,"address":[5600791,5601078],"length":1,"stats":{"Line":0}},{"line":62,"address":[5601003,5600902],"length":1,"stats":{"Line":0}},{"line":65,"address":[5600973,5601080],"length":1,"stats":{"Line":0}},{"line":68,"address":[5589696,5589854,5589814,5589721,5590425,5590376],"length":1,"stats":{"Line":0}},{"line":70,"address":[5589786],"length":1,"stats":{"Line":0}},{"line":71,"address":[5589901],"length":1,"stats":{"Line":0}},{"line":74,"address":[5589960],"length":1,"stats":{"Line":0}},{"line":75,"address":[5590029],"length":1,"stats":{"Line":0}},{"line":77,"address":[5590164,5590094],"length":1,"stats":{"Line":0}},{"line":80,"address":[5590233,5590451,5590686,5590322,5589841],"length":1,"stats":{"Line":0}},{"line":81,"address":[5591001],"length":1,"stats":{"Line":0}},{"line":82,"address":[5590862,5590791],"length":1,"stats":{"Line":0}},{"line":83,"address":[5590881],"length":1,"stats":{"Line":0}},{"line":85,"address":[5590713],"length":1,"stats":{"Line":0}},{"line":86,"address":[5591070,5590761],"length":1,"stats":{"Line":0}},{"line":91,"address":[5601680,5601264,5601686],"length":1,"stats":{"Line":0}},{"line":92,"address":[5601304,5601667,5601350,5601479],"length":1,"stats":{"Line":0}},{"line":93,"address":[5601427],"length":1,"stats":{"Line":0}},{"line":94,"address":[5601314,5601382],"length":1,"stats":{"Line":0}},{"line":98,"address":[5601434],"length":1,"stats":{"Line":0}},{"line":99,"address":[5601460],"length":1,"stats":{"Line":0}},{"line":105,"address":[5602949,5601712,5602955],"length":1,"stats":{"Line":0}},{"line":107,"address":[5601745],"length":1,"stats":{"Line":0}},{"line":108,"address":[5601804],"length":1,"stats":{"Line":0}},{"line":111,"address":[5601903],"length":1,"stats":{"Line":0}},{"line":114,"address":[5601908],"length":1,"stats":{"Line":0}},{"line":115,"address":[5602010,5601930],"length":1,"stats":{"Line":0}},{"line":118,"address":[5602040],"length":1,"stats":{"Line":0}},{"line":119,"address":[5602133,5602184],"length":1,"stats":{"Line":0}},{"line":122,"address":[5602214],"length":1,"stats":{"Line":0}},{"line":123,"address":[5602309],"length":1,"stats":{"Line":0}},{"line":126,"address":[5602358],"length":1,"stats":{"Line":0}},{"line":128,"address":[5602413],"length":1,"stats":{"Line":0}},{"line":129,"address":[5602489],"length":1,"stats":{"Line":0}},{"line":130,"address":[5602739],"length":1,"stats":{"Line":0}},{"line":131,"address":[5602820],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":57},{"path":["/","home","vidyootsenthil","Documents","TheValut-nameTBD","crates","clients","src","lib.rs"],"content":"use async_trait::async_trait;\nuse bitcoin::{consensus, Address, Network, Transaction};\nuse esplora_client::AsyncClient;\nuse std::{collections::HashSet, str::FromStr};\nuse tokio::sync::broadcast;\nuse tokio::time::{sleep, Duration};\nuse tracing::{error, info};\n\n#[derive(Debug)]\npub enum NodeError {\n    Error(String),\n}\n\n#[async_trait]\npub trait WindowedConfirmedTransactionProvider {\n    // Must only return transactions that are confirmed in the given range [min_height, max_height].\n    // All returned transactions must have at least six confirmations (\u003c current_chain_tip_height - 6).\n    async fn get_confirmed_transactions(\n        \u0026self,\n        addresses: Vec\u003cAddress\u003e,\n        min_height: u32,\n        max_height: u32,\n    ) -\u003e Result\u003cVec\u003cTransaction\u003e, NodeError\u003e;\n\n    // Must poll for new transactions and send them to the given channel.\n    async fn poll_new_transactions(\u0026mut self, addresses: Vec\u003cAddress\u003e);\n}\n\n#[derive(Debug)]\npub struct EsploraApiClient {\n    client: AsyncClient,\n    tx_channel: broadcast::Sender\u003cTransaction\u003e,\n    deposit_intent_rx: Option\u003cbroadcast::Receiver\u003cString\u003e\u003e,\n}\n\nimpl EsploraApiClient {\n    pub fn new(\n        client: AsyncClient,\n        capacity: usize,\n        deposit_intent_rx: Option\u003cbroadcast::Receiver\u003cString\u003e\u003e,\n    ) -\u003e Self {\n        Self {\n            client,\n            tx_channel: broadcast::channel(capacity).0,\n            deposit_intent_rx,\n        }\n    }\n}\n\n#[async_trait]\nimpl WindowedConfirmedTransactionProvider for EsploraApiClient {\n    async fn get_confirmed_transactions(\n        \u0026self,\n        addresses: Vec\u003cAddress\u003e,\n        min_height: u32,\n        max_height: u32,\n    ) -\u003e Result\u003cVec\u003cTransaction\u003e, NodeError\u003e {\n        let blockchain_height = self.client.get_height().await.map_err(|e| {\n            NodeError::Error(format!(\"Cannot retrieve height of blockchain: {}\", e))\n        })?;\n\n        let new_max_height = max_height.min(blockchain_height - 6);\n        let mut confirmed_txs = Vec::new();\n\n        for address in \u0026addresses {\n            let mut last_seen_txid = None;\n\n            loop {\n                let address_txs = self\n                    .client\n                    .scripthash_txs(\u0026address.script_pubkey(), last_seen_txid)\n                    .await\n                    .map_err(|e| {\n                        NodeError::Error(format!(\"Cannot retrieve transactions for address: {}\", e))\n                    })?;\n\n                if address_txs.is_empty() {\n                    break;\n                }\n\n                last_seen_txid = Some(address_txs.last().unwrap().txid);\n\n                let mut found_confirmed = false;\n                let last_tx_height = address_txs.last().and_then(|tx| tx.status.block_height);\n\n                for tx in address_txs {\n                    if let Some(block_height) = tx.status.block_height {\n                        if block_height \u003e= min_height \u0026\u0026 block_height \u003c= new_max_height {\n                            if let Ok(full_tx) = self.client.get_tx(\u0026tx.txid).await {\n                                if let Ok(bitcoin_tx) =\n                                    consensus::deserialize(\u0026consensus::serialize(\u0026full_tx.unwrap()))\n                                {\n                                    confirmed_txs.push(bitcoin_tx);\n                                    found_confirmed = true;\n                                }\n                            }\n                        }\n                    }\n                }\n\n                if !found_confirmed \u0026\u0026 last_tx_height.is_some_and(|height| height \u003c min_height) {\n                    break;\n                }\n            }\n\n            sleep(Duration::from_secs(5)).await;\n        }\n\n        Ok(confirmed_txs)\n    }\n\n    async fn poll_new_transactions(\u0026mut self, addresses: Vec\u003cAddress\u003e) {\n        let mut last_confirmed_height = match self.client.get_height().await {\n            Ok(height) =\u003e height - 6,\n            Err(e) =\u003e {\n                error!(\"Cannot retrieve height of blockchain: {}\", e);\n                return;\n            }\n        };\n\n        info!(\n            \"Polling for new transactions, starting from confirmed height {}\",\n            last_confirmed_height\n        );\n\n        let mut deposit_intent_rx = self.deposit_intent_rx.take().unwrap();\n        let mut addresses: HashSet\u003c_\u003e = addresses.into_iter().collect();\n\n        loop {\n            tokio::select! {\n                _ = sleep(Duration::from_secs(30)) =\u003e {\n                    let current_height = match self.client.get_height().await {\n                        Ok(height) =\u003e height,\n                        Err(e) =\u003e {\n                            error!(\"Cannot retrieve height of blockchain: {}\", e);\n                            continue;\n                        }\n                    };\n\n                    let new_confirmed_height = current_height - 6;\n\n                    if new_confirmed_height \u003e last_confirmed_height {\n                        info!(\n                            \"New confirmed block found. From height {} to {}\",\n                            last_confirmed_height + 1,\n                            new_confirmed_height\n                        );\n\n                        let new_txs = match self\n                            .get_confirmed_transactions(\n                                addresses.iter().cloned().collect(),\n                                last_confirmed_height + 1,\n                                new_confirmed_height,\n                            )\n                            .await\n                        {\n                            Ok(txs) =\u003e txs,\n                            Err(e) =\u003e {\n                                error!(\"Error getting confirmed transactions: {:?}\", e);\n                                continue;\n                            }\n                        };\n\n                        for tx in new_txs {\n                            println!(\"Found new confirmed transaction: {}\", tx.compute_txid());\n                            match self.tx_channel.send(tx) {\n                                Ok(_) =\u003e (),\n                                Err(e) =\u003e {\n                                    error!(\"Error sending transaction to channel: {:?}\", e);\n                                }\n                            }\n                        }\n\n                        last_confirmed_height = new_confirmed_height;\n                    }\n                }\n                Ok(address_str) = deposit_intent_rx.recv() =\u003e {\n                    info!(\"Received new deposit address to monitor: {}\", \u0026address_str);\n                    if addresses.insert(\n                        Address::from_str(\u0026address_str)\n                            .unwrap()\n                            .require_network(Network::Bitcoin)\n                            .unwrap(),\n                    ) {\n                        info!(\"Now polling {} addresses.\", addresses.len());\n                    }\n                }\n            }\n        }\n    }\n}\n","traces":[{"line":37,"address":[15961202,15960928,15961196],"length":1,"stats":{"Line":1}},{"line":44,"address":[15961078,15961012],"length":1,"stats":{"Line":2}},{"line":58,"address":[15739245,15737941,15738889,15743678,15738413,15738334,15743456,15738533],"length":1,"stats":{"Line":3}},{"line":59,"address":[16035302,16035362],"length":1,"stats":{"Line":0}},{"line":62,"address":[12675020],"length":1,"stats":{"Line":1}},{"line":63,"address":[2020385],"length":1,"stats":{"Line":1}},{"line":65,"address":[12675291,12675172,12675655,12675275],"length":1,"stats":{"Line":4}},{"line":66,"address":[13139650],"length":1,"stats":{"Line":1}},{"line":68,"address":[12677662,12675729],"length":1,"stats":{"Line":2}},{"line":69,"address":[13140389,13140463,13140192,13139887,13140138,13140563],"length":1,"stats":{"Line":5}},{"line":71,"address":[13139971,13140085,13139907],"length":1,"stats":{"Line":3}},{"line":72,"address":[2021494,2020579,2021489,2021693,2019322,2021449],"length":1,"stats":{"Line":5}},{"line":73,"address":[2025066,2024848],"length":1,"stats":{"Line":0}},{"line":74,"address":[12679814,12679874],"length":1,"stats":{"Line":0}},{"line":77,"address":[15740740],"length":1,"stats":{"Line":1}},{"line":81,"address":[2022029,2022094],"length":1,"stats":{"Line":2}},{"line":83,"address":[16032837],"length":1,"stats":{"Line":1}},{"line":84,"address":[12680053,12680048,12677108],"length":1,"stats":{"Line":3}},{"line":86,"address":[12677228,12677373,12677460],"length":1,"stats":{"Line":3}},{"line":87,"address":[2022809,2022671],"length":1,"stats":{"Line":2}},{"line":88,"address":[15741626,15743078,15741675],"length":1,"stats":{"Line":3}},{"line":89,"address":[2022899,2023053,2020612,2019343,2023008,2023455],"length":1,"stats":{"Line":5}},{"line":90,"address":[2023835,2023889,2024077],"length":1,"stats":{"Line":4}},{"line":93,"address":[15742777],"length":1,"stats":{"Line":1}},{"line":94,"address":[15742878],"length":1,"stats":{"Line":1}},{"line":101,"address":[12677588,12680073,12680064,12677671],"length":1,"stats":{"Line":4}},{"line":106,"address":[15739387,15738004,15739353,15743170,15743122],"length":1,"stats":{"Line":4}},{"line":109,"address":[16031478],"length":1,"stats":{"Line":1}},{"line":112,"address":[12605887],"length":1,"stats":{"Line":0}},{"line":113,"address":[15573122],"length":1,"stats":{"Line":0}},{"line":114,"address":[16036839,16036759],"length":1,"stats":{"Line":0}},{"line":115,"address":[16036680],"length":1,"stats":{"Line":0}},{"line":116,"address":[12682538,12680984,12682251],"length":1,"stats":{"Line":0}},{"line":121,"address":[2026083,2026445,2026138],"length":1,"stats":{"Line":0}},{"line":126,"address":[12681387,12681915],"length":1,"stats":{"Line":0}},{"line":127,"address":[2027128,2027008],"length":1,"stats":{"Line":0}},{"line":129,"address":[12692482],"length":1,"stats":{"Line":0}},{"line":130,"address":[15573148,15573473,15573326,15573406,15573516,15573591,15573755],"length":1,"stats":{"Line":0}}],"covered":25,"coverable":38},{"path":["/","home","vidyootsenthil","Documents","TheValut-nameTBD","crates","node","build.rs"],"content":"fn main() -\u003e Result\u003c(), Box\u003cdyn std::error::Error\u003e\u003e {\n    tonic_build::compile_protos(\"proto/node.proto\")?;\n    Ok(())\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","vidyootsenthil","Documents","TheValut-nameTBD","crates","node","src","db.rs"],"content":"use rocksdb::DB;\n\nuse protocol::{\n    block::{Block, BlockHash},\n    chain_state::ChainState,\n};\nuse types::errors::NodeError;\n\nuse crate::deposit_intents::DepositIntent;\n\npub trait Db: Send {\n    fn get_block_by_height(\u0026self, height: u64) -\u003e Result\u003cOption\u003cBlock\u003e, NodeError\u003e;\n    fn get_block_by_hash(\u0026self, hash: BlockHash) -\u003e Result\u003cOption\u003cBlock\u003e, NodeError\u003e;\n    fn get_tip_block_hash(\u0026self) -\u003e Result\u003cOption\u003cBlockHash\u003e, NodeError\u003e;\n    fn get_chain_state(\u0026self) -\u003e Result\u003cOption\u003cChainState\u003e, NodeError\u003e;\n    fn insert_chain_state(\u0026mut self, chain_state: ChainState) -\u003e Result\u003c(), NodeError\u003e;\n    fn insert_block(\u0026mut self, block: Block) -\u003e Result\u003c(), NodeError\u003e;\n    fn insert_deposit_intent(\u0026mut self, intent: DepositIntent) -\u003e Result\u003c(), NodeError\u003e;\n    fn get_deposit_intent(\u0026self, tracking_id: \u0026str) -\u003e Result\u003cOption\u003cDepositIntent\u003e, NodeError\u003e;\n}\n\npub struct RocksDb {\n    pub db: DB,\n}\n\nimpl RocksDb {\n    pub fn new(path: \u0026str) -\u003e Self {\n        let mut opts = rocksdb::Options::default();\n        opts.create_if_missing(true);\n        opts.create_missing_column_families(true);\n\n        let cfs = vec![\"deposit_intents\", \"blocks\", \"chain_state\"];\n        let db = DB::open_cf(\u0026opts, path, cfs).unwrap();\n\n        Self { db }\n    }\n}\n\nimpl Db for RocksDb {\n    fn get_block_by_height(\u0026self, height: u64) -\u003e Result\u003cOption\u003cBlock\u003e, NodeError\u003e {\n        let block_hash = self.db.get_cf(\n            self.db.cf_handle(\"blocks\").unwrap(),\n            format!(\"h:{}\", height),\n        )?;\n        if let Some(block_hash) = block_hash {\n            let block = self.db.get_cf(\n                self.db.cf_handle(\"blocks\").unwrap(),\n                format!(\"b:{}\", hex::encode(block_hash)),\n            )?;\n            Ok(block.and_then(|b| Block::deserialize(\u0026b).ok()))\n        } else {\n            Ok(None)\n        }\n    }\n\n    fn get_block_by_hash(\u0026self, hash: BlockHash) -\u003e Result\u003cOption\u003cBlock\u003e, NodeError\u003e {\n        let block = self.db.get_cf(\n            self.db.cf_handle(\"blocks\").unwrap(),\n            format!(\"b:{}\", hex::encode(hash)),\n        )?;\n        Ok(block.and_then(|b| Block::deserialize(\u0026b).ok()))\n    }\n\n    fn get_tip_block_hash(\u0026self) -\u003e Result\u003cOption\u003cBlockHash\u003e, NodeError\u003e {\n        let tip = self\n            .db\n            .get_cf(self.db.cf_handle(\"blocks\").unwrap(), \"h:tip\")?;\n        Ok(tip.and_then(|b| b.as_slice().try_into().ok()))\n    }\n\n    fn insert_chain_state(\u0026mut self, chain_state: ChainState) -\u003e Result\u003c(), NodeError\u003e {\n        self.db.put_cf(\n            self.db.cf_handle(\"chain_state\").unwrap(),\n            \"c:state\",\n            chain_state.serialize()?,\n        )?;\n        Ok(())\n    }\n\n    fn get_chain_state(\u0026self) -\u003e Result\u003cOption\u003cChainState\u003e, NodeError\u003e {\n        let chain_state = self\n            .db\n            .get_cf(self.db.cf_handle(\"chain_state\").unwrap(), \"c:state\")?;\n        Ok(chain_state.and_then(|b| ChainState::deserialize(\u0026b).ok()))\n    }\n\n    fn insert_block(\u0026mut self, block: Block) -\u003e Result\u003c(), NodeError\u003e {\n        let block_hash = block.hash();\n        self.db\n            .put_cf(\n                self.db.cf_handle(\"blocks\").unwrap(),\n                format!(\"b:{}\", hex::encode(block_hash)),\n                block.serialize()?,\n            )\n            .map_err(|e| NodeError::Error(format!(\"Failed to insert block: {}\", e)))?;\n\n        self.db\n            .put_cf(\n                self.db.cf_handle(\"blocks\").unwrap(),\n                format!(\"h:{}\", block.header.height),\n                block_hash,\n            )\n            .map_err(|e| NodeError::Error(format!(\"Failed to insert block: {}\", e)))?;\n\n        self.db\n            .put_cf(self.db.cf_handle(\"blocks\").unwrap(), \"h:tip\", block_hash)?;\n\n        Ok(())\n    }\n\n    fn insert_deposit_intent(\u0026mut self, intent: DepositIntent) -\u003e Result\u003c(), NodeError\u003e {\n        let key = format!(\"di:{}\", intent.deposit_tracking_id);\n        let value = bincode::encode_to_vec(\u0026intent, bincode::config::standard())\n            .map_err(|e| NodeError::Error(format!(\"Failed to serialize deposit intent: {}\", e)))?;\n\n        self.db\n            .put_cf(self.db.cf_handle(\"deposit_intents\").unwrap(), key, value)?;\n        Ok(())\n    }\n\n    fn get_deposit_intent(\u0026self, tracking_id: \u0026str) -\u003e Result\u003cOption\u003cDepositIntent\u003e, NodeError\u003e {\n        let key = format!(\"di:{}\", tracking_id);\n        let value = self\n            .db\n            .get_cf(self.db.cf_handle(\"deposit_intents\").unwrap(), key)?;\n\n        Ok(value.and_then(|v| {\n            bincode::decode_from_slice(\u0026v, bincode::config::standard())\n                .ok()\n                .map(|(intent, _)| intent)\n        }))\n    }\n}\n","traces":[{"line":27,"address":[11571210,11571216,11570768],"length":1,"stats":{"Line":0}},{"line":28,"address":[10003595],"length":1,"stats":{"Line":0}},{"line":29,"address":[5775283],"length":1,"stats":{"Line":0}},{"line":30,"address":[12130572],"length":1,"stats":{"Line":0}},{"line":32,"address":[11570923],"length":1,"stats":{"Line":0}},{"line":33,"address":[11571100],"length":1,"stats":{"Line":0}},{"line":40,"address":[11572652,11572747,11571232],"length":1,"stats":{"Line":0}},{"line":41,"address":[10004059,10004345,10004255],"length":1,"stats":{"Line":0}},{"line":42,"address":[11571299],"length":1,"stats":{"Line":0}},{"line":43,"address":[12131018],"length":1,"stats":{"Line":0}},{"line":45,"address":[11571673,11571823],"length":1,"stats":{"Line":0}},{"line":46,"address":[10005127,10005022],"length":1,"stats":{"Line":0}},{"line":47,"address":[12131554,12131434],"length":1,"stats":{"Line":0}},{"line":48,"address":[5776331],"length":1,"stats":{"Line":0}},{"line":50,"address":[6407696,6407724],"length":1,"stats":{"Line":0}},{"line":52,"address":[5776226],"length":1,"stats":{"Line":0}},{"line":56,"address":[11572832,11573590,11573619],"length":1,"stats":{"Line":0}},{"line":57,"address":[10006141,10006175,10005657,10006051],"length":1,"stats":{"Line":0}},{"line":58,"address":[11572881],"length":1,"stats":{"Line":0}},{"line":59,"address":[11572931],"length":1,"stats":{"Line":0}},{"line":61,"address":[12133131,12133231],"length":1,"stats":{"Line":0}},{"line":64,"address":[10006867,10006838,10006416],"length":1,"stats":{"Line":0}},{"line":65,"address":[11573720,11573812,11573670,11573843],"length":1,"stats":{"Line":0}},{"line":67,"address":[5778078,5778172],"length":1,"stats":{"Line":0}},{"line":68,"address":[11421995,11421968],"length":1,"stats":{"Line":0}},{"line":71,"address":[10006880,10007381],"length":1,"stats":{"Line":0}},{"line":72,"address":[10007173,10007364,10007296],"length":1,"stats":{"Line":0}},{"line":73,"address":[12133893,12133819],"length":1,"stats":{"Line":0}},{"line":75,"address":[5778616,5778951],"length":1,"stats":{"Line":0}},{"line":77,"address":[10007332],"length":1,"stats":{"Line":0}},{"line":80,"address":[10007863,10007408,10007834],"length":1,"stats":{"Line":0}},{"line":81,"address":[10007496,10007588,10007446,10007619],"length":1,"stats":{"Line":0}},{"line":83,"address":[5779116,5779022],"length":1,"stats":{"Line":0}},{"line":84,"address":[5779242,5779338],"length":1,"stats":{"Line":0}},{"line":87,"address":[10009616,10007872],"length":1,"stats":{"Line":0}},{"line":88,"address":[10007915],"length":1,"stats":{"Line":0}},{"line":89,"address":[5780332,5780133,5781051,5780237],"length":1,"stats":{"Line":0}},{"line":91,"address":[10007985],"length":1,"stats":{"Line":0}},{"line":92,"address":[5779601],"length":1,"stats":{"Line":0}},{"line":93,"address":[12135269,12135332],"length":1,"stats":{"Line":0}},{"line":95,"address":[11422326,11422304],"length":1,"stats":{"Line":0}},{"line":97,"address":[10009213,10009561,10009024],"length":1,"stats":{"Line":0}},{"line":99,"address":[5780362],"length":1,"stats":{"Line":0}},{"line":100,"address":[10008891],"length":1,"stats":{"Line":0}},{"line":103,"address":[11576397],"length":1,"stats":{"Line":0}},{"line":105,"address":[11576694,11576527,11576762],"length":1,"stats":{"Line":0}},{"line":106,"address":[10009446,10009247],"length":1,"stats":{"Line":0}},{"line":108,"address":[11576730],"length":1,"stats":{"Line":0}},{"line":111,"address":[11577870,11576864,11577806],"length":1,"stats":{"Line":0}},{"line":112,"address":[11576983,11576907],"length":1,"stats":{"Line":0}},{"line":113,"address":[5782043,5781344,5781409,5781513],"length":1,"stats":{"Line":0}},{"line":114,"address":[10010009],"length":1,"stats":{"Line":0}},{"line":116,"address":[5781914,5781993,5781810],"length":1,"stats":{"Line":0}},{"line":117,"address":[10010147,10010430,10010221],"length":1,"stats":{"Line":0}},{"line":118,"address":[12137394],"length":1,"stats":{"Line":0}},{"line":121,"address":[11578596,11577888,11578620],"length":1,"stats":{"Line":0}},{"line":122,"address":[10010712],"length":1,"stats":{"Line":0}},{"line":123,"address":[11578212,11578317],"length":1,"stats":{"Line":0}},{"line":125,"address":[5782381,5782311,5782509],"length":1,"stats":{"Line":0}},{"line":127,"address":[10866557,10866336],"length":1,"stats":{"Line":0}},{"line":128,"address":[8018912,8018830],"length":1,"stats":{"Line":0}},{"line":130,"address":[8019040,8019052],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":62},{"path":["/","home","vidyootsenthil","Documents","TheValut-nameTBD","crates","node","src","deposit_intents","handler.rs"],"content":"use libp2p::gossipsub::{IdentTopic, Message};\nuse tracing::info;\nuse types::errors::NodeError;\n\nuse crate::{\n    NodeState,\n    db::Db,\n    deposit_intents::{DepositIntent, DepositIntentState},\n    handler::Handler,\n    swarm_manager::{Network, NetworkEvent, SelfRequest, SelfResponse},\n};\n\n#[async_trait::async_trait]\nimpl\u003cN: Network, D: Db\u003e Handler\u003cN, D\u003e for DepositIntentState {\n    async fn handle(\n        \u0026mut self,\n        node: \u0026mut NodeState\u003cN, D\u003e,\n        message: Option\u003cNetworkEvent\u003e,\n    ) -\u003e Result\u003c(), types::errors::NodeError\u003e {\n        match message {\n            Some(NetworkEvent::SelfRequest {\n                request: SelfRequest::CreateDeposit { deposit_intent },\n                response_channel,\n            }) =\u003e {\n                let response = self.create_deposit(node, deposit_intent).await;\n                if let Some(response_channel) = response_channel {\n                    response_channel\n                        .send(SelfResponse::CreateDepositResponse {\n                            success: response.is_ok(),\n                        })\n                        .map_err(|e| NodeError::Error(format!(\"Failed to send response: {}\", e)))?;\n                }\n            }\n            Some(NetworkEvent::SelfRequest {\n                request: SelfRequest::GetPendingDepositIntents,\n                response_channel,\n            }) =\u003e {\n                let response = self.get_pending_deposit_intents();\n                if let Some(response_channel) = response_channel {\n                    response_channel\n                        .send(SelfResponse::GetPendingDepositIntentsResponse { intents: response })\n                        .map_err(|e| NodeError::Error(format!(\"Failed to send response: {}\", e)))?;\n                }\n            }\n            Some(NetworkEvent::GossipsubMessage(Message { data, topic, .. })) =\u003e {\n                if topic == IdentTopic::new(\"deposit-intents\").hash() {\n                    let deposit_intent =\n                        serde_json::from_slice::\u003cDepositIntent\u003e(\u0026data).map_err(|e| {\n                            NodeError::Error(format!(\"Failed to parse deposit intent: {}\", e))\n                        })?;\n\n                    if let Err(e) = self.create_deposit(node, deposit_intent).await {\n                        info!(\"Failed to store deposit intent: {}\", e);\n                    }\n                }\n            }\n            _ =\u003e {}\n        }\n        Ok(())\n    }\n}\n","traces":[{"line":20,"address":[10790279,10790060],"length":1,"stats":{"Line":4}},{"line":21,"address":[7345932],"length":1,"stats":{"Line":2}},{"line":22,"address":[],"length":0,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[8177455],"length":1,"stats":{"Line":4}},{"line":26,"address":[7397936],"length":1,"stats":{"Line":2}},{"line":27,"address":[6105070,6105224],"length":1,"stats":{"Line":2}},{"line":28,"address":[10245641],"length":1,"stats":{"Line":2}},{"line":29,"address":[7398012],"length":1,"stats":{"Line":2}},{"line":31,"address":[10796400,10793464,10796422],"length":1,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[],"length":0,"stats":{"Line":0}},{"line":38,"address":[10791020,10790766],"length":1,"stats":{"Line":0}},{"line":39,"address":[7346412],"length":1,"stats":{"Line":0}},{"line":40,"address":[7346575,7346657,7346756],"length":1,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[6103116,6108160,6108182],"length":1,"stats":{"Line":0}},{"line":45,"address":[10242686],"length":1,"stats":{"Line":1}},{"line":46,"address":[10790468,10792023,10795489,10791785],"length":1,"stats":{"Line":6}},{"line":47,"address":[7352255,7352261,7347588,7347370,7352032,7347466],"length":1,"stats":{"Line":4}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[7352115,7352067],"length":1,"stats":{"Line":0}},{"line":52,"address":[7347772,7345110,7349585,7347945],"length":1,"stats":{"Line":4}},{"line":53,"address":[10247107,10247352,10247012],"length":1,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":59,"address":[],"length":0,"stats":{"Line":4}}],"covered":12,"coverable":29},{"path":["/","home","vidyootsenthil","Documents","TheValut-nameTBD","crates","node","src","deposit_intents","mod.rs"],"content":"use std::collections::HashSet;\n\nuse bincode::{Decode, Encode};\nuse serde::{Deserialize, Serialize};\nuse tokio::sync::broadcast;\n\npub mod handler;\npub mod utils;\n\n#[derive(Debug, Clone, Serialize, Deserialize, Encode, Decode)]\npub struct DepositIntent {\n    pub amount_sat: u64,\n    pub deposit_tracking_id: String,\n    pub deposit_address: String,\n    pub timestamp: u64,\n}\n\npub struct DepositIntentState {\n    pub pending_intents: Vec\u003cDepositIntent\u003e,\n    pub deposit_addresses: HashSet\u003cString\u003e,\n    pub deposit_intent_tx: broadcast::Sender\u003cString\u003e,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","vidyootsenthil","Documents","TheValut-nameTBD","crates","node","src","deposit_intents","utils.rs"],"content":"use std::collections::HashSet;\n\nuse tokio::sync::broadcast;\nuse tracing::error;\n\nuse types::errors::NodeError;\n\nuse crate::{\n    NodeState,\n    db::Db,\n    deposit_intents::{DepositIntent, DepositIntentState},\n    swarm_manager::Network,\n};\n\nimpl DepositIntentState {\n    pub fn new(deposit_intent_tx: broadcast::Sender\u003cString\u003e) -\u003e Self {\n        Self {\n            pending_intents: vec![],\n            deposit_addresses: HashSet::new(),\n            deposit_intent_tx,\n        }\n    }\n\n    pub async fn create_deposit\u003cN: Network, D: Db\u003e(\n        \u0026mut self,\n        node: \u0026mut NodeState\u003cN, D\u003e,\n        deposit_intent: DepositIntent,\n    ) -\u003e Result\u003c(), NodeError\u003e {\n        node.db.insert_deposit_intent(deposit_intent.clone())?;\n\n        if self\n            .deposit_addresses\n            .insert(deposit_intent.deposit_address.clone())\n        {\n            if let Err(e) = self\n                .deposit_intent_tx\n                .send(deposit_intent.deposit_address.clone())\n            {\n                error!(\"Failed to notify deposit monitor of new address: {}\", e);\n            }\n        }\n\n        Ok(())\n    }\n\n    pub fn get_pending_deposit_intents(\u0026self) -\u003e Vec\u003cDepositIntent\u003e {\n        self.pending_intents.clone()\n    }\n}\n","traces":[{"line":16,"address":[7123336,7123342,7123152],"length":1,"stats":{"Line":8}},{"line":18,"address":[9183987],"length":1,"stats":{"Line":3}},{"line":19,"address":[9184038],"length":1,"stats":{"Line":8}},{"line":24,"address":[6257456],"length":1,"stats":{"Line":2}},{"line":29,"address":[9371790,9371687],"length":1,"stats":{"Line":4}},{"line":31,"address":[5834522,5834481],"length":1,"stats":{"Line":4}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[5834490],"length":1,"stats":{"Line":2}},{"line":35,"address":[5834600,5834641],"length":1,"stats":{"Line":4}},{"line":36,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[9029227],"length":1,"stats":{"Line":2}},{"line":39,"address":[8975047,8974802,8974707],"length":1,"stats":{"Line":4}},{"line":43,"address":[9372039],"length":1,"stats":{"Line":2}},{"line":46,"address":[9184192],"length":1,"stats":{"Line":0}},{"line":47,"address":[9184209],"length":1,"stats":{"Line":0}}],"covered":11,"coverable":15},{"path":["/","home","vidyootsenthil","Documents","TheValut-nameTBD","crates","node","src","dkg","handler.rs"],"content":"use tracing::{error, info};\n\nuse crate::{\n    NodeState,\n    db::Db,\n    dkg::DkgState,\n    handler::Handler,\n    swarm_manager::{DirectMessage, Network, NetworkEvent},\n};\n\n#[async_trait::async_trait]\nimpl\u003cN: Network, D: Db\u003e Handler\u003cN, D\u003e for DkgState {\n    async fn handle(\n        \u0026mut self,\n        node: \u0026mut NodeState\u003cN, D\u003e,\n        message: Option\u003cNetworkEvent\u003e,\n    ) -\u003e Result\u003c(), types::errors::NodeError\u003e {\n        match message {\n            Some(NetworkEvent::Subscribed { peer_id, topic }) =\u003e {\n                if topic == self.start_dkg_topic.hash() {\n                    self.dkg_listeners.insert(peer_id);\n                    info!(\n                        \"Peer {} subscribed to topic {topic}. Listeners: {}\",\n                        peer_id,\n                        self.dkg_listeners.len()\n                    );\n                    if let Err(e) = self.handle_dkg_start(node).await {\n                        error!(\"❌ Failed to handle DKG start: {}\", e);\n                    }\n                }\n            }\n            Some(NetworkEvent::GossipsubMessage(message)) =\u003e {\n                if message.topic == self.round1_topic.hash() {\n                    if let Some(source_peer) = message.source {\n                        self.handle_round1_payload(node, source_peer, \u0026message.data)?;\n                    }\n                }\n            }\n            Some(NetworkEvent::MessageEvent((peer, DirectMessage::Round2Package(package)))) =\u003e {\n                self.handle_round2_payload(node, peer, package)?;\n            }\n            _ =\u003e {}\n        }\n        Ok(())\n    }\n}\n","traces":[{"line":18,"address":[],"length":0,"stats":{"Line":4}},{"line":19,"address":[12593413],"length":1,"stats":{"Line":5}},{"line":20,"address":[8446222,8445982],"length":1,"stats":{"Line":6}},{"line":21,"address":[12593933],"length":1,"stats":{"Line":1}},{"line":22,"address":[8447031],"length":1,"stats":{"Line":5}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":27,"address":[8164484],"length":1,"stats":{"Line":4}},{"line":28,"address":[7422584,7422675,7422920],"length":1,"stats":{"Line":0}},{"line":32,"address":[11850298],"length":1,"stats":{"Line":1}},{"line":33,"address":[11850358,11851952],"length":1,"stats":{"Line":2}},{"line":34,"address":[8448205,8447802],"length":1,"stats":{"Line":2}},{"line":35,"address":[7420984],"length":1,"stats":{"Line":1}},{"line":39,"address":[7421421],"length":1,"stats":{"Line":1}},{"line":40,"address":[8448481,8448746],"length":1,"stats":{"Line":1}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":2}}],"covered":13,"coverable":18},{"path":["/","home","vidyootsenthil","Documents","TheValut-nameTBD","crates","node","src","dkg","key_creation.rs"],"content":"use frost_secp256k1::{self as frost, keys::dkg::round2};\nuse libp2p::PeerId;\nuse tracing::{debug, error, info, warn};\nuse types::errors::NodeError;\n\nuse crate::{\n    NodeState,\n    db::Db,\n    dkg::DkgState,\n    peer_id_to_identifier,\n    swarm_manager::{DirectMessage, Network},\n};\n\nimpl DkgState {\n    pub async fn handle_dkg_start\u003cN: Network, D: Db\u003e(\n        \u0026mut self,\n        node: \u0026mut NodeState\u003cN, D\u003e,\n    ) -\u003e Result\u003c(), NodeError\u003e {\n        if self.dkg_started {\n            debug!(\"DKG already started, skipping DKG process\");\n            return Ok(());\n        }\n\n        if node.private_key_package.is_some() \u0026\u0026 node.pubkey_package.is_some() {\n            info!(\"DKG keys already exist, skipping DKG process\");\n            return Ok(());\n        }\n\n        if self.dkg_listeners.len() + 1 != node.max_signers as usize {\n            debug!(\n                \"Not all listeners have subscribed to the DKG topic, not starting DKG process. Listeners: {:?}\",\n                self.dkg_listeners.len()\n            );\n            return Ok(());\n        }\n\n        info!(\"Starting DKG process\");\n\n        self.dkg_started = true;\n\n        // Run the DKG initialization code\n        let participant_identifier = peer_id_to_identifier(\u0026node.peer_id);\n\n        let (round1_secret_package, round1_package) = frost::keys::dkg::part1(\n            participant_identifier,\n            node.max_signers,\n            node.min_signers,\n            node.rng,\n        )\n        .expect(\"Failed to generate round1 package\");\n\n        self.r1_secret_package = Some(round1_secret_package);\n\n        let round1_package_bytes = round1_package\n            .serialize()\n            .expect(\"Failed to serialize round1 package\");\n\n        // Broadcast START_DKG message to the network,\n        let start_message = format!(\"START_DKG:{}\", node.peer_id);\n\n        match node.network_handle.send_broadcast(\n            self.start_dkg_topic.clone(),\n            start_message.as_bytes().to_vec(),\n        ) {\n            Ok(_) =\u003e (),\n            Err(e) =\u003e {\n                return Err(NodeError::Error(format!(\n                    \"Failed to send broadcast: {:?}\",\n                    e\n                )));\n            }\n        }\n\n        match node\n            .network_handle\n            .send_broadcast(self.round1_topic.clone(), round1_package_bytes)\n        {\n            Ok(_) =\u003e (),\n            Err(e) =\u003e {\n                return Err(NodeError::Error(format!(\n                    \"Failed to send broadcast: {:?}\",\n                    e\n                )));\n            }\n        }\n\n        match self.try_enter_round2(node) {\n            Ok(_) =\u003e {\n                info!(\n                    \"Generated and published round1 package in response to DKG start signal from {}\",\n                    \u0026node.peer_id\n                );\n                Ok(())\n            }\n            Err(e) =\u003e Err(NodeError::Error(format!(\"Failed to enter round2: {}\", e))),\n        }\n    }\n\n    pub fn handle_round1_payload\u003cN: Network, D: Db\u003e(\n        \u0026mut self,\n        node: \u0026mut NodeState\u003cN, D\u003e,\n        sender_peer_id: PeerId,\n        package: \u0026[u8],\n    ) -\u003e Result\u003c(), NodeError\u003e {\n        let identifier = peer_id_to_identifier(\u0026sender_peer_id);\n        let package = match frost::keys::dkg::round1::Package::deserialize(package) {\n            Ok(package) =\u003e package,\n            Err(e) =\u003e {\n                return Err(NodeError::Error(format!(\n                    \"Failed to deserialize round1 package: {}\",\n                    e\n                )));\n            }\n        };\n        // Add package to peer packages\n        self.round1_peer_packages.insert(identifier, package);\n\n        debug!(\n            \"Received round1 package from {} ({}/{})\",\n            sender_peer_id,\n            self.round1_peer_packages.len(),\n            node.max_signers - 1\n        );\n\n        self.try_enter_round2(node)?;\n\n        Ok(())\n    }\n\n    pub fn try_enter_round2\u003cN: Network, D: Db\u003e(\n        \u0026mut self,\n        node: \u0026mut NodeState\u003cN, D\u003e,\n    ) -\u003e Result\u003c(), NodeError\u003e {\n        if let Some(r1_secret_package) = self.r1_secret_package.as_ref() {\n            if self.round1_peer_packages.len() + 1 == node.max_signers as usize {\n                info!(\"Received all round1 packages, entering part2\");\n                // all packages received\n                let part2_result =\n                    frost::keys::dkg::part2(r1_secret_package.clone(), \u0026self.round1_peer_packages);\n                match part2_result {\n                    Ok((round2_secret_package, round2_packages)) =\u003e {\n                        info!(\"-------------------- ENTERING ROUND 2 ---------------------\");\n                        self.r1_secret_package = None;\n                        self.r2_secret_package = Some(round2_secret_package);\n\n                        for peer_to_send_to in self.dkg_listeners.iter() {\n                            let identifier = peer_id_to_identifier(peer_to_send_to);\n                            let package_to_send = match round2_packages.get(\u0026identifier) {\n                                Some(package) =\u003e package,\n                                None =\u003e {\n                                    warn!(\"Round2 package not found for {}\", peer_to_send_to);\n                                    return Err(NodeError::Error(format!(\n                                        \"Round2 package not found for {}\",\n                                        peer_to_send_to\n                                    )));\n                                }\n                            };\n\n                            let request = DirectMessage::Round2Package(package_to_send.clone());\n\n                            match node\n                                .network_handle\n                                .send_private_message(*peer_to_send_to, request)\n                            {\n                                Ok(_) =\u003e {\n                                    debug!(\n                                        \"{} Sent round2 package to {}\",\n                                        node.peer_id, peer_to_send_to\n                                    );\n                                }\n                                Err(e) =\u003e {\n                                    error!(\"Round2 package not found for {}\", peer_to_send_to);\n                                    return Err(NodeError::Error(format!(\n                                        \"Failed to send private request: {:?}\",\n                                        e\n                                    )));\n                                }\n                            }\n\n                            debug!(\"Sent round2 package to {}\", peer_to_send_to);\n                        }\n                    }\n                    Err(e) =\u003e {\n                        return Err(NodeError::Error(format!(\"DKG round2 failed: {}\", e)));\n                    }\n                }\n            }\n        }\n\n        Ok(())\n    }\n\n    pub fn handle_round2_payload\u003cN: Network, D: Db\u003e(\n        \u0026mut self,\n        node: \u0026mut NodeState\u003cN, D\u003e,\n        sender_peer_id: PeerId,\n        package: round2::Package,\n    ) -\u003e Result\u003c(), NodeError\u003e {\n        let identifier = peer_id_to_identifier(\u0026sender_peer_id);\n\n        match node\n            .network_handle\n            .send_private_message(sender_peer_id, DirectMessage::Pong)\n        {\n            Ok(_) =\u003e (),\n            Err(e) =\u003e {\n                return Err(NodeError::Error(format!(\n                    \"Failed to send private response: {:?}\",\n                    e\n                )));\n            }\n        }\n\n        // Add package to peer packages\n        self.round2_peer_packages.insert(identifier, package);\n\n        debug!(\n            \"Received round2 package from {} ({}/{})\",\n            sender_peer_id,\n            self.round2_peer_packages.len(),\n            node.max_signers - 1\n        );\n        if let Some(r2_secret_package) = self.r2_secret_package.as_ref() {\n            if self.round2_peer_packages.len() + 1 == node.max_signers as usize {\n                info!(\"Received all round2 packages, entering part3\");\n                let part3_result = frost::keys::dkg::part3(\n                    \u0026r2_secret_package.clone(),\n                    \u0026self.round1_peer_packages,\n                    \u0026self.round2_peer_packages,\n                );\n\n                match part3_result {\n                    Ok((private_key_package, pubkey_package)) =\u003e {\n                        info!(\n                            \"🎉 DKG finished successfully. Public key: {:?}\",\n                            pubkey_package.verifying_key()\n                        );\n\n                        self.save_dkg_keys(node, \u0026private_key_package, \u0026pubkey_package)?;\n\n                        self.dkg_started = false;\n                    }\n                    Err(e) =\u003e {\n                        error!(\"DKG failed during part3 aggregation: {}\", e);\n                        // Reset state so that a fresh DKG can be attempted again later\n                        self.reset_dkg_state();\n                    }\n                }\n            }\n        }\n\n        Ok(())\n    }\n\n    /// Reset DKG state after a failed run so that a new DKG round can be initiated.\n    fn reset_dkg_state(\u0026mut self) {\n        self.dkg_started = false;\n        self.r1_secret_package = None;\n        self.r2_secret_package = None;\n        self.round1_peer_packages.clear();\n        self.round2_peer_packages.clear();\n    }\n}\n","traces":[{"line":15,"address":[6562576],"length":1,"stats":{"Line":5}},{"line":19,"address":[12307984],"length":1,"stats":{"Line":5}},{"line":20,"address":[],"length":0,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":8}},{"line":25,"address":[],"length":0,"stats":{"Line":2}},{"line":26,"address":[5964334],"length":1,"stats":{"Line":1}},{"line":29,"address":[12308149,12308260],"length":1,"stats":{"Line":7}},{"line":30,"address":[12313166],"length":1,"stats":{"Line":0}},{"line":31,"address":[],"length":0,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":34,"address":[6277525],"length":1,"stats":{"Line":2}},{"line":37,"address":[],"length":0,"stats":{"Line":7}},{"line":39,"address":[12639218],"length":1,"stats":{"Line":3}},{"line":42,"address":[6273273],"length":1,"stats":{"Line":2}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":52,"address":[9084017,9084240],"length":1,"stats":{"Line":3}},{"line":54,"address":[],"length":0,"stats":{"Line":4}},{"line":59,"address":[12309872,12309939],"length":1,"stats":{"Line":4}},{"line":61,"address":[],"length":0,"stats":{"Line":4}},{"line":62,"address":[12640667,12640613],"length":1,"stats":{"Line":3}},{"line":63,"address":[12640683,12640763],"length":1,"stats":{"Line":3}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[12640878],"length":1,"stats":{"Line":0}},{"line":67,"address":[6274950,6276890],"length":1,"stats":{"Line":0}},{"line":68,"address":[],"length":0,"stats":{"Line":0}},{"line":69,"address":[],"length":0,"stats":{"Line":0}},{"line":74,"address":[],"length":0,"stats":{"Line":4}},{"line":75,"address":[],"length":0,"stats":{"Line":0}},{"line":76,"address":[5961153,5961082],"length":1,"stats":{"Line":4}},{"line":78,"address":[],"length":0,"stats":{"Line":0}},{"line":79,"address":[6275193],"length":1,"stats":{"Line":0}},{"line":80,"address":[5961309,5962697],"length":1,"stats":{"Line":0}},{"line":81,"address":[],"length":0,"stats":{"Line":0}},{"line":82,"address":[],"length":0,"stats":{"Line":0}},{"line":87,"address":[6275279],"length":1,"stats":{"Line":3}},{"line":88,"address":[],"length":0,"stats":{"Line":0}},{"line":89,"address":[],"length":0,"stats":{"Line":1}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[5961745],"length":1,"stats":{"Line":5}},{"line":95,"address":[5961387,5962274],"length":1,"stats":{"Line":0}},{"line":99,"address":[6571312,6569472,6571344],"length":1,"stats":{"Line":1}},{"line":105,"address":[],"length":0,"stats":{"Line":1}},{"line":106,"address":[9397456],"length":1,"stats":{"Line":1}},{"line":107,"address":[6569966],"length":1,"stats":{"Line":1}},{"line":108,"address":[9506855],"length":1,"stats":{"Line":0}},{"line":109,"address":[9506885],"length":1,"stats":{"Line":0}},{"line":110,"address":[],"length":0,"stats":{"Line":0}},{"line":111,"address":[],"length":0,"stats":{"Line":0}},{"line":116,"address":[8588763,8588602],"length":1,"stats":{"Line":2}},{"line":118,"address":[],"length":0,"stats":{"Line":1}},{"line":119,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[12116557,12116732,12115897],"length":1,"stats":{"Line":2}},{"line":127,"address":[8589820],"length":1,"stats":{"Line":1}},{"line":130,"address":[8589904,8596686,8596692],"length":1,"stats":{"Line":2}},{"line":134,"address":[9399266],"length":1,"stats":{"Line":3}},{"line":135,"address":[8590132,8590058],"length":1,"stats":{"Line":7}},{"line":136,"address":[6562864,6563145],"length":1,"stats":{"Line":1}},{"line":138,"address":[9508984],"length":1,"stats":{"Line":1}},{"line":139,"address":[],"length":0,"stats":{"Line":0}},{"line":140,"address":[8590393],"length":1,"stats":{"Line":1}},{"line":141,"address":[12117949],"length":1,"stats":{"Line":1}},{"line":142,"address":[9400501,9400580,9400889],"length":1,"stats":{"Line":3}},{"line":143,"address":[8592004,8591563],"length":1,"stats":{"Line":2}},{"line":144,"address":[6565073,6564847],"length":1,"stats":{"Line":1}},{"line":146,"address":[12119404],"length":1,"stats":{"Line":2}},{"line":147,"address":[12119573],"length":1,"stats":{"Line":1}},{"line":148,"address":[9511474],"length":1,"stats":{"Line":2}},{"line":149,"address":[6565615],"length":1,"stats":{"Line":1}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":151,"address":[12120164,12119834],"length":1,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":0}},{"line":154,"address":[],"length":0,"stats":{"Line":0}},{"line":159,"address":[9403267,9402228],"length":1,"stats":{"Line":3}},{"line":161,"address":[9403401,9403327],"length":1,"stats":{"Line":4}},{"line":162,"address":[],"length":0,"stats":{"Line":0}},{"line":163,"address":[6566733],"length":1,"stats":{"Line":1}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":1}},{"line":167,"address":[],"length":0,"stats":{"Line":0}},{"line":168,"address":[],"length":0,"stats":{"Line":0}},{"line":171,"address":[],"length":0,"stats":{"Line":0}},{"line":172,"address":[9405358,9405105,9403505],"length":1,"stats":{"Line":0}},{"line":173,"address":[9405798,9405328],"length":1,"stats":{"Line":0}},{"line":174,"address":[],"length":0,"stats":{"Line":0}},{"line":175,"address":[],"length":0,"stats":{"Line":0}},{"line":180,"address":[12121974,12121420],"length":1,"stats":{"Line":3}},{"line":183,"address":[12117697],"length":1,"stats":{"Line":0}},{"line":184,"address":[9400143],"length":1,"stats":{"Line":0}},{"line":190,"address":[9399395],"length":1,"stats":{"Line":3}},{"line":193,"address":[12123680,12127191,12127919],"length":1,"stats":{"Line":1}},{"line":199,"address":[9515522],"length":1,"stats":{"Line":1}},{"line":201,"address":[9515587,9515560],"length":1,"stats":{"Line":2}},{"line":202,"address":[],"length":0,"stats":{"Line":0}},{"line":203,"address":[9406231],"length":1,"stats":{"Line":1}},{"line":205,"address":[],"length":0,"stats":{"Line":0}},{"line":206,"address":[],"length":0,"stats":{"Line":0}},{"line":207,"address":[6571631,6575657],"length":1,"stats":{"Line":0}},{"line":208,"address":[],"length":0,"stats":{"Line":0}},{"line":209,"address":[],"length":0,"stats":{"Line":0}},{"line":215,"address":[8597048],"length":1,"stats":{"Line":1}},{"line":217,"address":[6572641,6572218],"length":1,"stats":{"Line":0}},{"line":218,"address":[],"length":0,"stats":{"Line":0}},{"line":219,"address":[],"length":0,"stats":{"Line":0}},{"line":220,"address":[],"length":0,"stats":{"Line":0}},{"line":221,"address":[],"length":0,"stats":{"Line":0}},{"line":223,"address":[],"length":0,"stats":{"Line":2}},{"line":224,"address":[9407498,9410320,9407424],"length":1,"stats":{"Line":4}},{"line":225,"address":[9407525,9407789],"length":1,"stats":{"Line":1}},{"line":227,"address":[6572971],"length":1,"stats":{"Line":1}},{"line":228,"address":[9517094],"length":1,"stats":{"Line":1}},{"line":229,"address":[6573022],"length":1,"stats":{"Line":1}},{"line":232,"address":[],"length":0,"stats":{"Line":1}},{"line":233,"address":[6573695],"length":1,"stats":{"Line":2}},{"line":234,"address":[12126603],"length":1,"stats":{"Line":3}},{"line":235,"address":[],"length":0,"stats":{"Line":0}},{"line":236,"address":[],"length":0,"stats":{"Line":0}},{"line":239,"address":[6574105,6574590],"length":1,"stats":{"Line":3}},{"line":241,"address":[12127059],"length":1,"stats":{"Line":1}},{"line":243,"address":[],"length":0,"stats":{"Line":0}},{"line":244,"address":[9408367,9409620,9409865],"length":1,"stats":{"Line":0}},{"line":246,"address":[6575104,6575556],"length":1,"stats":{"Line":0}},{"line":252,"address":[],"length":0,"stats":{"Line":1}},{"line":256,"address":[6003712,6004020],"length":1,"stats":{"Line":0}},{"line":257,"address":[6003731],"length":1,"stats":{"Line":0}},{"line":258,"address":[11642772,11642796],"length":1,"stats":{"Line":0}},{"line":259,"address":[5910689,5910716],"length":1,"stats":{"Line":0}},{"line":260,"address":[5910792],"length":1,"stats":{"Line":0}},{"line":261,"address":[5910809],"length":1,"stats":{"Line":0}}],"covered":66,"coverable":137},{"path":["/","home","vidyootsenthil","Documents","TheValut-nameTBD","crates","node","src","dkg","mod.rs"],"content":"use std::collections::{BTreeMap, HashSet};\n\nuse frost_secp256k1::{\n    Identifier,\n    keys::dkg::{round1, round2},\n};\nuse libp2p::PeerId;\n\npub mod handler;\npub mod key_creation;\npub mod utils;\n\npub struct DkgState {\n    pub dkg_started: bool,\n    pub dkg_listeners: HashSet\u003cPeerId\u003e,\n\n    pub start_dkg_topic: libp2p::gossipsub::IdentTopic,\n    pub round1_topic: libp2p::gossipsub::IdentTopic,\n\n    pub round1_peer_packages: BTreeMap\u003cIdentifier, round1::Package\u003e,\n    pub round2_peer_packages: BTreeMap\u003cIdentifier, round2::Package\u003e,\n\n    pub r1_secret_package: Option\u003cround1::SecretPackage\u003e,\n    pub r2_secret_package: Option\u003cround2::SecretPackage\u003e,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","vidyootsenthil","Documents","TheValut-nameTBD","crates","node","src","dkg","utils.rs"],"content":"use std::collections::{BTreeMap, HashSet};\n\nuse base64::{Engine as _, engine::general_purpose::STANDARD as BASE64};\nuse frost_secp256k1::{self as frost};\nuse libp2p::gossipsub;\nuse protocol::block::{ChainConfig, GenesisBlock, ValidatorInfo};\n\nuse crate::{\n    DkgKeys, EncryptionParams, NodeConfig, NodeState,\n    db::Db,\n    dkg::DkgState,\n    key_manager::{decrypt_private_key, encrypt_private_key, get_password_from_prompt},\n    swarm_manager::Network,\n};\nuse types::errors::NodeError;\n\nimpl DkgState {\n    pub fn new() -\u003e Result\u003cSelf, NodeError\u003e {\n        Ok(DkgState {\n            dkg_listeners: HashSet::new(),\n            start_dkg_topic: gossipsub::IdentTopic::new(\"start-dkg\"),\n            round1_topic: gossipsub::IdentTopic::new(\"round1_topic\"),\n            round1_peer_packages: BTreeMap::new(),\n            round2_peer_packages: BTreeMap::new(),\n            r1_secret_package: None,\n            r2_secret_package: None,\n            dkg_started: false,\n        })\n    }\n\n    pub fn load_dkg_keys(\n        config: NodeConfig,\n    ) -\u003e Result\u003c\n        Option\u003c(frost::keys::KeyPackage, frost::keys::PublicKeyPackage)\u003e,\n        Box\u003cdyn std::error::Error\u003e,\n    \u003e {\n        if let Some(dkg_keys) = config.dkg_keys {\n            let password = get_password_from_prompt()?;\n\n            // Decrypt the private key package\n            let private_key_bytes = decrypt_private_key(\n                \u0026dkg_keys.encrypted_private_key_package_b64,\n                \u0026password,\n                \u0026dkg_keys.dkg_encryption_params,\n            )?;\n\n            // Deserialize the private key from decrypted bytes\n            let private_key = frost::keys::KeyPackage::deserialize(\u0026private_key_bytes)?;\n\n            // Deserialize the public key from base64\n            let pubkey_bytes = BASE64.decode(\u0026dkg_keys.pubkey_package_b64)?;\n            let pubkey = frost::keys::PublicKeyPackage::deserialize(\u0026pubkey_bytes)?;\n\n            Ok(Some((private_key, pubkey)))\n        } else {\n            Ok(None)\n        }\n    }\n\n    pub fn save_dkg_keys\u003cN: Network, D: Db\u003e(\n        \u0026mut self,\n        node: \u0026mut NodeState\u003cN, D\u003e,\n        private_key: \u0026frost::keys::KeyPackage,\n        pubkey: \u0026frost::keys::PublicKeyPackage,\n    ) -\u003e Result\u003c(), NodeError\u003e {\n        node.private_key_package = Some(private_key.clone());\n        node.pubkey_package = Some(pubkey.clone());\n\n        let password = match std::env::var(\"KEY_PASSWORD\") {\n            Ok(pw) =\u003e pw,\n            Err(_) =\u003e get_password_from_prompt()?,\n        };\n\n        // Serialize private key to bytes\n        let private_key_bytes = private_key\n            .serialize()\n            .map_err(|e| NodeError::Error(format!(\"Failed to serialize private key: {}\", e)))?;\n\n        // Use existing salt from key_data, or generate a new one if empty\n        let salt_b64 = if node.config.key_data.encryption_params.salt_b64.is_empty() {\n            // Generate a new salt\n            use frost::rand_core::RngCore;\n            let mut salt = [0u8; 16];\n            frost::rand_core::OsRng.fill_bytes(\u0026mut salt);\n            BASE64.encode(salt)\n        } else {\n            node.config.key_data.encryption_params.salt_b64.clone()\n        };\n\n        // Encrypt the private key package\n        let (encrypted_private_key_b64, iv_b64) =\n            encrypt_private_key(\u0026private_key_bytes, \u0026password, \u0026salt_b64)\n                .map_err(|e| NodeError::Error(format!(\"Failed to encrypt private key: {}\", e)))?;\n\n        // Serialize and base64 encode the public key package\n        let pubkey_bytes = pubkey\n            .serialize()\n            .map_err(|e| NodeError::Error(format!(\"Failed to serialize public key: {}\", e)))?;\n        let pubkey_package_b64 = BASE64.encode(pubkey_bytes);\n\n        node.config.set_dkg_keys(DkgKeys {\n            encrypted_private_key_package_b64: encrypted_private_key_b64,\n            dkg_encryption_params: EncryptionParams {\n                kdf: \"argon2id\".to_string(),\n                salt_b64,\n                iv_b64,\n            },\n            pubkey_package_b64,\n        });\n\n        let mut validators: Vec\u003cValidatorInfo\u003e = node\n            .peers\n            .iter()\n            .map(|peer_id| ValidatorInfo {\n                pub_key: peer_id.to_bytes(),\n                stake: 100,\n            })\n            .collect();\n\n        validators.sort_by(|a, b| a.pub_key.cmp(\u0026b.pub_key));\n\n        let chain_config = ChainConfig {\n            block_time_seconds: 10,\n            min_signers: node.min_signers,\n            max_signers: node.max_signers,\n            min_stake: 100,\n            max_block_size: 1000,\n        };\n\n        let genesis_block = GenesisBlock::new(\n            validators,\n            chain_config,\n            pubkey\n                .serialize()\n                .map_err(|e| NodeError::Error(format!(\"Failed to serialize public key: {}\", e)))?,\n        );\n\n        node.db.insert_block(genesis_block.to_block())?;\n\n        node.config.save_to_file()?;\n        Ok(())\n    }\n}\n","traces":[{"line":18,"address":[5911491,5910848,5911485],"length":1,"stats":{"Line":3}},{"line":19,"address":[11643408],"length":1,"stats":{"Line":3}},{"line":20,"address":[11643088],"length":1,"stats":{"Line":7}},{"line":21,"address":[5910881],"length":1,"stats":{"Line":2}},{"line":22,"address":[5910956],"length":1,"stats":{"Line":6}},{"line":23,"address":[5911028],"length":1,"stats":{"Line":2}},{"line":24,"address":[8851344],"length":1,"stats":{"Line":6}},{"line":25,"address":[5911148],"length":1,"stats":{"Line":3}},{"line":26,"address":[6004342],"length":1,"stats":{"Line":6}},{"line":31,"address":[5913530,5911504,5913902],"length":1,"stats":{"Line":0}},{"line":37,"address":[11643771,11644016],"length":1,"stats":{"Line":0}},{"line":38,"address":[11645804,11644065,11643963],"length":1,"stats":{"Line":0}},{"line":42,"address":[5912023],"length":1,"stats":{"Line":0}},{"line":43,"address":[11644342],"length":1,"stats":{"Line":0}},{"line":44,"address":[6005323],"length":1,"stats":{"Line":0}},{"line":48,"address":[8852612,8852695,8853794],"length":1,"stats":{"Line":0}},{"line":51,"address":[11644903,11645760],"length":1,"stats":{"Line":0}},{"line":52,"address":[6006026,6006117],"length":1,"stats":{"Line":0}},{"line":54,"address":[6006387],"length":1,"stats":{"Line":0}},{"line":56,"address":[8852022],"length":1,"stats":{"Line":0}},{"line":60,"address":[6579945,6575872,6580339],"length":1,"stats":{"Line":1}},{"line":66,"address":[9410714],"length":1,"stats":{"Line":2}},{"line":67,"address":[9520242,9520332],"length":1,"stats":{"Line":1}},{"line":69,"address":[12128657],"length":1,"stats":{"Line":2}},{"line":70,"address":[12128719],"length":1,"stats":{"Line":1}},{"line":71,"address":[],"length":0,"stats":{"Line":0}},{"line":75,"address":[12132708,12129118,12129181,12129289],"length":1,"stats":{"Line":3}},{"line":77,"address":[11543312,11543328],"length":1,"stats":{"Line":0}},{"line":80,"address":[12129390,12129456,12129634],"length":1,"stats":{"Line":3}},{"line":83,"address":[8602464],"length":1,"stats":{"Line":0}},{"line":84,"address":[6577167],"length":1,"stats":{"Line":0}},{"line":85,"address":[9521336],"length":1,"stats":{"Line":0}},{"line":87,"address":[8602507,8602438],"length":1,"stats":{"Line":3}},{"line":91,"address":[],"length":0,"stats":{"Line":3}},{"line":92,"address":[],"length":0,"stats":{"Line":0}},{"line":93,"address":[6577577],"length":1,"stats":{"Line":0}},{"line":96,"address":[8605327,8603138,8603074,8603222],"length":1,"stats":{"Line":4}},{"line":98,"address":[12130254],"length":1,"stats":{"Line":0}},{"line":99,"address":[6578039,6578162],"length":1,"stats":{"Line":4}},{"line":101,"address":[9522278,9522625],"length":1,"stats":{"Line":4}},{"line":102,"address":[12130529],"length":1,"stats":{"Line":2}},{"line":103,"address":[6578379],"length":1,"stats":{"Line":2}},{"line":104,"address":[8603497],"length":1,"stats":{"Line":2}},{"line":105,"address":[],"length":0,"stats":{"Line":2}},{"line":106,"address":[9413105],"length":1,"stats":{"Line":2}},{"line":108,"address":[6578475],"length":1,"stats":{"Line":2}},{"line":111,"address":[8604001],"length":1,"stats":{"Line":2}},{"line":112,"address":[],"length":0,"stats":{"Line":0}},{"line":114,"address":[5731511,5731424],"length":1,"stats":{"Line":4}},{"line":115,"address":[12103614],"length":1,"stats":{"Line":2}},{"line":116,"address":[],"length":0,"stats":{"Line":0}},{"line":120,"address":[6578887,6578807],"length":1,"stats":{"Line":7}},{"line":124,"address":[9523032],"length":1,"stats":{"Line":2}},{"line":125,"address":[8604187],"length":1,"stats":{"Line":2}},{"line":131,"address":[],"length":0,"stats":{"Line":2}},{"line":132,"address":[],"length":0,"stats":{"Line":0}},{"line":133,"address":[9413865,9413973,9413802],"length":1,"stats":{"Line":3}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[8702720,8702704],"length":1,"stats":{"Line":0}},{"line":138,"address":[8604719,8605164,8604618],"length":1,"stats":{"Line":5}},{"line":140,"address":[],"length":0,"stats":{"Line":1}},{"line":141,"address":[],"length":0,"stats":{"Line":1}}],"covered":38,"coverable":62},{"path":["/","home","vidyootsenthil","Documents","TheValut-nameTBD","crates","node","src","grpc","grpc_handler.rs"],"content":"use crate::swarm_manager::NetworkHandle;\nuse tonic::{Request, Response, Status};\n\nuse crate::grpc::grpc_operator;\n\n// Include the generated proto code\npub mod node_proto {\n    tonic::include_proto!(\"node\");\n}\n\nuse node_proto::{\n    node_control_server::{NodeControl, NodeControlServer},\n    *,\n};\n\npub struct NodeControlService {\n    network: NetworkHandle,\n}\n\nimpl NodeControlService {\n    pub fn new(network: NetworkHandle) -\u003e Self {\n        Self { network }\n    }\n\n    pub fn into_server(self) -\u003e NodeControlServer\u003cSelf\u003e {\n        NodeControlServer::new(self)\n    }\n}\n\n#[tonic::async_trait]\nimpl NodeControl for NodeControlService {\n    async fn spend_funds(\n        \u0026self,\n        request: Request\u003cSpendFundsRequest\u003e,\n    ) -\u003e Result\u003cResponse\u003cSpendFundsResponse\u003e, Status\u003e {\n        let request = request.into_inner();\n        let response = grpc_operator::spend_funds(\u0026self.network, request).await?;\n\n        Ok(Response::new(response))\n    }\n\n    async fn start_signing(\n        \u0026self,\n        request: Request\u003cStartSigningRequest\u003e,\n    ) -\u003e Result\u003cResponse\u003cStartSigningResponse\u003e, Status\u003e {\n        let request = request.into_inner();\n        let response = grpc_operator::start_signing(\u0026self.network, request).await?;\n\n        Ok(Response::new(response))\n    }\n\n    async fn create_deposit_intent(\n        \u0026self,\n        request: Request\u003cCreateDepositIntentRequest\u003e,\n    ) -\u003e Result\u003cResponse\u003cCreateDepositIntentResponse\u003e, Status\u003e {\n        let request = request.into_inner();\n        let response = grpc_operator::create_deposit_intent(\u0026self.network, request).await?;\n\n        Ok(Response::new(response))\n    }\n\n    async fn get_pending_deposit_intents(\n        \u0026self,\n        _request: Request\u003cGetPendingDepositIntentsRequest\u003e,\n    ) -\u003e Result\u003cResponse\u003cGetPendingDepositIntentsResponse\u003e, Status\u003e {\n        let response = grpc_operator::get_pending_deposit_intents(\u0026self.network).await?;\n        Ok(Response::new(response))\n    }\n}\n","traces":[{"line":21,"address":[8032160],"length":1,"stats":{"Line":0}},{"line":25,"address":[8907024],"length":1,"stats":{"Line":0}},{"line":26,"address":[8907032],"length":1,"stats":{"Line":0}},{"line":36,"address":[8522713],"length":1,"stats":{"Line":0}},{"line":37,"address":[9043853,9043915,9043607,9044026],"length":1,"stats":{"Line":0}},{"line":39,"address":[11846306,11846446],"length":1,"stats":{"Line":0}},{"line":46,"address":[9045353],"length":1,"stats":{"Line":0}},{"line":47,"address":[7554749],"length":1,"stats":{"Line":0}},{"line":49,"address":[8524760,8524880],"length":1,"stats":{"Line":0}},{"line":56,"address":[8525577],"length":1,"stats":{"Line":0}},{"line":57,"address":[11848359,11848671,11848830,11848725],"length":1,"stats":{"Line":0}},{"line":59,"address":[9047646,9047490],"length":1,"stats":{"Line":0}},{"line":66,"address":[8165185],"length":1,"stats":{"Line":0}},{"line":67,"address":[9048906,9049014],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":14},{"path":["/","home","vidyootsenthil","Documents","TheValut-nameTBD","crates","node","src","grpc","grpc_operator.rs"],"content":"use crate::deposit_intents::DepositIntent;\nuse crate::grpc::grpc_handler::node_proto::{\n    self, CreateDepositIntentRequest, CreateDepositIntentResponse,\n    GetPendingDepositIntentsResponse, SpendFundsRequest, SpendFundsResponse, StartSigningRequest,\n    StartSigningResponse,\n};\nuse crate::swarm_manager::{Network, NetworkHandle, SelfRequest, SelfResponse};\nuse bitcoin::Address;\nuse bitcoin::hashes::Hash;\nuse bitcoin::secp256k1::Scalar;\nuse libp2p::gossipsub::IdentTopic;\nuse serde_json;\nuse std::str::FromStr;\nuse tonic::Status;\nuse tracing::{debug, info};\nuse uuid::Uuid;\n\npub async fn spend_funds(\n    network: \u0026NetworkHandle,\n    request: SpendFundsRequest,\n) -\u003e Result\u003cSpendFundsResponse, Status\u003e {\n    let amount_sat = request.amount_satoshis;\n    let address_to = request.address_to;\n\n    debug!(\"Received request to spend {} satoshis\", amount_sat);\n    let response = network\n        .send_self_request(\n            SelfRequest::Spend {\n                amount_sat,\n                address_to,\n            },\n            true,\n        )\n        .map_err(|e| Status::internal(format!(\"Network error: {:?}\", e)))?\n        .ok_or(Status::internal(\"No response from node\"))?\n        .await\n        .map_err(|e| Status::internal(format!(\"Network error: {:?}\", e)))?;\n\n    let SelfResponse::SpendRequestSent { sighash } = response else {\n        return Err(Status::internal(\"Invalid response from node\"));\n    };\n\n    Ok(SpendFundsResponse {\n        success: true,\n        message: format!(\"Spending {} satoshis\", amount_sat),\n        sighash: sighash.to_string(),\n    })\n}\n\npub async fn start_signing(\n    network: \u0026NetworkHandle,\n    request: StartSigningRequest,\n) -\u003e Result\u003cStartSigningResponse, Status\u003e {\n    let hex_msg = request.hex_message;\n\n    let network_request = SelfRequest::StartSigningSession {\n        hex_message: hex_msg.clone(),\n    };\n\n    let response = network\n        .send_self_request(network_request, true)\n        .map_err(|e| Status::internal(format!(\"Network error: {:?}\", e)))?\n        .ok_or(Status::internal(\"No response from node\"))?\n        .await\n        .map_err(|e| Status::internal(format!(\"Network error: {:?}\", e)))?;\n\n    let SelfResponse::StartSigningSessionResponse { sign_id } = response else {\n        return Err(Status::internal(format!(\n            \"Invalid response from node {:?}\",\n            response\n        )));\n    };\n\n    Ok(StartSigningResponse {\n        success: true,\n        message: \"Signing session started\".to_string(),\n        sign_id,\n    })\n}\n\npub async fn create_deposit_intent(\n    network: \u0026impl Network,\n    request: CreateDepositIntentRequest,\n) -\u003e Result\u003cCreateDepositIntentResponse, Status\u003e {\n    let req = request;\n\n    let amount_sat = if req.amount_satoshis \u003e 0 {\n        req.amount_satoshis\n    } else {\n        return Err(Status::invalid_argument(\n            \"Amount to deposit must be greater than 0\",\n        ));\n    };\n\n    let deposit_tracking_id = Uuid::new_v4().to_string();\n    let frost_pubkey_hex = network\n        .send_self_request(SelfRequest::GetFrostPublicKey, true)\n        .map_err(|e| Status::internal(format!(\"Network error: {:?}\", e)))?\n        .ok_or(Status::internal(\"No response from node\"))?\n        .await\n        .map_err(|e| Status::internal(format!(\"Network error: {:?}\", e)))?;\n\n    let SelfResponse::GetFrostPublicKeyResponse {\n        public_key: Some(public_key),\n    } = frost_pubkey_hex\n    else {\n        return Err(Status::internal(\n            \"Invalid response from node. No public key found.\",\n        ));\n    };\n\n    let public_key = bitcoin::PublicKey::from_str(\u0026public_key)\n        .map_err(|e| Status::internal(format!(\"Failed to parse public key: {}\", e)))?;\n\n    let secp = bitcoin::secp256k1::Secp256k1::new();\n\n    let internal_key = public_key.inner.x_only_public_key().0;\n\n    let tweak_scalar = Scalar::from_be_bytes(\n        bitcoin::hashes::sha256::Hash::hash(deposit_tracking_id.as_bytes()).to_byte_array(),\n    )\n    .expect(\"32 bytes, should not fail\");\n\n    let (tweaked_key, _) = internal_key\n        .add_tweak(\u0026secp, \u0026tweak_scalar)\n        .map_err(|e| Status::internal(format!(\"Failed to add tweak: {:?}\", e)))?;\n\n    let deposit_address = Address::p2tr(\u0026secp, tweaked_key, None, bitcoin::Network::Testnet);\n\n    let deposit_intent = DepositIntent {\n        amount_sat,\n        deposit_tracking_id: deposit_tracking_id.clone(),\n        deposit_address: deposit_address.to_string(),\n        timestamp: std::time::SystemTime::now()\n            .duration_since(std::time::UNIX_EPOCH)\n            .unwrap()\n            .as_secs(),\n    };\n\n    let _ = network\n        .send_self_request(SelfRequest::CreateDeposit { deposit_intent }, true)\n        .map_err(|e| Status::internal(format!(\"Network error: {:?}\", e)))?\n        .ok_or(Status::internal(\"No response from node\"))?\n        .await\n        .map_err(|e| Status::internal(format!(\"Network error: {:?}\", e)))?;\n\n    let broadcast_message = serde_json::json!({\n        \"deposit_address\": deposit_address.to_string(),\n        \"amount_sat\": amount_sat,\n        \"deposit_tracking_id\": deposit_tracking_id,\n        \"timestamp\": std::time::SystemTime::now()\n            .duration_since(std::time::UNIX_EPOCH)\n            .unwrap()\n            .as_secs()\n    });\n\n    if let Err(e) = network.send_broadcast(\n        IdentTopic::new(\"deposit-intents\"),\n        broadcast_message.to_string().as_bytes().to_vec(),\n    ) {\n        info!(\"Failed to broadcast new deposit address: {:?}\", e);\n    }\n\n    info!(\n        \"Received request to create deposit intent with amount {}. Tracking ID: {}. Deposit Address: {}\",\n        amount_sat,\n        deposit_tracking_id.clone(),\n        deposit_address.clone().to_string()\n    );\n\n    Ok(CreateDepositIntentResponse {\n        success: true,\n        message: \"Deposit intent created\".to_string(),\n        deposit_tracking_id,\n        deposit_address: deposit_address.to_string(),\n    })\n}\n\npub async fn get_pending_deposit_intents(\n    network: \u0026impl Network,\n) -\u003e Result\u003cGetPendingDepositIntentsResponse, Status\u003e {\n    let intents = network\n        .send_self_request(SelfRequest::GetPendingDepositIntents, true)\n        .map_err(|e| Status::internal(format!(\"Network error: {:?}\", e)))?\n        .ok_or(Status::internal(\"No response from node\"))?\n        .await\n        .map_err(|e| Status::internal(format!(\"Network error: {:?}\", e)))?;\n\n    let SelfResponse::GetPendingDepositIntentsResponse { intents } = intents else {\n        return Err(Status::internal(\"Invalid response from node\"));\n    };\n\n    Ok(GetPendingDepositIntentsResponse {\n        intents: intents\n            .iter()\n            .map(|intent| node_proto::DepositIntent {\n                amount_satoshis: intent.amount_sat,\n                deposit_tracking_id: intent.deposit_tracking_id.clone(),\n                deposit_address: intent.deposit_address.clone(),\n                timestamp: intent.timestamp,\n            })\n            .collect(),\n    })\n}\n","traces":[{"line":18,"address":[11475440],"length":1,"stats":{"Line":0}},{"line":22,"address":[11792167],"length":1,"stats":{"Line":0}},{"line":23,"address":[8973739],"length":1,"stats":{"Line":0}},{"line":25,"address":[7398088,7397594,7397720],"length":1,"stats":{"Line":0}},{"line":26,"address":[12226745,12227261,12229312,12227692,12227913,12227626,12227567,12228253,12227857,12228375,12228195,12227768,12227404],"length":1,"stats":{"Line":0}},{"line":28,"address":[11792639],"length":1,"stats":{"Line":0}},{"line":29,"address":[8974140],"length":1,"stats":{"Line":0}},{"line":30,"address":[12226648],"length":1,"stats":{"Line":0}},{"line":34,"address":[11793309,11795344,11795366],"length":1,"stats":{"Line":0}},{"line":35,"address":[7398530,7398818,7398906,7399271,7399215,7398787,7399008],"length":1,"stats":{"Line":0}},{"line":36,"address":[11092004],"length":1,"stats":{"Line":0}},{"line":37,"address":[7399616,7400894,7400864],"length":1,"stats":{"Line":0}},{"line":39,"address":[11794492],"length":1,"stats":{"Line":0}},{"line":40,"address":[7399869,7400469],"length":1,"stats":{"Line":0}},{"line":43,"address":[11794826],"length":1,"stats":{"Line":0}},{"line":45,"address":[12228594,12228703],"length":1,"stats":{"Line":0}},{"line":46,"address":[11794755],"length":1,"stats":{"Line":0}},{"line":50,"address":[6404560],"length":1,"stats":{"Line":0}},{"line":54,"address":[11795967],"length":1,"stats":{"Line":0}},{"line":57,"address":[12230041],"length":1,"stats":{"Line":0}},{"line":60,"address":[11796581,11797080,11796765,11797257,11797135,11796522,11796228,11796362,11796815,11796161,11797980,11796679],"length":1,"stats":{"Line":0}},{"line":62,"address":[8979552,8979574,8977870],"length":1,"stats":{"Line":0}},{"line":63,"address":[8978452,8978033,8978002,8978125,8977745,8978190,8978392],"length":1,"stats":{"Line":0}},{"line":64,"address":[8246529],"length":1,"stats":{"Line":0}},{"line":65,"address":[11798262,11797250,11798240],"length":1,"stats":{"Line":0}},{"line":67,"address":[12231462],"length":1,"stats":{"Line":0}},{"line":68,"address":[12231528,12231849],"length":1,"stats":{"Line":0}},{"line":74,"address":[7402767],"length":1,"stats":{"Line":0}},{"line":76,"address":[7402665],"length":1,"stats":{"Line":0}},{"line":81,"address":[7403680],"length":1,"stats":{"Line":1}},{"line":87,"address":[12232828],"length":1,"stats":{"Line":1}},{"line":88,"address":[8980443],"length":1,"stats":{"Line":1}},{"line":90,"address":[11798852,11798972],"length":1,"stats":{"Line":0}},{"line":95,"address":[7404099,7404287],"length":1,"stats":{"Line":2}},{"line":96,"address":[11799876,11799690,11800285,11799134,11799602,11799935,11799772,11803572,11800413,11799380,11799164,11800227,11799231,11799543],"length":1,"stats":{"Line":11}},{"line":97,"address":[8980708],"length":1,"stats":{"Line":1}},{"line":98,"address":[5885255,5894726,5894704],"length":1,"stats":{"Line":0}},{"line":99,"address":[11799594,11799975,11800035,11799502,11799196,11799722,11799471],"length":1,"stats":{"Line":2}},{"line":100,"address":[12233946,12233881,12232866,12234307,12234119],"length":1,"stats":{"Line":6}},{"line":101,"address":[11809056,11809078,11800403],"length":1,"stats":{"Line":0}},{"line":103,"address":[12234632,12234671],"length":1,"stats":{"Line":4}},{"line":104,"address":[5886589],"length":1,"stats":{"Line":2}},{"line":107,"address":[11800631,11803520],"length":1,"stats":{"Line":0}},{"line":112,"address":[11800959,11803444,11800707,11800812],"length":1,"stats":{"Line":4}},{"line":113,"address":[8982501,8990848,8990864],"length":1,"stats":{"Line":0}},{"line":115,"address":[12235189],"length":1,"stats":{"Line":2}},{"line":117,"address":[11801201,11801279],"length":1,"stats":{"Line":4}},{"line":120,"address":[11801343],"length":1,"stats":{"Line":2}},{"line":124,"address":[12237490,12235593,12235812],"length":1,"stats":{"Line":1}},{"line":125,"address":[7406637],"length":1,"stats":{"Line":2}},{"line":126,"address":[8991017,8983306,8990992],"length":1,"stats":{"Line":0}},{"line":128,"address":[11801935],"length":1,"stats":{"Line":1}},{"line":132,"address":[7407198],"length":1,"stats":{"Line":2}},{"line":133,"address":[12236172],"length":1,"stats":{"Line":2}},{"line":134,"address":[12236250,12236335],"length":1,"stats":{"Line":4}},{"line":140,"address":[11802599,11802666,11803269,11803037,11803791,11808538,11803159,11802523,11802815,11803328,11803919,11802978,11803733],"length":1,"stats":{"Line":16}},{"line":141,"address":[11802535],"length":1,"stats":{"Line":2}},{"line":142,"address":[8991168,8991190,8984314],"length":1,"stats":{"Line":0}},{"line":143,"address":[7408413,7407983,7408175,7407720,7408014,7408102,7408463],"length":1,"stats":{"Line":4}},{"line":144,"address":[12237339,12237813,12237625,12237274,12232887],"length":1,"stats":{"Line":8}},{"line":145,"address":[8139150,8138786,8138731],"length":1,"stats":{"Line":2}},{"line":147,"address":[5890498,5889988,5889943,5890682,5894309,5890940,5890136,5890427,5891009,5890065,5890756,5891221],"length":1,"stats":{"Line":4}},{"line":148,"address":[5890031],"length":1,"stats":{"Line":2}},{"line":151,"address":[5890983,5891065],"length":1,"stats":{"Line":4}},{"line":157,"address":[12239903,12239572,12239852],"length":1,"stats":{"Line":6}},{"line":158,"address":[8987096],"length":1,"stats":{"Line":2}},{"line":159,"address":[8987329,8987249,8987162],"length":1,"stats":{"Line":6}},{"line":161,"address":[11806297,11805924,11806025],"length":1,"stats":{"Line":0}},{"line":164,"address":[12240891,12241419,12241196,12241551,12240939],"length":1,"stats":{"Line":4}},{"line":171,"address":[11808018],"length":1,"stats":{"Line":2}},{"line":173,"address":[8988666],"length":1,"stats":{"Line":2}},{"line":174,"address":[11807896],"length":1,"stats":{"Line":2}},{"line":175,"address":[5893832],"length":1,"stats":{"Line":2}},{"line":179,"address":[12244144],"length":1,"stats":{"Line":0}},{"line":182,"address":[7415224,7415949,7416198,7417082,7415600,7415740,7416268,7416366,7415441,7415322,7415816,7415897,7415655],"length":1,"stats":{"Line":0}},{"line":183,"address":[7415195],"length":1,"stats":{"Line":0}},{"line":184,"address":[7417118,7415394,7417088],"length":1,"stats":{"Line":0}},{"line":185,"address":[7416020,7415772,7415559,7415964,7415271,7415647,7415528],"length":1,"stats":{"Line":0}},{"line":186,"address":[8141785],"length":1,"stats":{"Line":0}},{"line":187,"address":[8994086,8994064,8993043],"length":1,"stats":{"Line":0}},{"line":189,"address":[11811663],"length":1,"stats":{"Line":0}},{"line":190,"address":[12246223,12245794],"length":1,"stats":{"Line":0}},{"line":193,"address":[11811913],"length":1,"stats":{"Line":0}},{"line":194,"address":[7416589,7416690],"length":1,"stats":{"Line":0}},{"line":196,"address":[8994304,8994518,8994512,8994446],"length":1,"stats":{"Line":0}},{"line":197,"address":[7417604],"length":1,"stats":{"Line":0}},{"line":198,"address":[8994349],"length":1,"stats":{"Line":0}},{"line":199,"address":[8994378],"length":1,"stats":{"Line":0}},{"line":200,"address":[8994442],"length":1,"stats":{"Line":0}}],"covered":36,"coverable":89},{"path":["/","home","vidyootsenthil","Documents","TheValut-nameTBD","crates","node","src","grpc","mod.rs"],"content":"pub mod grpc_handler;\npub mod grpc_operator;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","vidyootsenthil","Documents","TheValut-nameTBD","crates","node","src","handler.rs"],"content":"use std::any::Any;\n\nuse types::errors::NodeError;\n\nuse crate::{Network, NodeState, db::Db, swarm_manager::NetworkEvent};\n\n#[async_trait::async_trait]\npub trait Handler\u003cN: Network, D: Db\u003e: Send + Any {\n    async fn handle(\n        \u0026mut self,\n        node: \u0026mut NodeState\u003cN, D\u003e,\n        message: Option\u003cNetworkEvent\u003e,\n    ) -\u003e Result\u003c(), NodeError\u003e;\n}\n\nimpl\u003cN: Network, D: Db\u003e dyn Handler\u003cN, D\u003e {\n    pub fn downcast_ref\u003cT\u003e(\u0026self) -\u003e Option\u003c\u0026T\u003e\n    where\n        T: Any,\n    {\n        (self as \u0026dyn Any).downcast_ref::\u003cT\u003e()\n    }\n}\n","traces":[{"line":17,"address":[6559760],"length":1,"stats":{"Line":1}},{"line":21,"address":[],"length":0,"stats":{"Line":1}}],"covered":2,"coverable":2},{"path":["/","home","vidyootsenthil","Documents","TheValut-nameTBD","crates","node","src","key_manager.rs"],"content":"use std::{fs, path::PathBuf};\n\nuse crate::{ConfigStore, EncryptionParams, KeyStore, NodeConfig};\nuse aes_gcm::{Aes256Gcm, Key, KeyInit, Nonce, aead::Aead};\nuse argon2::{Argon2, password_hash::SaltString};\nuse base64::{Engine as _, engine::general_purpose::STANDARD as BASE64};\nuse directories::ProjectDirs;\nuse frost_secp256k1 as frost;\nuse libp2p::identity::Keypair;\nuse tracing::debug;\nuse types::errors::NodeError;\n\npub fn get_key_file_path() -\u003e Result\u003cPathBuf, NodeError\u003e {\n    let proj_dirs = ProjectDirs::from(\"\", \"\", \"TheVault\")\n        .ok_or_else(|| NodeError::Error(\"Failed to determine project directory\".into()))?;\n\n    let config_dir = proj_dirs.config_dir();\n    fs::create_dir_all(config_dir)\n        .map_err(|e| NodeError::Error(format!(\"Failed to create config directory: {}\", e)))?;\n\n    let path = config_dir.join(\"config.json\");\n    debug!(\"Using key file path: {}\", path.display());\n    Ok(path)\n}\n\npub fn get_config_file_path(file_path_option: Option\u003cString\u003e) -\u003e Result\u003cPathBuf, NodeError\u003e {\n    if let Some(file_path_str) = file_path_option {\n        let mut path = PathBuf::from(file_path_str);\n        if path.is_dir() {\n            path.push(\"config.yaml\");\n        }\n        println!(\"Using config file path: {}\", path.display());\n        Ok(path)\n    } else {\n        let proj_dirs = ProjectDirs::from(\"\", \"\", \"TheVault\")\n            .ok_or_else(|| NodeError::Error(\"Failed to determine project directory\".into()))?;\n        let config_dir = proj_dirs.config_dir();\n        Ok(config_dir.join(\"config.yaml\"))\n    }\n}\n\npub fn derive_key_from_password(password: \u0026str, salt_str: \u0026str) -\u003e Result\u003cVec\u003cu8\u003e, NodeError\u003e {\n    let argon2 = Argon2::default();\n    let password_bytes = password.as_bytes();\n    let salt = SaltString::from_b64(salt_str)\n        .map_err(|e| NodeError::Error(format!(\"Salt decoding failed: {}\", e)))?;\n\n    let mut key = vec![0u8; 32];\n    argon2\n        .hash_password_into(password_bytes, salt.as_str().as_bytes(), \u0026mut key)\n        .map_err(|e| NodeError::Error(format!(\"Argon2 key derivation failed: {}\", e)))?;\n    Ok(key)\n}\n\npub fn encrypt_private_key(\n    private_key_data: \u0026[u8],\n    password: \u0026str,\n    salt_b64: \u0026str,\n) -\u003e Result\u003c(String, String), NodeError\u003e {\n    let key_bytes = derive_key_from_password(password, salt_b64)?;\n\n    // Generate random IV\n    let mut iv = [0u8; 12];\n    use frost::rand_core::RngCore;\n    frost::rand_core::OsRng.fill_bytes(\u0026mut iv);\n    let nonce = Nonce::from_slice(\u0026iv);\n\n    let cipher = Aes256Gcm::new(Key::\u003cAes256Gcm\u003e::from_slice(\u0026key_bytes));\n    let ciphertext = cipher\n        .encrypt(nonce, private_key_data)\n        .map_err(|e| NodeError::Error(format!(\"AES encryption failed: {}\", e)))?;\n\n    let encrypted_b64 = BASE64.encode(ciphertext);\n    let iv_b64 = BASE64.encode(iv);\n\n    Ok((encrypted_b64, iv_b64))\n}\n\npub fn decrypt_private_key(\n    encrypted_private_key_b64: \u0026str,\n    password: \u0026str,\n    params: \u0026EncryptionParams,\n) -\u003e Result\u003cVec\u003cu8\u003e, NodeError\u003e {\n    let key_bytes = derive_key_from_password(password, \u0026params.salt_b64)?;\n\n    let iv_bytes = BASE64\n        .decode(\u0026params.iv_b64)\n        .map_err(|e| NodeError::Error(format!(\"IV decoding failed: {}\", e)))?;\n    let nonce = Nonce::from_slice(\u0026iv_bytes);\n\n    let ciphertext = BASE64\n        .decode(encrypted_private_key_b64)\n        .map_err(|e| NodeError::Error(format!(\"Ciphertext decoding failed: {}\", e)))?;\n\n    let cipher = Aes256Gcm::new(Key::\u003cAes256Gcm\u003e::from_slice(\u0026key_bytes));\n\n    let decrypted_private_key = cipher\n        .decrypt(nonce, ciphertext.as_ref())\n        .map_err(|e| NodeError::Error(format!(\"AES decryption failed: {}\", e)))?;\n\n    Ok(decrypted_private_key)\n}\n\npub fn get_password_from_prompt() -\u003e Result\u003cString, NodeError\u003e {\n    rpassword::prompt_password(\"Enter password to decrypt identity key: \")\n        .map_err(|e| NodeError::Error(e.to_string()))\n}\n\npub fn get_config(\n    key_file_path: Option\u003cString\u003e,\n    config_file_path: Option\u003cString\u003e,\n) -\u003e Result\u003cNodeConfig, NodeError\u003e {\n    let key_file_path = if let Some(key_path) = key_file_path {\n        PathBuf::from(key_path)\n    } else {\n        get_key_file_path()?\n    };\n\n    let config_file_path = if let Some(config_path) = config_file_path {\n        PathBuf::from(config_path)\n    } else {\n        get_config_file_path(None)?\n    };\n\n    debug!(\"Using key file path: {}\", key_file_path.display());\n\n    let key_contents = fs::read_to_string(\u0026key_file_path)\n        .map_err(|e| NodeError::Error(format!(\"Failed to read config file: {}\", e)))?;\n\n    let key_store = serde_json::from_str::\u003cKeyStore\u003e(\u0026key_contents)\n        .map_err(|e| NodeError::Error(format!(\"Failed to deserialize key file: {}\", e)))?;\n\n    let config_contents = fs::read_to_string(\u0026config_file_path)\n        .map_err(|e| NodeError::Error(format!(\"Failed to read config file: {}\", e)))?;\n\n    let config_store = serde_yaml::from_str::\u003cConfigStore\u003e(\u0026config_contents)\n        .map_err(|e| NodeError::Error(format!(\"Failed to deserialize config file: {}\", e)))?;\n\n    let node_config = NodeConfig {\n        key_data: key_store.key_data,\n        dkg_keys: key_store.dkg_keys,\n        allowed_peers: config_store.allowed_peers,\n        log_file_path: config_store.log_file_path,\n        key_file_path,\n        config_file_path,\n    };\n\n    debug!(\"Read config file\");\n\n    Ok(node_config)\n}\n\npub fn load_and_decrypt_keypair(config_data: \u0026NodeConfig) -\u003e Result\u003cKeypair, NodeError\u003e {\n    let password = match std::env::var(\"KEY_PASSWORD\") {\n        Ok(pw) =\u003e pw,\n        Err(_) =\u003e get_password_from_prompt()?,\n    };\n\n    let private_key_protobuf = decrypt_private_key(\n        \u0026config_data.key_data.encrypted_private_key_b64,\n        \u0026password,\n        \u0026config_data.key_data.encryption_params,\n    )?;\n\n    Keypair::from_protobuf_encoding(\u0026private_key_protobuf).map_err(|e| {\n        NodeError::Error(format!(\n            \"Failed to reconstruct keypair from protobuf: {}\",\n            e\n        ))\n    })\n}\n\npub fn load_dkg_keys(\n    config: NodeConfig,\n) -\u003e Result\u003c\n    Option\u003c(frost::keys::KeyPackage, frost::keys::PublicKeyPackage)\u003e,\n    Box\u003cdyn std::error::Error\u003e,\n\u003e {\n    if let Some(dkg_keys) = config.dkg_keys {\n        let password = match std::env::var(\"KEY_PASSWORD\") {\n            Ok(pw) =\u003e pw,\n            Err(_) =\u003e get_password_from_prompt()?,\n        };\n\n        let private_key_bytes = decrypt_private_key(\n            \u0026dkg_keys.encrypted_private_key_package_b64,\n            \u0026password,\n            \u0026dkg_keys.dkg_encryption_params,\n        )?;\n\n        let private_key = frost::keys::KeyPackage::deserialize(\u0026private_key_bytes)?;\n\n        let pubkey_bytes = BASE64.decode(\u0026dkg_keys.pubkey_package_b64)?;\n        let pubkey = frost::keys::PublicKeyPackage::deserialize(\u0026pubkey_bytes)?;\n\n        Ok(Some((private_key, pubkey)))\n    } else {\n        Ok(None)\n    }\n}\n","traces":[{"line":13,"address":[8510801,8510779,8509152],"length":1,"stats":{"Line":0}},{"line":14,"address":[8509357,8509175],"length":1,"stats":{"Line":0}},{"line":15,"address":[8755099],"length":1,"stats":{"Line":0}},{"line":17,"address":[8755363,8755276],"length":1,"stats":{"Line":0}},{"line":18,"address":[8755540,8755398],"length":1,"stats":{"Line":0}},{"line":19,"address":[7197040,7197062],"length":1,"stats":{"Line":0}},{"line":21,"address":[8509801],"length":1,"stats":{"Line":0}},{"line":22,"address":[8714649,8715063,8714722],"length":1,"stats":{"Line":0}},{"line":23,"address":[8714953],"length":1,"stats":{"Line":0}},{"line":26,"address":[8510816,8511525,8512017],"length":1,"stats":{"Line":0}},{"line":27,"address":[8715660],"length":1,"stats":{"Line":0}},{"line":28,"address":[8715760],"length":1,"stats":{"Line":0}},{"line":29,"address":[8756924,8756856],"length":1,"stats":{"Line":0}},{"line":30,"address":[8813582],"length":1,"stats":{"Line":0}},{"line":32,"address":[8715997,8716057],"length":1,"stats":{"Line":0}},{"line":33,"address":[8813772],"length":1,"stats":{"Line":0}},{"line":35,"address":[8756727,8757426,8757319],"length":1,"stats":{"Line":0}},{"line":36,"address":[10180976,10180990],"length":1,"stats":{"Line":0}},{"line":37,"address":[8814230,8814155],"length":1,"stats":{"Line":0}},{"line":38,"address":[8716678],"length":1,"stats":{"Line":0}},{"line":42,"address":[8717846,8717852,8716864],"length":1,"stats":{"Line":2}},{"line":43,"address":[8814504],"length":1,"stats":{"Line":1}},{"line":44,"address":[8512144],"length":1,"stats":{"Line":2}},{"line":45,"address":[8717144,8717013],"length":1,"stats":{"Line":1}},{"line":46,"address":[8758038],"length":1,"stats":{"Line":0}},{"line":48,"address":[8814894],"length":1,"stats":{"Line":2}},{"line":49,"address":[8512879,8512723],"length":1,"stats":{"Line":1}},{"line":50,"address":[8717440,8717357],"length":1,"stats":{"Line":3}},{"line":51,"address":[10728912,10728936],"length":1,"stats":{"Line":0}},{"line":52,"address":[8758655],"length":1,"stats":{"Line":2}},{"line":55,"address":[8816740,8816672,8815440],"length":1,"stats":{"Line":2}},{"line":60,"address":[8718002],"length":1,"stats":{"Line":1}},{"line":63,"address":[8759116],"length":1,"stats":{"Line":1}},{"line":65,"address":[8815782],"length":1,"stats":{"Line":2}},{"line":66,"address":[8815855],"length":1,"stats":{"Line":2}},{"line":68,"address":[8513513],"length":1,"stats":{"Line":2}},{"line":69,"address":[8816164,8816059,8815988],"length":1,"stats":{"Line":4}},{"line":71,"address":[7333889,7333872],"length":1,"stats":{"Line":0}},{"line":73,"address":[8718697],"length":1,"stats":{"Line":2}},{"line":74,"address":[8513996],"length":1,"stats":{"Line":2}},{"line":76,"address":[8514106],"length":1,"stats":{"Line":2}},{"line":79,"address":[8720738,8719200,8720712],"length":1,"stats":{"Line":0}},{"line":84,"address":[8760170],"length":1,"stats":{"Line":0}},{"line":86,"address":[8719517,8719587,8719692,8720736],"length":1,"stats":{"Line":0}},{"line":87,"address":[8760390],"length":1,"stats":{"Line":0}},{"line":88,"address":[10181600,10181584],"length":1,"stats":{"Line":0}},{"line":89,"address":[8515052,8514969],"length":1,"stats":{"Line":0}},{"line":91,"address":[8760764,8760887,8761531],"length":1,"stats":{"Line":0}},{"line":93,"address":[7198080,7198064],"length":1,"stats":{"Line":0}},{"line":95,"address":[8817699,8817782],"length":1,"stats":{"Line":0}},{"line":97,"address":[8761299,8761195],"length":1,"stats":{"Line":0}},{"line":98,"address":[8515438],"length":1,"stats":{"Line":0}},{"line":99,"address":[10729601,10729584],"length":1,"stats":{"Line":0}},{"line":101,"address":[8761361],"length":1,"stats":{"Line":0}},{"line":104,"address":[8515936],"length":1,"stats":{"Line":0}},{"line":105,"address":[8720765],"length":1,"stats":{"Line":0}},{"line":106,"address":[10729778,10729760],"length":1,"stats":{"Line":0}},{"line":109,"address":[8516000,8521076,8521612],"length":1,"stats":{"Line":0}},{"line":113,"address":[8720870,8721403],"length":1,"stats":{"Line":0}},{"line":114,"address":[8516221,8516316],"length":1,"stats":{"Line":0}},{"line":116,"address":[8721044,8721189,8726273],"length":1,"stats":{"Line":0}},{"line":119,"address":[8762220,8761960,8762601],"length":1,"stats":{"Line":0}},{"line":120,"address":[8819124,8819031],"length":1,"stats":{"Line":0}},{"line":122,"address":[8819163,8823767,8819048],"length":1,"stats":{"Line":0}},{"line":125,"address":[8517341,8517046,8516748],"length":1,"stats":{"Line":0}},{"line":127,"address":[8722721,8722127,8726148,8722829],"length":1,"stats":{"Line":0}},{"line":128,"address":[7198544,7198566],"length":1,"stats":{"Line":0}},{"line":130,"address":[8763797,8763706,8763927,8766835],"length":1,"stats":{"Line":0}},{"line":131,"address":[8820699],"length":1,"stats":{"Line":0}},{"line":133,"address":[8723358,8723290,8726034,8723466],"length":1,"stats":{"Line":0}},{"line":134,"address":[8518618],"length":1,"stats":{"Line":0}},{"line":136,"address":[8518972,8518751,8518822],"length":1,"stats":{"Line":0}},{"line":137,"address":[8723756],"length":1,"stats":{"Line":0}},{"line":140,"address":[8821561],"length":1,"stats":{"Line":0}},{"line":141,"address":[8519313],"length":1,"stats":{"Line":0}},{"line":142,"address":[8821833],"length":1,"stats":{"Line":0}},{"line":143,"address":[8765033],"length":1,"stats":{"Line":0}},{"line":148,"address":[8822377,8822765,8822450],"length":1,"stats":{"Line":0}},{"line":150,"address":[8520332],"length":1,"stats":{"Line":0}},{"line":153,"address":[8824976,8824032,8824995],"length":1,"stats":{"Line":0}},{"line":154,"address":[8767198],"length":1,"stats":{"Line":0}},{"line":155,"address":[8824118],"length":1,"stats":{"Line":0}},{"line":156,"address":[8767412,8767240],"length":1,"stats":{"Line":0}},{"line":160,"address":[8726916],"length":1,"stats":{"Line":0}},{"line":161,"address":[8767695],"length":1,"stats":{"Line":0}},{"line":162,"address":[8767737],"length":1,"stats":{"Line":0}},{"line":165,"address":[10183248,10183470],"length":1,"stats":{"Line":0}},{"line":166,"address":[10731010,10730950],"length":1,"stats":{"Line":0}},{"line":173,"address":[8524963,8522672,8525366],"length":1,"stats":{"Line":6}},{"line":179,"address":[8522972,8522715],"length":1,"stats":{"Line":4}},{"line":180,"address":[8825291,8825405],"length":1,"stats":{"Line":0}},{"line":181,"address":[8768537],"length":1,"stats":{"Line":0}},{"line":182,"address":[8728034,8727851],"length":1,"stats":{"Line":0}},{"line":186,"address":[8728272],"length":1,"stats":{"Line":0}},{"line":187,"address":[8728367],"length":1,"stats":{"Line":0}},{"line":188,"address":[8825972],"length":1,"stats":{"Line":0}},{"line":191,"address":[8770387,8769249,8769340],"length":1,"stats":{"Line":0}},{"line":193,"address":[8769560,8770385],"length":1,"stats":{"Line":0}},{"line":194,"address":[8769763,8769854],"length":1,"stats":{"Line":0}},{"line":196,"address":[8729512],"length":1,"stats":{"Line":0}},{"line":198,"address":[8727762],"length":1,"stats":{"Line":6}}],"covered":21,"coverable":101},{"path":["/","home","vidyootsenthil","Documents","TheValut-nameTBD","crates","node","src","lib.rs"],"content":"use crate::{\n    db::Db, deposit_intents::DepositIntentState, dkg::DkgState, handler::Handler,\n    signing::SigningState,\n};\nuse aes_gcm::{Aes256Gcm, Key, KeyInit, Nonce, aead::Aead};\nuse argon2::{\n    Argon2,\n    password_hash::{\n        SaltString,\n        rand_core::{OsRng, RngCore},\n    },\n};\nuse base64::{Engine as _, engine::general_purpose::STANDARD as BASE64};\nuse frost_secp256k1::{self as frost, Identifier};\nuse libp2p::{PeerId, identity::Keypair};\nuse serde::{Deserialize, Serialize};\nuse std::{collections::HashSet, fs, path::PathBuf};\nuse swarm_manager::{Network, NetworkEvent};\nuse tokio::sync::broadcast;\nuse tracing::error;\nuse types::errors::NodeError;\n\npub mod db;\npub mod deposit_intents;\npub mod dkg;\npub mod grpc;\npub mod handler;\npub mod key_manager;\npub mod main_loop;\npub mod signing;\npub mod start_node;\npub mod swarm_manager;\npub mod wallet;\n\n#[derive(Clone, Serialize, Deserialize, PartialEq)]\npub struct PeerData {\n    pub name: String,\n    pub public_key: String,\n}\n\n#[derive(Clone, Serialize, Deserialize)]\npub struct DkgKeys {\n    pub encrypted_private_key_package_b64: String,\n    pub dkg_encryption_params: EncryptionParams,\n    pub pubkey_package_b64: String,\n}\n\n#[derive(Clone, Serialize, Deserialize)]\npub struct EncryptionParams {\n    pub kdf: String,\n    pub salt_b64: String,\n    pub iv_b64: String,\n}\n\n#[derive(Clone, Serialize, Deserialize)]\npub struct KeyData {\n    pub public_key_b58: String,\n    pub encrypted_private_key_b64: String,\n    pub encryption_params: EncryptionParams,\n}\n\n#[derive(Clone, Serialize, Deserialize)]\npub struct NodeConfig {\n    pub allowed_peers: Vec\u003cPeerData\u003e,\n    pub key_data: KeyData,\n    pub dkg_keys: Option\u003cDkgKeys\u003e,\n    pub log_file_path: Option\u003cPathBuf\u003e,\n    #[serde(skip)]\n    key_file_path: PathBuf,\n    #[serde(skip)]\n    config_file_path: PathBuf,\n}\n\n#[derive(Serialize, Deserialize)]\npub struct KeyStore {\n    key_data: KeyData,\n    dkg_keys: Option\u003cDkgKeys\u003e,\n}\n\n#[derive(Serialize, Deserialize)]\npub struct ConfigStore {\n    allowed_peers: Vec\u003cPeerData\u003e,\n    log_file_path: Option\u003cPathBuf\u003e,\n    key_file_path: PathBuf,\n}\n\nimpl NodeConfig {\n    pub fn new(\n        key_file_path: PathBuf,\n        config_file_path: PathBuf,\n        log_file_path: Option\u003cPathBuf\u003e,\n        password: \u0026str,\n    ) -\u003e Result\u003cSelf, NodeError\u003e {\n        // Generate a new keypair\n        let keypair = Keypair::generate_ed25519();\n        let public_key_b58 = keypair.public().to_peer_id().to_base58();\n\n        // Generate salt for encryption\n        let salt = SaltString::generate(\u0026mut OsRng);\n        let salt_b64 = salt.to_string();\n\n        // Derive encryption key from password\n        let argon2 = Argon2::default();\n        let mut key_bytes = vec![0u8; 32];\n        argon2\n            .hash_password_into(\n                password.as_bytes(),\n                salt.as_str().as_bytes(),\n                \u0026mut key_bytes,\n            )\n            .map_err(|e| NodeError::Error(format!(\"Argon2 key derivation failed: {}\", e)))?;\n\n        // Generate random IV for AES encryption\n        let mut iv = [0u8; 12];\n        frost::rand_core::OsRng.fill_bytes(\u0026mut iv);\n        let nonce = Nonce::from_slice(\u0026iv);\n\n        // Get private key bytes\n        let private_key_bytes = keypair\n            .to_protobuf_encoding()\n            .map_err(|e| NodeError::Error(format!(\"Failed to encode private key: {}\", e)))?;\n\n        // Encrypt the private key\n        let cipher = Aes256Gcm::new(Key::\u003cAes256Gcm\u003e::from_slice(\u0026key_bytes));\n        let ciphertext = cipher\n            .encrypt(nonce, private_key_bytes.as_ref())\n            .map_err(|e| NodeError::Error(format!(\"AES encryption failed: {}\", e)))?;\n\n        let encrypted_private_key_b64 = BASE64.encode(ciphertext);\n        let iv_b64 = BASE64.encode(iv);\n\n        let key_data = KeyData {\n            public_key_b58,\n            encrypted_private_key_b64,\n            encryption_params: EncryptionParams {\n                kdf: \"argon2id\".to_string(),\n                salt_b64,\n                iv_b64,\n            },\n        };\n\n        Ok(NodeConfig {\n            allowed_peers: Vec::new(),\n            key_data,\n            dkg_keys: None,\n            log_file_path,\n            key_file_path,\n            config_file_path,\n        })\n    }\n\n    pub fn save_to_file(\u0026self) -\u003e Result\u003c(), NodeError\u003e {\n        let key_store = KeyStore {\n            key_data: self.key_data.clone(),\n            dkg_keys: self.dkg_keys.clone(),\n        };\n\n        let key_info_str = serde_json::to_string_pretty(\u0026key_store)\n            .map_err(|e| NodeError::Error(format!(\"Failed to serialize key data: {}\", e)))?;\n\n        fs::write(\u0026self.key_file_path, key_info_str)\n            .map_err(|e| NodeError::Error(format!(\"Failed to write key data: {}\", e)))?;\n\n        let config_store = ConfigStore {\n            allowed_peers: self.allowed_peers.clone(),\n            log_file_path: self.log_file_path.clone(),\n            key_file_path: self.key_file_path.clone(),\n        };\n\n        let config_str: String = serde_yaml::to_string(\u0026config_store).unwrap();\n\n        fs::write(\u0026self.config_file_path, config_str)\n            .map_err(|e| NodeError::Error(format!(\"Failed to write config: {}\", e)))?;\n\n        Ok(())\n    }\n\n    pub fn set_dkg_keys(\u0026mut self, dkg_keys: DkgKeys) {\n        self.dkg_keys = Some(dkg_keys);\n    }\n\n    pub fn set_key_data(\u0026mut self, key_data: KeyData) {\n        self.key_data = key_data;\n    }\n}\n\npub struct NodeState\u003cN: Network, D: Db\u003e {\n    pub handlers: Vec\u003cBox\u003cdyn Handler\u003cN, D\u003e\u003e\u003e,\n    pub db: D,\n\n    pub peer_id: PeerId,\n    pub peers: HashSet\u003cPeerId\u003e,\n\n    pub min_signers: u16,\n    pub max_signers: u16,\n    pub rng: frost::rand_core::OsRng,\n    pub pubkey_package: Option\u003cfrost::keys::PublicKeyPackage\u003e,\n    pub private_key_package: Option\u003cfrost::keys::KeyPackage\u003e,\n\n    // FROST signing\n    pub wallet: crate::wallet::SimpleWallet,\n\n    pub config: NodeConfig,\n\n    pub network_handle: N,\n\n    pub network_events_stream: broadcast::Receiver\u003cNetworkEvent\u003e,\n    // track deposits and then send new addresses over a channel to the polling thread\n}\n\nimpl\u003cN: Network, D: Db\u003e NodeState\u003cN, D\u003e {\n    pub fn new_from_config(\n        network_handle: N,\n        min_signers: u16,\n        max_signers: u16,\n        config: NodeConfig,\n        storage_db: D,\n        network_events_sender: broadcast::Sender\u003cNetworkEvent\u003e,\n        deposit_intent_tx: broadcast::Sender\u003cString\u003e,\n    ) -\u003e Result\u003cSelf, NodeError\u003e {\n        let keys = key_manager::load_dkg_keys(config.clone())\n            .map_err(|e| NodeError::Error(format!(\"Failed to load DKG keys: {}\", e)))?;\n        let dkg_state = DkgState::new()?;\n        let signing_state = SigningState::new()?;\n        let deposit_intent_state = DepositIntentState::new(deposit_intent_tx);\n\n        let mut node_state = NodeState {\n            network_handle: network_handle.clone(),\n            network_events_stream: network_events_sender.subscribe(),\n            peer_id: network_handle.peer_id(),\n            min_signers,\n            max_signers,\n            db: storage_db,\n            peers: HashSet::new(),\n            rng: frost::rand_core::OsRng,\n            wallet: crate::wallet::SimpleWallet::default(),\n            config,\n            handlers: vec![\n                Box::new(dkg_state),\n                Box::new(signing_state),\n                Box::new(deposit_intent_state),\n            ],\n            pubkey_package: None,\n            private_key_package: None,\n        };\n\n        if let Some((private_key, pubkey)) = keys {\n            node_state.private_key_package = Some(private_key);\n            node_state.pubkey_package = Some(pubkey);\n        }\n\n        Ok(node_state)\n    }\n}\n\npub fn peer_id_to_identifier(peer_id: \u0026PeerId) -\u003e Identifier {\n    let bytes = peer_id.to_bytes();\n    match Identifier::derive(\u0026bytes) {\n        Ok(identifier) =\u003e identifier,\n        Err(e) =\u003e {\n            error!(\"Failed to derive identifier: {}\", e);\n            panic!(\"Failed to derive identifier\");\n        }\n    }\n}\n","traces":[{"line":88,"address":[8775267,8774795,8771440],"length":1,"stats":{"Line":3}},{"line":95,"address":[7384047],"length":1,"stats":{"Line":8}},{"line":96,"address":[8771735,8771667],"length":1,"stats":{"Line":10}},{"line":99,"address":[8771797],"length":1,"stats":{"Line":2}},{"line":100,"address":[9170521],"length":1,"stats":{"Line":8}},{"line":103,"address":[9211500],"length":1,"stats":{"Line":1}},{"line":104,"address":[7384477],"length":1,"stats":{"Line":2}},{"line":105,"address":[9214568,9212011,9211852],"length":1,"stats":{"Line":3}},{"line":107,"address":[7384526],"length":1,"stats":{"Line":8}},{"line":108,"address":[7384622],"length":1,"stats":{"Line":1}},{"line":109,"address":[8772190],"length":1,"stats":{"Line":7}},{"line":111,"address":[9171035],"length":1,"stats":{"Line":0}},{"line":114,"address":[7384948],"length":1,"stats":{"Line":2}},{"line":115,"address":[7384971],"length":1,"stats":{"Line":6}},{"line":116,"address":[8772495],"length":1,"stats":{"Line":4}},{"line":119,"address":[8772672,8774966,8772537],"length":1,"stats":{"Line":4}},{"line":121,"address":[10929072,10929094],"length":1,"stats":{"Line":0}},{"line":124,"address":[8772848,8772765],"length":1,"stats":{"Line":6}},{"line":125,"address":[9171632,9171767],"length":1,"stats":{"Line":5}},{"line":126,"address":[9212488],"length":1,"stats":{"Line":1}},{"line":127,"address":[8773079],"length":1,"stats":{"Line":0}},{"line":129,"address":[7385680,7385791],"length":1,"stats":{"Line":7}},{"line":130,"address":[9172096,9171991],"length":1,"stats":{"Line":7}},{"line":135,"address":[9213283],"length":1,"stats":{"Line":1}},{"line":142,"address":[9172913],"length":1,"stats":{"Line":6}},{"line":143,"address":[7386388],"length":1,"stats":{"Line":6}},{"line":144,"address":[9172674],"length":1,"stats":{"Line":1}},{"line":145,"address":[8774156],"length":1,"stats":{"Line":6}},{"line":146,"address":[7386613],"length":1,"stats":{"Line":1}},{"line":147,"address":[9213795],"length":1,"stats":{"Line":6}},{"line":148,"address":[7386675],"length":1,"stats":{"Line":1}},{"line":152,"address":[8776896,8775312,8776928],"length":1,"stats":{"Line":2}},{"line":154,"address":[9214950],"length":1,"stats":{"Line":3}},{"line":155,"address":[8775372],"length":1,"stats":{"Line":3}},{"line":158,"address":[8775683,8776926,8775748,8775853],"length":1,"stats":{"Line":6}},{"line":159,"address":[10372790,10372768],"length":1,"stats":{"Line":0}},{"line":161,"address":[7389244,7388363,7388484,7388588],"length":1,"stats":{"Line":4}},{"line":162,"address":[9215764],"length":1,"stats":{"Line":0}},{"line":165,"address":[7388618],"length":1,"stats":{"Line":1}},{"line":166,"address":[7388645],"length":1,"stats":{"Line":1}},{"line":167,"address":[8776336],"length":1,"stats":{"Line":1}},{"line":170,"address":[9216095,9216166],"length":1,"stats":{"Line":4}},{"line":172,"address":[7389117,7388973],"length":1,"stats":{"Line":3}},{"line":173,"address":[8612758,8612736],"length":1,"stats":{"Line":0}},{"line":175,"address":[7389154],"length":1,"stats":{"Line":1}},{"line":178,"address":[9175742,9175600],"length":1,"stats":{"Line":2}},{"line":179,"address":[8777125,8776968],"length":1,"stats":{"Line":4}},{"line":182,"address":[9216824,9216768],"length":1,"stats":{"Line":0}},{"line":183,"address":[9175915,9175842],"length":1,"stats":{"Line":0}},{"line":212,"address":[10933486,10930272,10934095],"length":1,"stats":{"Line":1}},{"line":221,"address":[],"length":0,"stats":{"Line":8}},{"line":222,"address":[5703952,5700613,5703978],"length":1,"stats":{"Line":0}},{"line":223,"address":[5700766,5700841,5703610],"length":1,"stats":{"Line":14}},{"line":224,"address":[8613842,8613906],"length":1,"stats":{"Line":11}},{"line":225,"address":[],"length":0,"stats":{"Line":6}},{"line":228,"address":[10374789],"length":1,"stats":{"Line":8}},{"line":229,"address":[5701490,5701574],"length":1,"stats":{"Line":11}},{"line":230,"address":[8614350],"length":1,"stats":{"Line":3}},{"line":234,"address":[8614469],"length":1,"stats":{"Line":8}},{"line":236,"address":[10375144],"length":1,"stats":{"Line":3}},{"line":238,"address":[10932109,10933619,10932429,10932245,10932037,10931976],"length":1,"stats":{"Line":11}},{"line":247,"address":[8615668,8616094],"length":1,"stats":{"Line":8}},{"line":248,"address":[10376456],"length":1,"stats":{"Line":0}},{"line":249,"address":[5703094,5703293,5703223],"length":1,"stats":{"Line":0}},{"line":252,"address":[10933266],"length":1,"stats":{"Line":3}},{"line":256,"address":[9177042,9177048,9175936],"length":1,"stats":{"Line":1}},{"line":257,"address":[9175961],"length":1,"stats":{"Line":3}},{"line":258,"address":[9217068,9216996],"length":1,"stats":{"Line":6}},{"line":259,"address":[8777593],"length":1,"stats":{"Line":3}},{"line":260,"address":[9176171],"length":1,"stats":{"Line":0}},{"line":261,"address":[9176324,9176576,9176219],"length":1,"stats":{"Line":0}},{"line":262,"address":[9177014,9176547],"length":1,"stats":{"Line":0}}],"covered":58,"coverable":72},{"path":["/","home","vidyootsenthil","Documents","TheValut-nameTBD","crates","node","src","main_loop.rs"],"content":"use tracing::info;\n\nuse crate::db::Db;\nuse crate::swarm_manager::{NetworkEvent, SelfRequest, SelfResponse};\nuse crate::{Network, NodeState};\nuse types::errors::NodeError;\n\nimpl\u003cN: Network + 'static, D: Db + 'static\u003e NodeState\u003cN, D\u003e {\n    pub async fn try_poll(\u0026mut self) -\u003e Result\u003cbool, NodeError\u003e {\n        let send_message = self.network_events_stream.try_recv().ok();\n        if let Some(event) = send_message {\n            self.handle(Some(event)).await?;\n            Ok(true)\n        } else {\n            Ok(false)\n        }\n    }\n\n    pub async fn poll(\u0026mut self) -\u003e Result\u003c(), NodeError\u003e {\n        let send_message = self.network_events_stream.recv().await.ok();\n        self.handle(send_message).await\n    }\n\n    pub async fn start(\u0026mut self) -\u003e Result\u003c(), NodeError\u003e {\n        info!(\"Local peer id: {}\", self.peer_id);\n\n        loop {\n            self.poll().await?\n        }\n    }\n\n    pub async fn handle(\u0026mut self, send_message: Option\u003cNetworkEvent\u003e) -\u003e Result\u003c(), NodeError\u003e {\n        let mut handlers = std::mem::take(\u0026mut self.handlers);\n\n        for handler in handlers.iter_mut() {\n            handler.handle(self, send_message.clone()).await?;\n        }\n\n        self.handlers = handlers;\n        match send_message {\n            Some(NetworkEvent::SelfRequest {\n                request: SelfRequest::GetFrostPublicKey,\n                response_channel,\n            }) =\u003e {\n                let response = self.get_frost_public_key();\n                if let Some(response_channel) = response_channel {\n                    response_channel\n                        .send(SelfResponse::GetFrostPublicKeyResponse {\n                            public_key: response,\n                        })\n                        .map_err(|e| NodeError::Error(format!(\"Failed to send response: {}\", e)))?;\n                }\n            }\n            Some(NetworkEvent::PeersConnected(list)) =\u003e {\n                for (peer_id, _multiaddr) in list {\n                    self.peers.insert(peer_id);\n                }\n            }\n            _ =\u003e {}\n        }\n        Ok(())\n    }\n}\n","traces":[{"line":9,"address":[5704368,5704376],"length":1,"stats":{"Line":15}},{"line":10,"address":[],"length":0,"stats":{"Line":7}},{"line":11,"address":[],"length":0,"stats":{"Line":10}},{"line":12,"address":[],"length":0,"stats":{"Line":4}},{"line":13,"address":[6529929],"length":1,"stats":{"Line":2}},{"line":15,"address":[],"length":0,"stats":{"Line":2}},{"line":19,"address":[8611424,8611432],"length":1,"stats":{"Line":0}},{"line":20,"address":[12585232,12584993,12585127,12585055],"length":1,"stats":{"Line":0}},{"line":21,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[12587265,12585875,12586005,12586748,12585965,12585840],"length":1,"stats":{"Line":0}},{"line":25,"address":[12586298,12586056,12585940],"length":1,"stats":{"Line":0}},{"line":27,"address":[9041488],"length":1,"stats":{"Line":0}},{"line":28,"address":[12199910,12200277,12199934,12199128,12199403],"length":1,"stats":{"Line":0}},{"line":32,"address":[10928771,10928736],"length":1,"stats":{"Line":14}},{"line":33,"address":[9041889,9042040],"length":1,"stats":{"Line":5}},{"line":35,"address":[6524999,6525101,6525633],"length":1,"stats":{"Line":7}},{"line":36,"address":[7545088],"length":1,"stats":{"Line":7}},{"line":39,"address":[12588567,12588488],"length":1,"stats":{"Line":3}},{"line":40,"address":[9042994,9043170],"length":1,"stats":{"Line":4}},{"line":41,"address":[12202138],"length":1,"stats":{"Line":2}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[],"length":0,"stats":{"Line":0}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[12589048,12589150],"length":1,"stats":{"Line":2}},{"line":46,"address":[12202294],"length":1,"stats":{"Line":1}},{"line":47,"address":[],"length":0,"stats":{"Line":4}},{"line":48,"address":[12589257],"length":1,"stats":{"Line":1}},{"line":49,"address":[12589217],"length":1,"stats":{"Line":1}},{"line":51,"address":[9043762,9045742,9045712],"length":1,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":4}},{"line":55,"address":[9043288,9044190,9044063],"length":1,"stats":{"Line":8}},{"line":56,"address":[9485625],"length":1,"stats":{"Line":3}},{"line":59,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":4}}],"covered":22,"coverable":34},{"path":["/","home","vidyootsenthil","Documents","TheValut-nameTBD","crates","node","src","signing","create_signature.rs"],"content":"use rand::seq::SliceRandom;\nuse std::collections::BTreeMap;\n\nuse frost_secp256k1::rand_core::RngCore;\nuse frost_secp256k1::{self as frost};\nuse hex;\nuse libp2p::PeerId;\nuse tracing::{debug, error, info, warn};\n\nuse crate::NodeState;\nuse crate::db::Db;\nuse crate::signing::ActiveSigning;\nuse crate::swarm_manager::{DirectMessage, Network};\nuse crate::{peer_id_to_identifier, signing::SigningState};\nuse types::errors::NodeError;\n\nimpl SigningState {\n    pub fn start_signing_session\u003cN: Network, D: Db\u003e(\n        \u0026mut self,\n        node: \u0026mut NodeState\u003cN, D\u003e,\n        message_hex: \u0026str,\n    ) -\u003e Result\u003cOption\u003cu64\u003e, NodeError\u003e {\n        if node.private_key_package.is_none() || node.pubkey_package.is_none() {\n            error!(\"❌ DKG not completed – cannot start signing\");\n            return Err(NodeError::Error(\"DKG not completed\".to_string()));\n        }\n\n        let Ok(message) = hex::decode(message_hex.trim()) else {\n            error!(\"❌ Invalid hex message\");\n            return Err(NodeError::Error(\"Invalid hex message\".to_string()));\n        };\n        if message.len() != 32 {\n            error!(\n                \"❌ Message must be 32-byte (sighash) – got {} bytes\",\n                message.len()\n            );\n            return Err(NodeError::Error(\n                \"Message must be 32-byte (sighash)\".to_string(),\n            ));\n        }\n\n        info!(\"Starting signing session for message: {}\", message_hex);\n\n        if self.active_signing.is_some() {\n            error!(\"❌ A signing session is already active\");\n            return Err(NodeError::Error(\n                \"A signing session is already active\".to_string(),\n            ));\n        }\n\n        let sign_id = node.rng.next_u64();\n        let self_identifier = peer_id_to_identifier(\u0026node.peer_id);\n\n        // Select participants: self + first (min_signers -1) peers\n        let required = (node.min_signers - 1) as usize;\n        if node.peers.len() \u003c required {\n            error!(\"❌ Not enough peers – need at least {} others\", required);\n            return Err(NodeError::Error(\"Not enough peers\".to_string()));\n        }\n        // Randomly shuffle peers and pick required number\n        let mut rng_rand = rand::rng();\n        let mut peer_pool = node.peers.clone().into_iter().collect::\u003cVec\u003c_\u003e\u003e();\n        peer_pool.shuffle(\u0026mut rng_rand);\n\n        let selected_peers: Vec\u003cPeerId\u003e = peer_pool.into_iter().take(required).collect();\n\n        let mut participants: Vec\u003c_\u003e = Vec::new();\n        participants.push(self_identifier);\n        for peer in \u0026selected_peers {\n            participants.push(peer_id_to_identifier(peer));\n        }\n\n        // Generate nonces \u0026 commitments for self\n        let key_pkg = match node.private_key_package.as_ref() {\n            Some(key_pkg) =\u003e key_pkg.clone(),\n            None =\u003e {\n                return Err(NodeError::Error(\"No private key found\".to_string()));\n            }\n        };\n        let (nonces, commitments) = frost::round1::commit(key_pkg.signing_share(), \u0026mut node.rng);\n\n        let mut commitments_map = BTreeMap::new();\n        commitments_map.insert(self_identifier, commitments);\n\n        // Save active session\n        self.active_signing = Some(ActiveSigning {\n            sign_id,\n            message: message.clone(),\n            selected_peers: selected_peers.clone(),\n            nonces,\n            commitments: commitments_map,\n            signature_shares: BTreeMap::new(),\n            signing_package: None,\n            is_coordinator: true,\n        });\n\n        // Broadcast SignRequest to chosen peers (skip self)\n        for peer in \u0026selected_peers {\n            let req = DirectMessage::SignRequest {\n                sign_id,\n                message: message.clone(),\n            };\n            node.network_handle\n                .send_private_message(*peer, req)\n                .map_err(|e| {\n                    NodeError::Error(format!(\"Failed to send private request: {:?}\", e))\n                })?;\n        }\n\n        Ok(Some(sign_id))\n    }\n\n    /// Handle incoming SignRequest (participant side)\n    pub fn handle_sign_request\u003cN: Network, D: Db\u003e(\n        \u0026mut self,\n        node: \u0026mut NodeState\u003cN, D\u003e,\n        peer: PeerId,\n        sign_id: u64,\n        message: Vec\u003cu8\u003e,\n    ) -\u003e Result\u003c(), NodeError\u003e {\n        if node.private_key_package.is_none() {\n            let _ = node.network_handle.send_private_message(\n                peer,\n                DirectMessage::Commitments {\n                    sign_id,\n                    commitments: Vec::new(),\n                },\n            );\n            return Ok(());\n        }\n\n        let key_pkg = match node.private_key_package.as_ref() {\n            Some(key_pkg) =\u003e key_pkg.clone(),\n            None =\u003e {\n                return Err(NodeError::Error(\"No private key found\".to_string()));\n            }\n        };\n        let (nonces, commitments) = frost::round1::commit(key_pkg.signing_share(), \u0026mut node.rng);\n\n        // Save session (one at a time for simplicity)\n        self.active_signing = Some(ActiveSigning {\n            sign_id,\n            message: message.clone(),\n            selected_peers: Vec::new(),\n            nonces,\n            commitments: BTreeMap::new(), // not used for participant\n            signature_shares: BTreeMap::new(),\n            signing_package: None,\n            is_coordinator: false,\n        });\n\n        let Ok(commit_bytes) = commitments.serialize() else {\n            return Err(NodeError::Error(\n                \"Failed to serialize commitments\".to_string(),\n            ));\n        };\n\n        let resp = DirectMessage::Commitments {\n            sign_id,\n            commitments: commit_bytes,\n        };\n        let _ = node.network_handle.send_private_message(peer, resp);\n\n        debug!(\n            \"🔐 Provided commitments for sign_id {} to {}\",\n            sign_id, peer\n        );\n\n        Ok(())\n    }\n\n    /// Coordinator receives commitments responses\n    pub fn handle_commitments_response\u003cN: Network, D: Db\u003e(\n        \u0026mut self,\n        node: \u0026mut NodeState\u003cN, D\u003e,\n        peer: PeerId,\n        sign_id: u64,\n        commitments_bytes: Vec\u003cu8\u003e,\n    ) -\u003e Result\u003c(), NodeError\u003e {\n        let Some(active) = self.active_signing.as_mut() else {\n            return Err(NodeError::Error(\"No active session\".to_string()));\n        };\n        if !active.is_coordinator || active.sign_id != sign_id {\n            return Err(NodeError::Error(\"Session id mismatch\".to_string()));\n        }\n\n        let Ok(commitments) = frost::round1::SigningCommitments::deserialize(\u0026commitments_bytes)\n        else {\n            warn!(\"Failed to deserialize commitments from {}\", peer);\n            return Err(NodeError::Error(\n                \"Failed to deserialize commitments\".to_string(),\n            ));\n        };\n        let identifier = peer_id_to_identifier(\u0026peer);\n        active.commitments.insert(identifier, commitments);\n        debug!(\n            \"📩 Received commitments from {} (total {}/{})\",\n            peer,\n            active.commitments.len(),\n            node.min_signers\n        );\n\n        if active.commitments.len() == node.min_signers as usize {\n            // Build signing package\n            let signing_package =\n                frost::SigningPackage::new(active.commitments.clone(), \u0026active.message);\n            active.signing_package = Some(signing_package.clone());\n            let Ok(pkg_bytes) = signing_package.serialize() else {\n                warn!(\"Failed to serialize signing package\");\n                return Err(NodeError::Error(\n                    \"Failed to serialize signing package\".to_string(),\n                ));\n            };\n\n            // Send package to participants (excluding self)\n            for peer in \u0026active.selected_peers {\n                let req = DirectMessage::SignPackage {\n                    sign_id,\n                    package: pkg_bytes.clone(),\n                };\n                let _ = node.network_handle.send_private_message(*peer, req);\n            }\n\n            // Generate our signature share\n            let sig_share = frost::round2::sign(\n                \u0026signing_package,\n                \u0026active.nonces,\n                match node.private_key_package.as_ref() {\n                    Some(key_pkg) =\u003e key_pkg,\n                    None =\u003e {\n                        return Err(NodeError::Error(\"No private key found\".to_string()));\n                    }\n                },\n            );\n            match sig_share {\n                Ok(sig_share) =\u003e {\n                    active\n                        .signature_shares\n                        .insert(peer_id_to_identifier(\u0026node.peer_id), sig_share);\n                }\n                Err(e) =\u003e {\n                    return Err(NodeError::Error(format!(\"Failed to sign: {}\", e)));\n                }\n            }\n\n            debug!(\"📦 Distributed signing package for session {}\", sign_id);\n        }\n\n        Ok(())\n    }\n\n    /// Participant handles SignPackage request\n    pub fn handle_sign_package\u003cN: Network, D: Db\u003e(\n        \u0026mut self,\n        node: \u0026mut NodeState\u003cN, D\u003e,\n        peer: PeerId,\n        sign_id: u64,\n        package_bytes: Vec\u003cu8\u003e,\n    ) -\u003e Result\u003c(), NodeError\u003e {\n        let Some(active) = self.active_signing.as_ref() else {\n            warn!(\"No active session to sign\");\n            return Err(NodeError::Error(\"No active session\".to_string()));\n        };\n        if active.sign_id != sign_id {\n            warn!(\"Session id mismatch\");\n            return Err(NodeError::Error(\"Session id mismatch\".to_string()));\n        }\n\n        let Ok(signing_package) = frost::SigningPackage::deserialize(\u0026package_bytes) else {\n            warn!(\"Failed to deserialize signing package\");\n            return Err(NodeError::Error(\n                \"Failed to deserialize signing package\".to_string(),\n            ));\n        };\n\n        let sig_share = frost::round2::sign(\n            \u0026signing_package,\n            \u0026active.nonces,\n            match node.private_key_package.as_ref() {\n                Some(key_pkg) =\u003e key_pkg,\n                None =\u003e {\n                    return Err(NodeError::Error(\"No private key found\".to_string()));\n                }\n            },\n        );\n        match sig_share {\n            Ok(sig_share) =\u003e {\n                let sig_bytes = sig_share.serialize();\n                let resp = DirectMessage::SignatureShare {\n                    sign_id,\n                    signature_share: sig_bytes,\n                };\n                let _ = node.network_handle.send_private_message(peer, resp);\n            }\n            Err(e) =\u003e {\n                return Err(NodeError::Error(format!(\"Failed to sign: {}\", e)));\n            }\n        }\n\n        debug!(\n            \"✍️  Sent signature share for session {} to {}\",\n            sign_id, peer\n        );\n        self.active_signing = None;\n\n        Ok(())\n    }\n\n    /// Coordinator handles incoming signature share\n    pub fn handle_signature_share\u003cN: Network, D: Db\u003e(\n        \u0026mut self,\n        node: \u0026mut NodeState\u003cN, D\u003e,\n        peer: PeerId,\n        sign_id: u64,\n        sig_bytes: Vec\u003cu8\u003e,\n    ) -\u003e Result\u003c(), NodeError\u003e {\n        let Some(active) = self.active_signing.as_mut() else {\n            return Err(NodeError::Error(\"No active session\".to_string()));\n        };\n        if !active.is_coordinator || active.sign_id != sign_id {\n            return Err(NodeError::Error(\"Session id mismatch\".to_string()));\n        }\n\n        let Ok(sig_share) = frost::round2::SignatureShare::deserialize(\u0026sig_bytes) else {\n            warn!(\"Failed to deserialize signature share from {}\", peer);\n            return Err(NodeError::Error(\n                \"Failed to deserialize signature share\".to_string(),\n            ));\n        };\n        let identifier = peer_id_to_identifier(\u0026peer);\n        active.signature_shares.insert(identifier, sig_share);\n        debug!(\n            \"✅ Received signature share from {} (total {}/{})\",\n            peer,\n            active.signature_shares.len(),\n            node.min_signers\n        );\n\n        if active.signature_shares.len() == node.min_signers as usize {\n            let signing_package = match active.signing_package.clone() {\n                Some(signing_package) =\u003e signing_package,\n                None =\u003e {\n                    return Err(NodeError::Error(\"No signing package found\".to_string()));\n                }\n            };\n            let group_sig = frost::aggregate(\n                \u0026signing_package,\n                \u0026active.signature_shares,\n                match node.pubkey_package.as_ref() {\n                    Some(public_key) =\u003e public_key,\n                    None =\u003e {\n                        return Err(NodeError::Error(\"No public key found\".to_string()));\n                    }\n                },\n            )\n            .expect(\"Aggregate\");\n            let sig_hex = hex::encode(group_sig.serialize().expect(\"serialize group sig\"));\n            debug!(\n                \"🎉 Final FROST signature for session {}: {}\",\n                sign_id, sig_hex\n            );\n\n            // If this signing session corresponds to a pending spend, finalise the transaction.\n            if let Some(pending) = self.pending_spends.remove(\u0026sign_id) {\n                match Self::frost_signature_to_bitcoin(\u0026group_sig) {\n                    Ok(bitcoin_sig) =\u003e {\n                        let mut tx = pending.tx;\n                        let mut witness = bitcoin::witness::Witness::new();\n                        witness.push(bitcoin_sig.as_ref());\n                        if let Some(input) = tx.input.first_mut() {\n                            input.witness = witness;\n                        }\n                        let raw_tx = bitcoin::consensus::encode::serialize(\u0026tx);\n                        debug!(\"📤 Signed transaction (hex): {}\", hex::encode(raw_tx));\n                    }\n                    Err(e) =\u003e debug!(\"❌ Failed to convert signature: {}\", e),\n                }\n            }\n            // Reset\n            self.active_signing = None;\n        }\n\n        Ok(())\n    }\n}\n","traces":[{"line":18,"address":[10134688,10138987,10141592],"length":1,"stats":{"Line":1}},{"line":23,"address":[9763761],"length":1,"stats":{"Line":1}},{"line":24,"address":[6993706,6986427,6993981],"length":1,"stats":{"Line":0}},{"line":25,"address":[6187642],"length":1,"stats":{"Line":0}},{"line":28,"address":[6180262,6180141],"length":1,"stats":{"Line":2}},{"line":29,"address":[9770856,9763942,9770581],"length":1,"stats":{"Line":0}},{"line":30,"address":[6993215],"length":1,"stats":{"Line":0}},{"line":32,"address":[9764006,9764085],"length":1,"stats":{"Line":2}},{"line":33,"address":[9600719,9594647,9600521,9600264],"length":1,"stats":{"Line":0}},{"line":34,"address":[],"length":0,"stats":{"Line":0}},{"line":35,"address":[],"length":0,"stats":{"Line":0}},{"line":37,"address":[10141504],"length":1,"stats":{"Line":0}},{"line":38,"address":[6992444],"length":1,"stats":{"Line":0}},{"line":42,"address":[9594619,9594979,9594685],"length":1,"stats":{"Line":2}},{"line":44,"address":[9594958,9595452],"length":1,"stats":{"Line":2}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[6987607,6987534],"length":1,"stats":{"Line":2}},{"line":52,"address":[9595547],"length":1,"stats":{"Line":1}},{"line":55,"address":[6987645,6987726],"length":1,"stats":{"Line":1}},{"line":56,"address":[9595636,9595690],"length":1,"stats":{"Line":2}},{"line":57,"address":[9768081,9765191,9768380],"length":1,"stats":{"Line":0}},{"line":58,"address":[9768346,9768854],"length":1,"stats":{"Line":0}},{"line":61,"address":[10136262,10136196],"length":1,"stats":{"Line":2}},{"line":62,"address":[10136270,10136340],"length":1,"stats":{"Line":2}},{"line":63,"address":[10136494,10136402],"length":1,"stats":{"Line":2}},{"line":65,"address":[6181773],"length":1,"stats":{"Line":1}},{"line":67,"address":[10136642],"length":1,"stats":{"Line":1}},{"line":68,"address":[6988245],"length":1,"stats":{"Line":1}},{"line":69,"address":[],"length":0,"stats":{"Line":1}},{"line":70,"address":[],"length":0,"stats":{"Line":2}},{"line":74,"address":[9596506],"length":1,"stats":{"Line":1}},{"line":75,"address":[],"length":0,"stats":{"Line":1}},{"line":76,"address":[],"length":0,"stats":{"Line":0}},{"line":77,"address":[6988630],"length":1,"stats":{"Line":0}},{"line":80,"address":[],"length":0,"stats":{"Line":1}},{"line":82,"address":[],"length":0,"stats":{"Line":1}},{"line":83,"address":[],"length":0,"stats":{"Line":1}},{"line":86,"address":[6989311,6989611],"length":1,"stats":{"Line":1}},{"line":87,"address":[],"length":0,"stats":{"Line":0}},{"line":88,"address":[],"length":0,"stats":{"Line":1}},{"line":89,"address":[6182870],"length":1,"stats":{"Line":1}},{"line":90,"address":[],"length":0,"stats":{"Line":0}},{"line":91,"address":[9766661],"length":1,"stats":{"Line":1}},{"line":92,"address":[10137725],"length":1,"stats":{"Line":1}},{"line":93,"address":[10137806],"length":1,"stats":{"Line":1}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":98,"address":[],"length":0,"stats":{"Line":1}},{"line":101,"address":[6183618],"length":1,"stats":{"Line":1}},{"line":103,"address":[9598217,9598151,9598387],"length":1,"stats":{"Line":2}},{"line":104,"address":[9767630],"length":1,"stats":{"Line":1}},{"line":105,"address":[9254992,9255214],"length":1,"stats":{"Line":0}},{"line":106,"address":[6556546,6556486],"length":1,"stats":{"Line":0}},{"line":110,"address":[10138411],"length":1,"stats":{"Line":1}},{"line":114,"address":[9774291,9774644,9771872],"length":1,"stats":{"Line":1}},{"line":121,"address":[6177255,6177336],"length":1,"stats":{"Line":2}},{"line":122,"address":[6177381,6179793],"length":1,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":0}},{"line":124,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[],"length":0,"stats":{"Line":0}},{"line":126,"address":[10143120],"length":1,"stats":{"Line":0}},{"line":129,"address":[6997046],"length":1,"stats":{"Line":0}},{"line":132,"address":[6994595,6994530],"length":1,"stats":{"Line":2}},{"line":133,"address":[],"length":0,"stats":{"Line":1}},{"line":134,"address":[],"length":0,"stats":{"Line":0}},{"line":135,"address":[9602728],"length":1,"stats":{"Line":0}},{"line":138,"address":[10143362],"length":1,"stats":{"Line":1}},{"line":141,"address":[],"length":0,"stats":{"Line":1}},{"line":142,"address":[],"length":0,"stats":{"Line":0}},{"line":143,"address":[],"length":0,"stats":{"Line":1}},{"line":144,"address":[],"length":0,"stats":{"Line":1}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[6177854],"length":1,"stats":{"Line":1}},{"line":147,"address":[9603146],"length":1,"stats":{"Line":1}},{"line":148,"address":[6995140],"length":1,"stats":{"Line":1}},{"line":149,"address":[],"length":0,"stats":{"Line":0}},{"line":152,"address":[],"length":0,"stats":{"Line":2}},{"line":153,"address":[9774344],"length":1,"stats":{"Line":0}},{"line":154,"address":[9604833],"length":1,"stats":{"Line":0}},{"line":162,"address":[],"length":0,"stats":{"Line":2}},{"line":164,"address":[],"length":0,"stats":{"Line":1}},{"line":165,"address":[],"length":0,"stats":{"Line":0}},{"line":166,"address":[],"length":0,"stats":{"Line":0}},{"line":169,"address":[9773736],"length":1,"stats":{"Line":1}},{"line":173,"address":[9609521,9605200,9611339],"length":1,"stats":{"Line":1}},{"line":180,"address":[6997193,6997268],"length":1,"stats":{"Line":2}},{"line":181,"address":[7003055,6997342],"length":1,"stats":{"Line":0}},{"line":183,"address":[9605534,9605447],"length":1,"stats":{"Line":2}},{"line":184,"address":[10145988,10151651],"length":1,"stats":{"Line":0}},{"line":187,"address":[6997587,6997443],"length":1,"stats":{"Line":2}},{"line":188,"address":[],"length":0,"stats":{"Line":0}},{"line":189,"address":[9779826,9780083,9775120],"length":1,"stats":{"Line":0}},{"line":190,"address":[],"length":0,"stats":{"Line":0}},{"line":191,"address":[],"length":0,"stats":{"Line":0}},{"line":194,"address":[6196037],"length":1,"stats":{"Line":1}},{"line":195,"address":[9775216],"length":1,"stats":{"Line":1}},{"line":196,"address":[10146367,10146963,10146704],"length":1,"stats":{"Line":0}},{"line":197,"address":[],"length":0,"stats":{"Line":0}},{"line":198,"address":[],"length":0,"stats":{"Line":0}},{"line":199,"address":[],"length":0,"stats":{"Line":0}},{"line":200,"address":[],"length":0,"stats":{"Line":0}},{"line":203,"address":[],"length":0,"stats":{"Line":2}},{"line":205,"address":[10147389,10150821],"length":1,"stats":{"Line":1}},{"line":206,"address":[],"length":0,"stats":{"Line":0}},{"line":207,"address":[9607062,9607141],"length":1,"stats":{"Line":2}},{"line":208,"address":[6999262,6999201],"length":1,"stats":{"Line":2}},{"line":209,"address":[],"length":0,"stats":{"Line":0}},{"line":210,"address":[10150714],"length":1,"stats":{"Line":0}},{"line":211,"address":[9779257],"length":1,"stats":{"Line":0}},{"line":216,"address":[6999381,6999294],"length":1,"stats":{"Line":2}},{"line":219,"address":[],"length":0,"stats":{"Line":1}},{"line":221,"address":[],"length":0,"stats":{"Line":1}},{"line":226,"address":[],"length":0,"stats":{"Line":0}},{"line":227,"address":[6198024],"length":1,"stats":{"Line":1}},{"line":228,"address":[9777192],"length":1,"stats":{"Line":1}},{"line":229,"address":[6198117],"length":1,"stats":{"Line":1}},{"line":230,"address":[],"length":0,"stats":{"Line":0}},{"line":231,"address":[],"length":0,"stats":{"Line":0}},{"line":235,"address":[9777463],"length":1,"stats":{"Line":1}},{"line":236,"address":[6999931],"length":1,"stats":{"Line":1}},{"line":237,"address":[6198463,6198511],"length":1,"stats":{"Line":2}},{"line":238,"address":[],"length":0,"stats":{"Line":0}},{"line":239,"address":[],"length":0,"stats":{"Line":1}},{"line":241,"address":[],"length":0,"stats":{"Line":0}},{"line":242,"address":[9777525,9778576],"length":1,"stats":{"Line":0}},{"line":246,"address":[7000102,7000424],"length":1,"stats":{"Line":1}},{"line":249,"address":[6998729],"length":1,"stats":{"Line":1}},{"line":253,"address":[9616132,9613781,9611360],"length":1,"stats":{"Line":1}},{"line":260,"address":[6172490,6172561],"length":1,"stats":{"Line":2}},{"line":261,"address":[],"length":0,"stats":{"Line":0}},{"line":262,"address":[10156540,10156109],"length":1,"stats":{"Line":0}},{"line":264,"address":[9781056],"length":1,"stats":{"Line":1}},{"line":265,"address":[9784111,9784368,9781141],"length":1,"stats":{"Line":0}},{"line":266,"address":[9614862,9615295],"length":1,"stats":{"Line":0}},{"line":269,"address":[],"length":0,"stats":{"Line":3}},{"line":270,"address":[7005889,7005555],"length":1,"stats":{"Line":0}},{"line":271,"address":[7006308],"length":1,"stats":{"Line":0}},{"line":272,"address":[9614087],"length":1,"stats":{"Line":0}},{"line":277,"address":[],"length":0,"stats":{"Line":0}},{"line":278,"address":[10152370],"length":1,"stats":{"Line":1}},{"line":279,"address":[10152460,10152382],"length":1,"stats":{"Line":2}},{"line":280,"address":[6173051],"length":1,"stats":{"Line":1}},{"line":281,"address":[],"length":0,"stats":{"Line":0}},{"line":282,"address":[6173097],"length":1,"stats":{"Line":0}},{"line":286,"address":[10152697],"length":1,"stats":{"Line":1}},{"line":287,"address":[9612293],"length":1,"stats":{"Line":1}},{"line":288,"address":[6173381],"length":1,"stats":{"Line":1}},{"line":293,"address":[],"length":0,"stats":{"Line":1}},{"line":295,"address":[6173255],"length":1,"stats":{"Line":0}},{"line":296,"address":[6173303,6174598],"length":1,"stats":{"Line":0}},{"line":300,"address":[9612564,9612904],"length":1,"stats":{"Line":1}},{"line":301,"address":[],"length":0,"stats":{"Line":0}},{"line":302,"address":[],"length":0,"stats":{"Line":0}},{"line":304,"address":[6173918,6174453],"length":1,"stats":{"Line":1}},{"line":306,"address":[10154010],"length":1,"stats":{"Line":1}},{"line":310,"address":[9616160,9623538,9621530],"length":1,"stats":{"Line":1}},{"line":317,"address":[6188344,6188249],"length":1,"stats":{"Line":2}},{"line":318,"address":[6188418,6195414],"length":1,"stats":{"Line":0}},{"line":320,"address":[9785895,9785982],"length":1,"stats":{"Line":2}},{"line":321,"address":[9616468,9623354],"length":1,"stats":{"Line":0}},{"line":324,"address":[9616535,9616650],"length":1,"stats":{"Line":2}},{"line":325,"address":[10163049,10163306,10157107],"length":1,"stats":{"Line":0}},{"line":326,"address":[9792730],"length":1,"stats":{"Line":0}},{"line":327,"address":[],"length":0,"stats":{"Line":0}},{"line":330,"address":[7008442],"length":1,"stats":{"Line":1}},{"line":331,"address":[10157221],"length":1,"stats":{"Line":1}},{"line":332,"address":[7009129],"length":1,"stats":{"Line":1}},{"line":333,"address":[],"length":0,"stats":{"Line":0}},{"line":334,"address":[],"length":0,"stats":{"Line":0}},{"line":335,"address":[],"length":0,"stats":{"Line":0}},{"line":336,"address":[],"length":0,"stats":{"Line":0}},{"line":339,"address":[9617809,9617155],"length":1,"stats":{"Line":2}},{"line":340,"address":[9617869],"length":1,"stats":{"Line":1}},{"line":341,"address":[],"length":0,"stats":{"Line":1}},{"line":342,"address":[],"length":0,"stats":{"Line":0}},{"line":343,"address":[6190100],"length":1,"stats":{"Line":0}},{"line":347,"address":[],"length":0,"stats":{"Line":0}},{"line":348,"address":[9787549],"length":1,"stats":{"Line":1}},{"line":349,"address":[7009811,7010029],"length":1,"stats":{"Line":2}},{"line":350,"address":[9787832],"length":1,"stats":{"Line":1}},{"line":351,"address":[],"length":0,"stats":{"Line":0}},{"line":352,"address":[9618403],"length":1,"stats":{"Line":0}},{"line":357,"address":[9618565],"length":1,"stats":{"Line":1}},{"line":358,"address":[7010750,7010365,7010444],"length":1,"stats":{"Line":2}},{"line":359,"address":[],"length":0,"stats":{"Line":0}},{"line":360,"address":[],"length":0,"stats":{"Line":0}},{"line":364,"address":[10159513,10160059,10162822],"length":1,"stats":{"Line":2}},{"line":365,"address":[10160168,10160258],"length":1,"stats":{"Line":0}},{"line":366,"address":[7011529],"length":1,"stats":{"Line":0}},{"line":367,"address":[9619909],"length":1,"stats":{"Line":0}},{"line":368,"address":[10160485],"length":1,"stats":{"Line":0}},{"line":369,"address":[9789589,9789512],"length":1,"stats":{"Line":0}},{"line":370,"address":[9620136,9620462],"length":1,"stats":{"Line":0}},{"line":371,"address":[],"length":0,"stats":{"Line":0}},{"line":373,"address":[],"length":0,"stats":{"Line":0}},{"line":374,"address":[9790020,9790304,9789944],"length":1,"stats":{"Line":0}},{"line":376,"address":[7011466,7013248],"length":1,"stats":{"Line":0}},{"line":380,"address":[],"length":0,"stats":{"Line":1}},{"line":383,"address":[],"length":0,"stats":{"Line":1}}],"covered":103,"coverable":200},{"path":["/","home","vidyootsenthil","Documents","TheValut-nameTBD","crates","node","src","signing","handler.rs"],"content":"use crate::NodeState;\nuse crate::db::Db;\nuse crate::handler::Handler;\nuse crate::signing::SigningState;\nuse crate::swarm_manager::{DirectMessage, Network, NetworkEvent, SelfRequest, SelfResponse};\nuse types::errors::NodeError;\n\n#[async_trait::async_trait]\nimpl\u003cN: Network, D: Db\u003e Handler\u003cN, D\u003e for SigningState {\n    async fn handle(\n        \u0026mut self,\n        node: \u0026mut NodeState\u003cN, D\u003e,\n        message: Option\u003cNetworkEvent\u003e,\n    ) -\u003e Result\u003c(), NodeError\u003e {\n        match message {\n            Some(NetworkEvent::SelfRequest {\n                request: SelfRequest::StartSigningSession { hex_message },\n                ..\n            }) =\u003e {\n                let _ = self.start_signing_session(node, \u0026hex_message)?;\n            }\n            Some(NetworkEvent::SelfRequest {\n                request:\n                    SelfRequest::Spend {\n                        amount_sat,\n                        address_to,\n                    },\n                response_channel,\n            }) =\u003e {\n                let response = self.start_spend_request(node, amount_sat, \u0026address_to);\n                if let Some(response_channel) = response_channel {\n                    response_channel\n                        .send(SelfResponse::SpendRequestSent {\n                            sighash: response.unwrap_or(\"No sighash\".to_string()),\n                        })\n                        .map_err(|e| NodeError::Error(format!(\"Failed to send response: {}\", e)))?;\n                }\n            }\n            Some(NetworkEvent::MessageEvent((\n                peer,\n                DirectMessage::SignRequest { sign_id, message },\n            ))) =\u003e self.handle_sign_request(node, peer, sign_id, message)?,\n            Some(NetworkEvent::MessageEvent((\n                peer,\n                DirectMessage::SignPackage { sign_id, package },\n            ))) =\u003e self.handle_sign_package(node, peer, sign_id, package)?,\n            Some(NetworkEvent::MessageEvent((\n                peer,\n                DirectMessage::Commitments {\n                    sign_id,\n                    commitments,\n                },\n            ))) =\u003e self.handle_commitments_response(node, peer, sign_id, commitments)?,\n            Some(NetworkEvent::MessageEvent((\n                peer,\n                DirectMessage::SignatureShare {\n                    sign_id,\n                    signature_share,\n                },\n            ))) =\u003e self.handle_signature_share(node, peer, sign_id, signature_share)?,\n            _ =\u003e (),\n        }\n\n        Ok(())\n    }\n}\n","traces":[{"line":15,"address":[8729301,8729495],"length":1,"stats":{"Line":4}},{"line":16,"address":[9147725],"length":1,"stats":{"Line":1}},{"line":17,"address":[],"length":0,"stats":{"Line":0}},{"line":18,"address":[],"length":0,"stats":{"Line":0}},{"line":19,"address":[],"length":0,"stats":{"Line":0}},{"line":20,"address":[8729653,8729909],"length":1,"stats":{"Line":2}},{"line":22,"address":[9147813],"length":1,"stats":{"Line":0}},{"line":23,"address":[],"length":0,"stats":{"Line":0}},{"line":24,"address":[],"length":0,"stats":{"Line":0}},{"line":25,"address":[],"length":0,"stats":{"Line":0}},{"line":26,"address":[],"length":0,"stats":{"Line":0}},{"line":28,"address":[],"length":0,"stats":{"Line":0}},{"line":29,"address":[],"length":0,"stats":{"Line":0}},{"line":30,"address":[],"length":0,"stats":{"Line":0}},{"line":31,"address":[6231322],"length":1,"stats":{"Line":0}},{"line":32,"address":[],"length":0,"stats":{"Line":0}},{"line":33,"address":[8730599],"length":1,"stats":{"Line":0}},{"line":34,"address":[8730954,8730507,8730409],"length":1,"stats":{"Line":0}},{"line":36,"address":[8734534,8730809,8734512],"length":1,"stats":{"Line":0}},{"line":39,"address":[],"length":0,"stats":{"Line":1}},{"line":40,"address":[],"length":0,"stats":{"Line":0}},{"line":41,"address":[],"length":0,"stats":{"Line":0}},{"line":42,"address":[],"length":0,"stats":{"Line":0}},{"line":43,"address":[9149663],"length":1,"stats":{"Line":1}},{"line":44,"address":[],"length":0,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[8731828],"length":1,"stats":{"Line":1}},{"line":48,"address":[],"length":0,"stats":{"Line":0}},{"line":49,"address":[],"length":0,"stats":{"Line":0}},{"line":50,"address":[],"length":0,"stats":{"Line":0}},{"line":51,"address":[],"length":0,"stats":{"Line":0}},{"line":53,"address":[],"length":0,"stats":{"Line":0}},{"line":54,"address":[],"length":0,"stats":{"Line":1}},{"line":55,"address":[],"length":0,"stats":{"Line":0}},{"line":56,"address":[],"length":0,"stats":{"Line":0}},{"line":57,"address":[],"length":0,"stats":{"Line":0}},{"line":58,"address":[],"length":0,"stats":{"Line":0}},{"line":60,"address":[],"length":0,"stats":{"Line":0}},{"line":61,"address":[],"length":0,"stats":{"Line":0}},{"line":64,"address":[],"length":0,"stats":{"Line":4}}],"covered":8,"coverable":41},{"path":["/","home","vidyootsenthil","Documents","TheValut-nameTBD","crates","node","src","signing","mod.rs"],"content":"pub mod create_signature;\npub mod handler;\npub mod utils;\nuse std::collections::BTreeMap;\n\nuse frost_secp256k1::{self as frost, Identifier};\nuse libp2p::PeerId;\n\n// Active signing session tracking\npub struct ActiveSigning {\n    pub sign_id: u64,\n    pub message: Vec\u003cu8\u003e,\n    pub selected_peers: Vec\u003cPeerId\u003e,\n    pub nonces: frost::round1::SigningNonces,\n    pub commitments: BTreeMap\u003cIdentifier, frost::round1::SigningCommitments\u003e,\n    pub signature_shares: BTreeMap\u003cIdentifier, frost::round2::SignatureShare\u003e,\n    pub signing_package: Option\u003cfrost::SigningPackage\u003e,\n    pub is_coordinator: bool,\n}\n\npub struct SigningState {\n    pub active_signing: Option\u003cActiveSigning\u003e,\n    pub pending_spends: std::collections::BTreeMap\u003cu64, crate::wallet::PendingSpend\u003e,\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","vidyootsenthil","Documents","TheValut-nameTBD","crates","node","src","signing","utils.rs"],"content":"use std::{collections::BTreeMap, str::FromStr};\n\nuse frost_secp256k1::{self as frost};\nuse tracing::{error, info};\nuse types::errors::NodeError;\n\nuse crate::{NodeState, db::Db, signing::SigningState, swarm_manager::Network};\n\nimpl SigningState {\n    pub fn new() -\u003e Result\u003cSelf, NodeError\u003e {\n        Ok(SigningState {\n            active_signing: None,\n            pending_spends: BTreeMap::new(),\n        })\n    }\n\n    pub fn frost_signature_to_bitcoin(\n        frost_sig: \u0026frost::Signature,\n    ) -\u003e Result\u003cbitcoin::secp256k1::schnorr::Signature, String\u003e {\n        let sig_bytes = frost_sig\n            .serialize()\n            .map_err(|e| format!(\"Serialize frost sig: {}\", e))?;\n\n        let schnorr_bytes = match sig_bytes.len() {\n            64 =\u003e sig_bytes,\n            65 =\u003e sig_bytes[..64].to_vec(),\n            _ =\u003e return Err(format!(\"Unsupported signature len {}\", sig_bytes.len())),\n        };\n\n        bitcoin::secp256k1::schnorr::Signature::from_slice(\u0026schnorr_bytes)\n            .map_err(|e| format!(\"Parse schnorr sig: {}\", e))\n    }\n\n    pub fn start_spend_request\u003cN: Network, D: Db\u003e(\n        \u0026mut self,\n        node: \u0026mut NodeState\u003cN, D\u003e,\n        amount_sat: u64,\n        address: \u0026str,\n    ) -\u003e Option\u003cString\u003e {\n        info!(\"🚀 Creating spend request for {} sat\", amount_sat);\n        let address = bitcoin::Address::from_str(address).ok()?.assume_checked();\n        match node.wallet.create_spend(amount_sat, \u0026address) {\n            Ok((tx, sighash)) =\u003e {\n                let sighash_hex = hex::encode(sighash);\n                match self.start_signing_session(node, \u0026sighash_hex) {\n                    Ok(_) =\u003e (),\n                    Err(e) =\u003e {\n                        error!(\"❌ Failed to start signing session: {}\", e);\n                        return None;\n                    }\n                }\n\n                if let Some(active) = \u0026self.active_signing {\n                    self.pending_spends\n                        .insert(active.sign_id, crate::wallet::PendingSpend { tx });\n                    info!(\"🚀 Spend request prepared (session id {})\", active.sign_id);\n\n                    Some(hex::encode(sighash))\n                } else {\n                    error!(\"❌ Failed to start signing session\");\n                    None\n                }\n            }\n            Err(e) =\u003e {\n                error!(\"❌ Failed to create spend transaction: {}\", e);\n                None\n            }\n        }\n    }\n}\n","traces":[{"line":10,"address":[9253314,9253320,9253120],"length":1,"stats":{"Line":7}},{"line":11,"address":[9295362],"length":1,"stats":{"Line":3}},{"line":12,"address":[9295291],"length":1,"stats":{"Line":3}},{"line":13,"address":[8821491],"length":1,"stats":{"Line":8}},{"line":17,"address":[6096512,6097156,6097370],"length":1,"stats":{"Line":0}},{"line":20,"address":[6096655,6096537],"length":1,"stats":{"Line":0}},{"line":22,"address":[6380272,6380289],"length":1,"stats":{"Line":0}},{"line":24,"address":[6096741,6096808],"length":1,"stats":{"Line":0}},{"line":25,"address":[6096853],"length":1,"stats":{"Line":0}},{"line":26,"address":[6096902,6096978],"length":1,"stats":{"Line":0}},{"line":27,"address":[8821997,8822335],"length":1,"stats":{"Line":0}},{"line":30,"address":[6096940,6097060],"length":1,"stats":{"Line":0}},{"line":31,"address":[6380424,6380400],"length":1,"stats":{"Line":0}},{"line":34,"address":[9797330,9797324,9793024],"length":1,"stats":{"Line":0}},{"line":40,"address":[7015603,7015311],"length":1,"stats":{"Line":0}},{"line":41,"address":[9793859,9793319],"length":1,"stats":{"Line":0}},{"line":42,"address":[6202564],"length":1,"stats":{"Line":0}},{"line":43,"address":[9624587],"length":1,"stats":{"Line":0}},{"line":44,"address":[10165187],"length":1,"stats":{"Line":0}},{"line":45,"address":[],"length":0,"stats":{"Line":0}},{"line":46,"address":[],"length":0,"stats":{"Line":0}},{"line":47,"address":[],"length":0,"stats":{"Line":0}},{"line":48,"address":[6205149,6203090,6205415],"length":1,"stats":{"Line":0}},{"line":49,"address":[9627291],"length":1,"stats":{"Line":0}},{"line":53,"address":[9795969,9794494],"length":1,"stats":{"Line":0}},{"line":54,"address":[7016895,7016726],"length":1,"stats":{"Line":0}},{"line":55,"address":[9794757,9794556],"length":1,"stats":{"Line":0}},{"line":56,"address":[10166162,10165800],"length":1,"stats":{"Line":0}},{"line":58,"address":[9795076,9795619],"length":1,"stats":{"Line":0}},{"line":60,"address":[6204605,6204314,6203361],"length":1,"stats":{"Line":0}},{"line":61,"address":[9626484],"length":1,"stats":{"Line":0}},{"line":64,"address":[9624524],"length":1,"stats":{"Line":0}},{"line":65,"address":[],"length":0,"stats":{"Line":0}},{"line":66,"address":[],"length":0,"stats":{"Line":0}}],"covered":4,"coverable":34},{"path":["/","home","vidyootsenthil","Documents","TheValut-nameTBD","crates","node","src","start_node.rs"],"content":"use types::errors::NodeError;\n\nuse crate::{\n    NodeConfig, NodeState, db::RocksDb, grpc::grpc_handler::NodeControlService,\n    key_manager::load_and_decrypt_keypair, swarm_manager::build_swarm,\n};\nuse clients::{EsploraApiClient, WindowedConfirmedTransactionProvider};\nuse esplora_client::Builder;\nuse std::path::{Path, PathBuf};\nuse tokio::sync::broadcast;\nuse tonic::transport::Server;\nuse tracing::{error, info};\nuse tracing_appender::rolling::{RollingFileAppender, Rotation};\nuse tracing_subscriber::{EnvFilter, fmt, prelude::*};\n\npub async fn start_node(\n    max_signers: Option\u003cu16\u003e,\n    min_signers: Option\u003cu16\u003e,\n    config: NodeConfig,\n    grpc_port: Option\u003cu16\u003e,\n    log_file: Option\u003cPathBuf\u003e,\n) -\u003e Result\u003c(), NodeError\u003e {\n    // Initialize logging\n    let env_filter = EnvFilter::try_from_default_env().unwrap_or_else(|_| EnvFilter::new(\"info\"));\n\n    let registry = tracing_subscriber::registry().with(env_filter);\n\n    if let Some(log_path) = config.log_file_path.clone().or(log_file) {\n        // File logging\n        let log_dir = Path::new(\u0026log_path);\n\n        if !log_dir.exists() {\n            info!(\"Creating log directory: {:?}\", log_dir);\n            if let Err(e) = std::fs::create_dir_all(log_dir) {\n                error!(\n                    \"Failed to create log directory {}: {}\",\n                    log_dir.display(),\n                    e\n                );\n                return Err(NodeError::Error(e.to_string()));\n            }\n        }\n\n        let file_appender = RollingFileAppender::new(Rotation::DAILY, log_dir, \"node.log\");\n\n        let file_layer = fmt::layer()\n            .with_writer(file_appender)\n            .with_ansi(false)\n            .with_target(true)\n            .with_thread_ids(true)\n            .with_thread_names(true);\n\n        let console_layer = fmt::layer()\n            .with_writer(std::io::stdout)\n            .with_ansi(true)\n            .with_target(false);\n\n        registry.with(file_layer).with(console_layer).init();\n        info!(\n            \"Logging initialized with file output: {}\",\n            log_path.display()\n        );\n    } else {\n        // Console-only logging\n        let console_layer = fmt::layer()\n            .with_writer(std::io::stdout)\n            .with_ansi(true)\n            .with_target(false);\n\n        registry.with(console_layer).init();\n        info!(\"Logging initialized with console output only\");\n    }\n\n    let keypair = match load_and_decrypt_keypair(\u0026config) {\n        Ok(kp) =\u003e kp,\n        Err(e) =\u003e {\n            error!(\"Failed to decrypt key: {}\", e);\n            return Err(e);\n        }\n    };\n\n    let max_signers = max_signers.unwrap_or(5);\n    let min_signers = min_signers.unwrap_or(3);\n\n    let allowed_peers = config.allowed_peers.clone();\n\n    let (network_handle, mut swarm) =\n        build_swarm(keypair.clone(), allowed_peers.clone()).expect(\"Failed to build swarm\");\n\n    let (deposit_intent_tx, deposit_intent_rx) = broadcast::channel(100);\n\n    let mut node_state = NodeState::new_from_config(\n        network_handle,\n        min_signers,\n        max_signers,\n        config,\n        RocksDb::new(\"nodedb.db\"),\n        swarm.network_events.clone(),\n        deposit_intent_tx,\n    )\n    .expect(\"Failed to create node\");\n\n    let network_handle = node_state.network_handle.clone();\n\n    let swarm_handle = tokio::spawn(async move {\n        swarm.start().await;\n    });\n\n    let grpc_handle = tokio::spawn(async move {\n        let addr = format!(\"0.0.0.0:{}\", grpc_port.unwrap_or(50051))\n            .parse()\n            .unwrap();\n\n        let node_control_service = NodeControlService::new(network_handle);\n\n        info!(\"gRPC server listening on {}\", addr);\n\n        Server::builder()\n            .add_service(node_control_service.into_server())\n            .serve(addr)\n            .await\n            .expect(\"gRPC server failed\");\n    });\n\n    let main_loop_handle = tokio::spawn(async move { node_state.start().await });\n\n    let deposit_monitor_handle = tokio::spawn(async move {\n        let mut client = EsploraApiClient::new(\n            Builder::new(\"https://blockstream.info/testnet/api\")\n                .build_async()\n                .unwrap(),\n            100,\n            Some(deposit_intent_rx),\n        );\n\n        client.poll_new_transactions(vec![]).await;\n    });\n\n    // Wait for either task to complete (they should run indefinitely)\n    tokio::select! {\n        result = grpc_handle =\u003e {\n            match result {\n                Ok(_) =\u003e info!(\"gRPC server stopped\"),\n                Err(e) =\u003e error!(\"gRPC server error: {}\", e),\n            }\n        }\n        result = swarm_handle =\u003e {\n            match result {\n                Ok(_) =\u003e info!(\"Swarm stopped\"),\n                Err(e) =\u003e error!(\"Swarm error: {}\", e),\n            }\n        }\n        result = main_loop_handle =\u003e {\n            match result {\n                Ok(Ok(_)) =\u003e info!(\"Main loop stopped\"),\n                Ok(Err(e)) =\u003e error!(\"Main loop error: {}\", e),\n                Err(e) =\u003e error!(\"Main loop task error: {}\", e),\n            }\n        }\n        result = deposit_monitor_handle =\u003e {\n            match result {\n                Ok(_) =\u003e info!(\"Deposit monitor stopped\"),\n                Err(e) =\u003e error!(\"Deposit monitor error: {}\", e),\n            }\n        }\n    }\n\n    Ok(())\n}\n","traces":[{"line":16,"address":[7273296],"length":1,"stats":{"Line":0}},{"line":24,"address":[12611872,12592542,12611856,12592667],"length":1,"stats":{"Line":0}},{"line":26,"address":[8714760,8714842],"length":1,"stats":{"Line":0}},{"line":28,"address":[9488535,9488453],"length":1,"stats":{"Line":0}},{"line":30,"address":[9488686,9488803],"length":1,"stats":{"Line":0}},{"line":32,"address":[12593267],"length":1,"stats":{"Line":0}},{"line":33,"address":[12593704,12593401,12593310],"length":1,"stats":{"Line":0}},{"line":34,"address":[9162386,9161874],"length":1,"stats":{"Line":0}},{"line":35,"address":[9490434,9489785,9490181,9489886],"length":1,"stats":{"Line":0}},{"line":40,"address":[8716619,8717225],"length":1,"stats":{"Line":0}},{"line":44,"address":[8715370,8717394],"length":1,"stats":{"Line":0}},{"line":46,"address":[9163713,9163594],"length":1,"stats":{"Line":0}},{"line":47,"address":[8717463],"length":1,"stats":{"Line":0}},{"line":53,"address":[12595725,12595665],"length":1,"stats":{"Line":0}},{"line":58,"address":[9491365],"length":1,"stats":{"Line":0}},{"line":59,"address":[8718502],"length":1,"stats":{"Line":0}},{"line":65,"address":[9165205],"length":1,"stats":{"Line":0}},{"line":70,"address":[12597104],"length":1,"stats":{"Line":0}},{"line":71,"address":[9492763],"length":1,"stats":{"Line":0}},{"line":74,"address":[9493478,9492468],"length":1,"stats":{"Line":0}},{"line":75,"address":[12598003],"length":1,"stats":{"Line":0}},{"line":76,"address":[9166148],"length":1,"stats":{"Line":0}},{"line":77,"address":[9493524,9497645,9497279],"length":1,"stats":{"Line":0}},{"line":78,"address":[9170200],"length":1,"stats":{"Line":0}},{"line":82,"address":[9493666,9493771],"length":1,"stats":{"Line":0}},{"line":83,"address":[8720151],"length":1,"stats":{"Line":0}},{"line":85,"address":[9166481],"length":1,"stats":{"Line":0}},{"line":87,"address":[9493982,9493898,9493868,9497206],"length":1,"stats":{"Line":0}},{"line":90,"address":[9167066,9166987],"length":1,"stats":{"Line":0}},{"line":93,"address":[8720836],"length":1,"stats":{"Line":0}},{"line":96,"address":[12599055],"length":1,"stats":{"Line":0}},{"line":97,"address":[9167323,9167403],"length":1,"stats":{"Line":0}},{"line":98,"address":[12599203],"length":1,"stats":{"Line":0}},{"line":99,"address":[8721191],"length":1,"stats":{"Line":0}},{"line":103,"address":[12599560,12599653],"length":1,"stats":{"Line":0}},{"line":105,"address":[8721552,8734152,8733759,8733901,8733664,8733689,8734074,8721737],"length":1,"stats":{"Line":0}},{"line":106,"address":[9507598,9507697,9507646,9507799],"length":1,"stats":{"Line":0}},{"line":109,"address":[9180890,9168328,9180747,9182607,9180704,9168088,9182984],"length":1,"stats":{"Line":0}},{"line":110,"address":[12612595,12612775,12612989],"length":1,"stats":{"Line":0}},{"line":112,"address":[9181254,9181143],"length":1,"stats":{"Line":0}},{"line":114,"address":[12613228,12613065],"length":1,"stats":{"Line":0}},{"line":116,"address":[9508795,9509118,9508869],"length":1,"stats":{"Line":0}},{"line":118,"address":[9181748,9182846,9182220,9182423,9182544,9182482,9182788],"length":1,"stats":{"Line":0}},{"line":119,"address":[9509584],"length":1,"stats":{"Line":0}},{"line":120,"address":[12614242],"length":1,"stats":{"Line":0}},{"line":121,"address":[7516253],"length":1,"stats":{"Line":0}},{"line":122,"address":[9510228,9509714],"length":1,"stats":{"Line":0}},{"line":125,"address":[9183040,9183075,9183189,9168524,9168351,9183335,9183566],"length":1,"stats":{"Line":0}},{"line":127,"address":[9183820,9184437,9168547,9183696,9184431,9183721,9184223,9168707],"length":1,"stats":{"Line":0}},{"line":128,"address":[9511115,9511342],"length":1,"stats":{"Line":0}},{"line":129,"address":[8737149,8737262],"length":1,"stats":{"Line":0}},{"line":133,"address":[9511304],"length":1,"stats":{"Line":0}},{"line":136,"address":[9511384,9511191,9511593,9511459],"length":1,"stats":{"Line":0}},{"line":140,"address":[9505932,9505184],"length":1,"stats":{"Line":0}},{"line":168,"address":[9499653],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":55},{"path":["/","home","vidyootsenthil","Documents","TheValut-nameTBD","crates","node","src","swarm_manager.rs"],"content":"use futures::StreamExt;\nuse libp2p::{\n    Multiaddr, PeerId,\n    request_response::{Event, Message},\n    swarm::SwarmEvent,\n};\nuse std::{\n    collections::{BTreeMap, HashSet, hash_map::DefaultHasher},\n    fmt::Debug,\n    future::Future,\n    hash::{Hash, Hasher},\n    pin::Pin,\n    time::Duration,\n};\nuse tracing::info;\n\nuse frost_secp256k1::keys::dkg::round2;\nuse libp2p::{\n    StreamProtocol, Swarm, gossipsub, mdns, noise, request_response, swarm::NetworkBehaviour, tcp,\n    yamux,\n};\nuse libp2p::{identity::Keypair, request_response::cbor};\nuse tokio::{\n    io,\n    sync::{\n        broadcast,\n        mpsc::{self, unbounded_channel},\n    },\n};\n\nuse crate::{PeerData, deposit_intents::DepositIntent};\nuse types::errors::{NetworkError, NodeError};\n\n#[derive(Clone, Debug, serde::Serialize, serde::Deserialize)]\npub struct PingBody {\n    pub message: String,\n}\n\n#[derive(Clone, Debug, serde::Serialize, serde::Deserialize)]\npub enum DirectMessage {\n    Ping(PingBody),\n    Round2Package(round2::Package),\n    SignRequest {\n        sign_id: u64,\n        message: Vec\u003cu8\u003e,\n    },\n    SignPackage {\n        sign_id: u64,\n        package: Vec\u003cu8\u003e,\n    },\n    Pong,\n    Commitments {\n        sign_id: u64,\n        commitments: Vec\u003cu8\u003e,\n    },\n    SignatureShare {\n        sign_id: u64,\n        signature_share: Vec\u003cu8\u003e,\n    },\n}\n\n#[derive(Clone, Debug, serde::Serialize, serde::Deserialize)]\npub enum SelfRequest {\n    GetFrostPublicKey,\n    CreateDeposit { deposit_intent: DepositIntent },\n    GetPendingDepositIntents,\n    StartSigningSession { hex_message: String },\n    Spend { amount_sat: u64, address_to: String },\n}\n\n#[derive(Clone, Debug, serde::Serialize, serde::Deserialize)]\npub enum SelfResponse {\n    GetFrostPublicKeyResponse { public_key: Option\u003cString\u003e },\n    CreateDepositResponse { success: bool },\n    GetPendingDepositIntentsResponse { intents: Vec\u003cDepositIntent\u003e },\n    StartSigningSessionResponse { sign_id: u64 },\n    SpendRequestSent { sighash: String },\n}\n\n#[derive(NetworkBehaviour)]\npub struct MyBehaviour {\n    pub gossipsub: gossipsub::Behaviour,\n    pub mdns: mdns::tokio::Behaviour,\n    pub request_response: cbor::Behaviour\u003cDirectMessage, ()\u003e,\n}\n\n#[derive(Clone, Debug)]\npub enum NetworkMessage {\n    SendBroadcast {\n        topic: gossipsub::IdentTopic,\n        message: Vec\u003cu8\u003e,\n    },\n    SendPrivateMessage(PeerId, DirectMessage),\n    SendSelfRequest {\n        request: SelfRequest,\n        response_channel: Option\u003cmpsc::UnboundedSender\u003cSelfResponse\u003e\u003e,\n    },\n}\n\npub type NetworkResponseFuture =\n    Pin\u003cBox\u003cdyn Future\u003cOutput = Result\u003cSelfResponse, NetworkError\u003e\u003e + Send\u003e\u003e;\n\n#[derive(Debug, Clone)]\npub struct NetworkHandle {\n    peer_id: PeerId,\n    tx: mpsc::UnboundedSender\u003cNetworkMessage\u003e,\n}\n\npub trait Network: Clone + Debug + Sync + Send {\n    fn peer_id(\u0026self) -\u003e PeerId;\n    fn send_broadcast(\n        \u0026self,\n        topic: gossipsub::IdentTopic,\n        message: Vec\u003cu8\u003e,\n    ) -\u003e Result\u003c(), NetworkError\u003e;\n    fn send_private_message(\n        \u0026self,\n        peer_id: PeerId,\n        request: DirectMessage,\n    ) -\u003e Result\u003c(), NetworkError\u003e;\n    fn send_self_request(\n        \u0026self,\n        request: SelfRequest,\n        sync: bool,\n    ) -\u003e Result\u003cOption\u003cNetworkResponseFuture\u003e, NetworkError\u003e;\n}\n\nimpl Network for NetworkHandle {\n    fn peer_id(\u0026self) -\u003e PeerId {\n        self.peer_id\n    }\n\n    fn send_broadcast(\n        \u0026self,\n        topic: gossipsub::IdentTopic,\n        message: Vec\u003cu8\u003e,\n    ) -\u003e Result\u003c(), NetworkError\u003e {\n        let network_message = NetworkMessage::SendBroadcast { topic, message };\n        self.tx\n            .send(network_message)\n            .map_err(|e| NetworkError::SendError(e.to_string()))\n    }\n\n    fn send_private_message(\n        \u0026self,\n        peer_id: PeerId,\n        request: DirectMessage,\n    ) -\u003e Result\u003c(), NetworkError\u003e {\n        let network_message = NetworkMessage::SendPrivateMessage(peer_id, request);\n        self.tx\n            .send(network_message)\n            .map_err(|e| NetworkError::SendError(e.to_string()))\n    }\n\n    fn send_self_request(\n        \u0026self,\n        request: SelfRequest,\n        sync: bool,\n    ) -\u003e Result\u003cOption\u003cNetworkResponseFuture\u003e, NetworkError\u003e {\n        if sync {\n            let (tx, mut rx) = unbounded_channel::\u003cSelfResponse\u003e();\n\n            let network_message = NetworkMessage::SendSelfRequest {\n                request,\n                response_channel: Some(tx),\n            };\n\n            self.tx\n                .send(network_message)\n                .map_err(|e| NetworkError::SendError(e.to_string()))?;\n\n            Ok(Some(Box::pin(async move {\n                rx.recv().await.ok_or(NetworkError::RecvError)\n            })))\n        } else {\n            let network_message = NetworkMessage::SendSelfRequest {\n                request,\n                response_channel: None,\n            };\n\n            self.tx\n                .send(network_message)\n                .map_err(|e| NetworkError::SendError(e.to_string()))?;\n\n            Ok(None)\n        }\n    }\n}\n\n#[derive(Debug, Clone)]\npub enum NetworkEvent {\n    SelfRequest {\n        request: SelfRequest,\n        response_channel: Option\u003cmpsc::UnboundedSender\u003cSelfResponse\u003e\u003e,\n    },\n    Subscribed {\n        peer_id: PeerId,\n        topic: gossipsub::TopicHash,\n    },\n    GossipsubMessage(gossipsub::Message),\n    MessageEvent((PeerId, DirectMessage)),\n    PeersConnected(Vec\u003c(PeerId, Multiaddr)\u003e),\n    PeersDisconnected(Vec\u003c(PeerId, Multiaddr)\u003e),\n    Unknown,\n}\n\npub struct SwarmManager {\n    pub inner: Swarm\u003cMyBehaviour\u003e,\n\n    pub network_manager_rx: mpsc::UnboundedReceiver\u003cNetworkMessage\u003e,\n    pub network_events: broadcast::Sender\u003cNetworkEvent\u003e,\n\n    pub allowed_peers: Vec\u003cPeerId\u003e,\n    pub peers_to_names: BTreeMap\u003cPeerId, String\u003e,\n\n    pub live_peers: HashSet\u003cPeerId\u003e,\n\n    pub round1_topic: gossipsub::IdentTopic,\n    pub start_dkg_topic: gossipsub::IdentTopic,\n    pub deposit_intents_topic: gossipsub::IdentTopic,\n}\n\nimpl SwarmManager {\n    pub fn new(\n        mut swarm: Swarm\u003cMyBehaviour\u003e,\n        peer_data: Vec\u003cPeerData\u003e,\n    ) -\u003e Result\u003c(Self, NetworkHandle), NodeError\u003e {\n        let (send_commands, receiving_commands) = unbounded_channel::\u003cNetworkMessage\u003e();\n\n        let (network_events_emitter, _) = broadcast::channel::\u003cNetworkEvent\u003e(100);\n\n        let network_handle = NetworkHandle {\n            peer_id: *swarm.local_peer_id(),\n            tx: send_commands,\n        };\n\n        // Read full lines from stdin\n        let round1_topic = gossipsub::IdentTopic::new(\"round1_topic\");\n        swarm\n            .behaviour_mut()\n            .gossipsub\n            .subscribe(\u0026round1_topic)\n            .map_err(|e| NodeError::Error(e.to_string()))?;\n\n        let allowed_peers: Vec\u003cPeerId\u003e = peer_data\n            .iter()\n            .map(|peer| peer.public_key.parse().unwrap())\n            .collect();\n\n        let peers_to_names: BTreeMap\u003cPeerId, String\u003e = peer_data\n            .iter()\n            .map(|peer| (peer.public_key.parse().unwrap(), peer.name.clone()))\n            .collect();\n\n        let start_dkg_topic = gossipsub::IdentTopic::new(\"start-dkg\");\n        swarm\n            .behaviour_mut()\n            .gossipsub\n            .subscribe(\u0026start_dkg_topic)\n            .map_err(|e| NodeError::Error(e.to_string()))?;\n\n        let deposit_intents_topic = gossipsub::IdentTopic::new(\"deposit-intents\");\n        swarm\n            .behaviour_mut()\n            .gossipsub\n            .subscribe(\u0026deposit_intents_topic)\n            .map_err(|e| NodeError::Error(e.to_string()))?;\n\n        Ok((\n            Self {\n                round1_topic,\n                live_peers: HashSet::new(),\n                start_dkg_topic,\n                deposit_intents_topic,\n                inner: swarm,\n                network_manager_rx: receiving_commands,\n                network_events: network_events_emitter,\n                allowed_peers,\n                peers_to_names,\n            },\n            network_handle,\n        ))\n    }\n\n    pub fn peer_name(\u0026self, peer_id: \u0026PeerId) -\u003e String {\n        self.peers_to_names\n            .get(peer_id)\n            .unwrap_or(\u0026peer_id.to_string())\n            .clone()\n    }\n\n    pub async fn start(\u0026mut self) {\n        info!(\"Starting swarm manager\");\n        loop {\n            tokio::select! {\n                send_message = self.network_manager_rx.recv() =\u003e match send_message {\n                    Some(NetworkMessage::SendBroadcast { topic, message }) =\u003e {\n                        let _ = self.inner\n                            .behaviour_mut()\n                            .gossipsub\n                            .publish(topic, message);\n                    }\n                    Some(NetworkMessage::SendPrivateMessage(peer_id, request)) =\u003e {\n                        self.inner\n                            .behaviour_mut()\n                            .request_response\n                            .send_request(\u0026peer_id, request);\n                    }\n                    Some(NetworkMessage::SendSelfRequest { request, response_channel }) =\u003e {\n                        self.network_events.send(NetworkEvent::SelfRequest { request, response_channel } ).unwrap();\n                    }\n                    _ =\u003e {\n                    }\n                },\n                event = self.inner.select_next_some() =\u003e {\n                    match event {\n                        SwarmEvent::Behaviour(MyBehaviourEvent::Mdns(mdns::Event::Discovered(list))) =\u003e {\n                            let mut peers_connected = vec![];\n                            for (peer_id, multiaddr) in list {\n                                if self.allowed_peers.contains(\u0026peer_id) {\n                                    info!(\"Discovered peer: {}\", self.peer_name(\u0026peer_id));\n                                    peers_connected.push((peer_id, multiaddr));\n                                    self.live_peers.insert(peer_id);\n                                    self.inner.behaviour_mut().gossipsub.add_explicit_peer(\u0026peer_id);\n                                }\n                            }\n                            self.network_events.send(NetworkEvent::PeersConnected(peers_connected)).unwrap();\n                        },\n                        SwarmEvent::Behaviour(MyBehaviourEvent::Mdns(mdns::Event::Expired(list))) =\u003e {\n                            for (peer_id, _multiaddr) in list.clone() {\n                                if self.allowed_peers.contains(\u0026peer_id) {\n                                    info!(\"Peer expired: {}\", self.peer_name(\u0026peer_id));\n                                    self.live_peers.retain(|p| p != \u0026peer_id);\n                                    self.inner.behaviour_mut().gossipsub.remove_explicit_peer(\u0026peer_id);\n                                }\n                            }\n                            self.network_events.send(NetworkEvent::PeersDisconnected(list)).unwrap();\n                        },\n                        SwarmEvent::Behaviour(MyBehaviourEvent::Gossipsub(gossipsub::Event::Message {\n                            message,\n                            ..\n                        })) =\u003e {\n                            self.network_events.send(NetworkEvent::GossipsubMessage(message.clone())).unwrap();\n                        },\n                        SwarmEvent::Behaviour(MyBehaviourEvent::RequestResponse(Event::Message {\n                            peer,\n                            message: Message::Request { request, .. },\n                            ..\n                        }) ) =\u003e {\n                            self.network_events.send(NetworkEvent::MessageEvent((peer, request))).unwrap();\n                        },\n                        SwarmEvent::Behaviour(MyBehaviourEvent::Gossipsub(gossipsub::Event::Subscribed { peer_id, topic })) =\u003e {\n                            self.network_events.send(NetworkEvent::Subscribed { peer_id, topic }).unwrap();\n                        },\n                        _ =\u003e {\n                            // self.network_events.send(NetworkEvent::SwarmEvent(event)).unwrap();\n                        }\n                    }\n                }\n\n            }\n        }\n    }\n}\n\npub fn build_swarm(\n    keypair: Keypair,\n    peer_data: Vec\u003cPeerData\u003e,\n) -\u003e Result\u003c(NetworkHandle, SwarmManager), NodeError\u003e {\n    let mut swarm = libp2p::SwarmBuilder::with_existing_identity(keypair)\n        .with_tokio()\n        .with_tcp(\n            tcp::Config::default(),\n            noise::Config::new,\n            yamux::Config::default,\n        )\n        .map_err(|e| NodeError::Error(format!(\"Failed to add tcp {}\", e)))?\n        .with_quic()\n        .with_behaviour(|key| {\n            // To content-address message, we can take the hash of message and use it as an ID.\n            let message_id_fn = |message: \u0026gossipsub::Message| {\n                let mut s = DefaultHasher::new();\n                message.data.hash(\u0026mut s);\n                gossipsub::MessageId::from(s.finish().to_string())\n            };\n\n            let gossipsub_config = gossipsub::ConfigBuilder::default()\n                .heartbeat_interval(Duration::from_secs(10)) // This is set to aid debugging by not cluttering the log space\n                .validation_mode(gossipsub::ValidationMode::Strict) // This sets the kind of message validation. The default is Strict (enforce message signing)\n                .message_id_fn(message_id_fn) // content-address messages. No two messages of the same content will be propagated.\n                .mesh_n_low(1) // Minimum number of peers in mesh network (default is 4)\n                .mesh_n_high(12) // Maximum number of peers in mesh network\n                .mesh_n(3) // Target number of peers in mesh network (default is 6)\n                .mesh_outbound_min(1) // Minimum outbound connections (default is 2)\n                .gossip_lazy(3) // Number of peers to gossip to (default is 6)\n                .flood_publish(true) // Always flood publish messages to all peers, regardless of mesh\n                .build()\n                .map_err(io::Error::other)?; // Temporary hack because `build` does not return a proper `std::error::Error`.\n\n            let gossipsub = gossipsub::Behaviour::new(\n                gossipsub::MessageAuthenticity::Signed(key.clone()),\n                gossipsub_config,\n            )?;\n\n            let mdns =\n                mdns::tokio::Behaviour::new(mdns::Config::default(), key.public().to_peer_id())?;\n\n            let request_response = cbor::Behaviour::new(\n                [(\n                    StreamProtocol::new(\"/direct-message/1.0.0\"),\n                    request_response::ProtocolSupport::Full,\n                )],\n                request_response::Config::default(),\n            );\n\n            Ok(MyBehaviour {\n                gossipsub,\n                mdns,\n                request_response,\n            })\n        })\n        .map_err(|e| NodeError::Error(format!(\"Failed to add behaviour {}\", e)))?\n        .with_swarm_config(|c| c.with_idle_connection_timeout(Duration::from_secs(60)))\n        .build();\n\n    swarm\n        .listen_on(\n            \"/ip4/0.0.0.0/udp/0/quic-v1\"\n                .parse()\n                .expect(\"Failed to deserialize message\"),\n        )\n        .map_err(|e| NodeError::Error(format!(\"Failed to listen on quic {}\", e)))?;\n\n    swarm\n        .listen_on(\n            \"/ip4/0.0.0.0/tcp/0\"\n                .parse()\n                .expect(\"Failed to deserialize message\"),\n        )\n        .map_err(|e| NodeError::Error(format!(\"Failed to listen on tcp {}\", e)))?;\n\n    let (swarm_manager, network) = SwarmManager::new(swarm, peer_data)\n        .map_err(|e| NodeError::Error(format!(\"Failed to create swarm manager: {}\", e)))?;\n\n    Ok((network, swarm_manager))\n}\n","traces":[{"line":129,"address":[9637136],"length":1,"stats":{"Line":0}},{"line":130,"address":[6826817],"length":1,"stats":{"Line":0}},{"line":133,"address":[9637184],"length":1,"stats":{"Line":0}},{"line":138,"address":[9637208],"length":1,"stats":{"Line":0}},{"line":139,"address":[9637269],"length":1,"stats":{"Line":0}},{"line":141,"address":[7282144,7282167],"length":1,"stats":{"Line":0}},{"line":144,"address":[8432960],"length":1,"stats":{"Line":0}},{"line":149,"address":[6827040],"length":1,"stats":{"Line":0}},{"line":150,"address":[8433052],"length":1,"stats":{"Line":0}},{"line":152,"address":[7574032,7574050],"length":1,"stats":{"Line":0}},{"line":155,"address":[6827136,6828367,6828392],"length":1,"stats":{"Line":0}},{"line":160,"address":[8433153,8434200],"length":1,"stats":{"Line":0}},{"line":161,"address":[8433385,8433677],"length":1,"stats":{"Line":0}},{"line":165,"address":[9638146],"length":1,"stats":{"Line":0}},{"line":168,"address":[10178743,10178808,10178936],"length":1,"stats":{"Line":0}},{"line":170,"address":[9638408],"length":1,"stats":{"Line":0}},{"line":172,"address":[9638469],"length":1,"stats":{"Line":0}},{"line":173,"address":[10978879,10978776,10978677,10978725],"length":1,"stats":{"Line":0}},{"line":181,"address":[6827394,6827486,6827707,6827614],"length":1,"stats":{"Line":0}},{"line":183,"address":[10178414],"length":1,"stats":{"Line":0}},{"line":185,"address":[8433593],"length":1,"stats":{"Line":0}},{"line":224,"address":[9641889,9638768,9641592],"length":1,"stats":{"Line":0}},{"line":228,"address":[9638986,9638867],"length":1,"stats":{"Line":0}},{"line":230,"address":[9639010,9639085],"length":1,"stats":{"Line":0}},{"line":233,"address":[8434713],"length":1,"stats":{"Line":0}},{"line":238,"address":[9639359],"length":1,"stats":{"Line":0}},{"line":239,"address":[8437091,8434974,8435059,8435189],"length":1,"stats":{"Line":0}},{"line":243,"address":[9639641],"length":1,"stats":{"Line":0}},{"line":245,"address":[8435236],"length":1,"stats":{"Line":0}},{"line":247,"address":[7575307,7575264],"length":1,"stats":{"Line":0}},{"line":250,"address":[9639874,9639949],"length":1,"stats":{"Line":0}},{"line":252,"address":[7575420,7575376],"length":1,"stats":{"Line":0}},{"line":255,"address":[6829694],"length":1,"stats":{"Line":0}},{"line":256,"address":[6829997,6829777,6829839,6831300],"length":1,"stats":{"Line":0}},{"line":260,"address":[10180797],"length":1,"stats":{"Line":0}},{"line":262,"address":[6830040],"length":1,"stats":{"Line":0}},{"line":263,"address":[10180911,10180976,10181134],"length":1,"stats":{"Line":0}},{"line":267,"address":[10423266,10423248],"length":1,"stats":{"Line":0}},{"line":269,"address":[6831041],"length":1,"stats":{"Line":0}},{"line":270,"address":[9641017],"length":1,"stats":{"Line":0}},{"line":271,"address":[6830345],"length":1,"stats":{"Line":0}},{"line":272,"address":[9640721],"length":1,"stats":{"Line":0}},{"line":273,"address":[8436208],"length":1,"stats":{"Line":0}},{"line":274,"address":[9640824],"length":1,"stats":{"Line":0}},{"line":275,"address":[8436272],"length":1,"stats":{"Line":0}},{"line":276,"address":[6830578],"length":1,"stats":{"Line":0}},{"line":277,"address":[6830591],"length":1,"stats":{"Line":0}},{"line":278,"address":[8436356],"length":1,"stats":{"Line":0}},{"line":279,"address":[9640972],"length":1,"stats":{"Line":0}},{"line":281,"address":[8436679],"length":1,"stats":{"Line":0}},{"line":285,"address":[9641936,9642131,9642137],"length":1,"stats":{"Line":0}},{"line":286,"address":[9642099,9641986,9642041],"length":1,"stats":{"Line":0}},{"line":288,"address":[8437378],"length":1,"stats":{"Line":0}},{"line":292,"address":[10980174,10980500,10982868,10980468,10981271,10980128],"length":1,"stats":{"Line":0}},{"line":293,"address":[10423818,10424120,10423704],"length":1,"stats":{"Line":0}},{"line":294,"address":[10983706],"length":1,"stats":{"Line":0}},{"line":295,"address":[7292306],"length":1,"stats":{"Line":0}},{"line":366,"address":[9644139,9642192,9644184],"length":1,"stats":{"Line":0}},{"line":370,"address":[9642598,9642479,9644145,9642872,9642428,9642336,9642244],"length":1,"stats":{"Line":0}},{"line":373,"address":[10182867],"length":1,"stats":{"Line":0}},{"line":377,"address":[10434214,10434192],"length":1,"stats":{"Line":0}},{"line":379,"address":[10993180,10991184,10993143],"length":1,"stats":{"Line":0}},{"line":381,"address":[7588960,7587056],"length":1,"stats":{"Line":0}},{"line":382,"address":[7588998],"length":1,"stats":{"Line":0}},{"line":383,"address":[7589013],"length":1,"stats":{"Line":0}},{"line":384,"address":[10993300],"length":1,"stats":{"Line":0}},{"line":387,"address":[7587072,7587567,7587175,7587218],"length":1,"stats":{"Line":0}},{"line":388,"address":[7587094],"length":1,"stats":{"Line":0}},{"line":389,"address":[7587210],"length":1,"stats":{"Line":0}},{"line":398,"address":[10991938,10993212,10991388,10991823],"length":1,"stats":{"Line":0}},{"line":400,"address":[10993178,10992236,10992114],"length":1,"stats":{"Line":0}},{"line":401,"address":[7295550],"length":1,"stats":{"Line":0}},{"line":402,"address":[7295609],"length":1,"stats":{"Line":0}},{"line":406,"address":[10435591,10435662],"length":1,"stats":{"Line":0}},{"line":408,"address":[10992876],"length":1,"stats":{"Line":0}},{"line":410,"address":[7296155],"length":1,"stats":{"Line":0}},{"line":411,"address":[7588450],"length":1,"stats":{"Line":0}},{"line":413,"address":[10436080],"length":1,"stats":{"Line":0}},{"line":416,"address":[7296479],"length":1,"stats":{"Line":0}},{"line":417,"address":[10436191],"length":1,"stats":{"Line":0}},{"line":418,"address":[10436217],"length":1,"stats":{"Line":0}},{"line":422,"address":[7589104,7589130],"length":1,"stats":{"Line":0}},{"line":423,"address":[7297120,7297133],"length":1,"stats":{"Line":0}},{"line":426,"address":[9644082,9643152,9643304],"length":1,"stats":{"Line":0}},{"line":428,"address":[10183600,10183528],"length":1,"stats":{"Line":0}},{"line":432,"address":[6832936],"length":1,"stats":{"Line":0}},{"line":434,"address":[9644080,9643580,9643428],"length":1,"stats":{"Line":0}},{"line":436,"address":[9643349],"length":1,"stats":{"Line":0}},{"line":440,"address":[9643548],"length":1,"stats":{"Line":0}},{"line":442,"address":[9643852,9644066,9643625],"length":1,"stats":{"Line":0}},{"line":443,"address":[8439068],"length":1,"stats":{"Line":0}},{"line":445,"address":[6833630],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":92},{"path":["/","home","vidyootsenthil","Documents","TheValut-nameTBD","crates","node","src","wallet.rs"],"content":"use bitcoin::absolute::LockTime;\nuse bitcoin::consensus::encode::serialize;\nuse bitcoin::hashes::Hash;\nuse bitcoin::transaction::{OutPoint, Version};\nuse bitcoin::witness::Witness;\nuse bitcoin::{Amount, ScriptBuf, Transaction, TxIn, TxOut, hashes::sha256};\n\nuse crate::db::Db;\nuse crate::{Network, NodeState};\n\n/// Very simple demonstration UTXO representation (key-path Taproot assumed)\n#[derive(Debug, Clone)]\npub struct Utxo {\n    pub outpoint: OutPoint,\n    pub value: Amount,\n    pub script_pubkey: ScriptBuf,\n}\n\n/// Wallet that only tracks a list of local UTXOs and is able to construct a\n/// single-input spending transaction that possibly creates a change output. No\n/// fee calculation is performed – this is purely for demonstration purposes.\n#[derive(Debug, Default)]\npub struct SimpleWallet {\n    pub utxos: Vec\u003cUtxo\u003e,\n    pub address: Option\u003cbitcoin::Address\u003e,\n}\n\nimpl SimpleWallet {\n    pub fn new(address: \u0026bitcoin::Address) -\u003e Self {\n        Self {\n            address: Some(address.clone()),\n            utxos: vec![\n                Utxo {\n                    outpoint: OutPoint {\n                        txid: bitcoin::Txid::from_slice(\u0026[0u8; 32]).expect(\"Failed to create UTXO\"),\n                        vout: 0,\n                    },\n                    value: Amount::from_sat(100_000),\n                    script_pubkey: address.script_pubkey(),\n                },\n                Utxo {\n                    outpoint: OutPoint {\n                        txid: bitcoin::Txid::from_slice(\u0026[1u8; 32]).expect(\"Failed to create UTXO\"),\n                        vout: 0,\n                    },\n                    value: Amount::from_sat(50_000),\n                    script_pubkey: address.script_pubkey(),\n                },\n                Utxo {\n                    outpoint: OutPoint {\n                        txid: bitcoin::Txid::from_slice(\u0026[2u8; 32]).expect(\"Failed to create UTXO\"),\n                        vout: 0,\n                    },\n                    value: Amount::from_sat(20_000),\n                    script_pubkey: address.script_pubkey(),\n                },\n            ],\n        }\n    }\n\n    pub fn create_spend(\n        \u0026mut self,\n        amount_sat: u64,\n        address: \u0026bitcoin::Address,\n    ) -\u003e Result\u003c(Transaction, [u8; 32]), String\u003e {\n        let pos = self\n            .utxos\n            .iter()\n            .position(|u| u.value.to_sat() \u003e= amount_sat)\n            .ok_or_else(|| {\n                \"No single UTXO large enough – coin selection not implemented\".to_string()\n            })?;\n\n        let utxo = self.utxos.remove(pos);\n        let change_sat = utxo.value.to_sat() - amount_sat;\n\n        let input = TxIn {\n            previous_output: utxo.outpoint,\n            script_sig: ScriptBuf::new(),\n            sequence: bitcoin::Sequence::ZERO,\n            witness: Witness::new(),\n        };\n\n        let recipient_output = TxOut {\n            value: Amount::from_sat(amount_sat),\n            script_pubkey: address.script_pubkey(),\n        };\n\n        let mut outputs = vec![recipient_output];\n\n        // Add change output if needed\n        if change_sat \u003e 0 {\n            outputs.push(TxOut {\n                value: Amount::from_sat(change_sat),\n                script_pubkey: ScriptBuf::new(),\n            });\n        }\n\n        let tx = Transaction {\n            version: Version::TWO,\n            lock_time: LockTime::ZERO,\n            input: vec![input],\n            output: outputs,\n        };\n\n        let sighash = sha256::Hash::hash(\u0026serialize(\u0026tx));\n        Ok((tx, sighash.to_byte_array()))\n    }\n}\n\n#[derive(Debug)]\npub struct PendingSpend {\n    pub tx: Transaction,\n}\n\nimpl\u003cN: Network, D: Db\u003e NodeState\u003cN, D\u003e {\n    pub fn get_frost_public_key(\u0026self) -\u003e Option\u003cString\u003e {\n        self.pubkey_package.as_ref().map(|p| {\n            format!(\"{:?}\", p.verifying_key())\n                .replace(\"VerifyingKey(\", \"\")\n                .replace(\")\", \"\")\n                .replace(\"\\\\\", \"\")\n                .replace(\"\\\"\", \"\")\n        })\n    }\n}\n","traces":[{"line":29,"address":[5414800,5416048,5416054],"length":1,"stats":{"Line":0}},{"line":31,"address":[6380558],"length":1,"stats":{"Line":0}},{"line":32,"address":[9632957,9633858,9633293,9634108,9633589,9632997],"length":1,"stats":{"Line":0}},{"line":61,"address":[9634144,9636366,9636460],"length":1,"stats":{"Line":0}},{"line":66,"address":[9634200,9634402],"length":1,"stats":{"Line":0}},{"line":69,"address":[12047346,12047328],"length":1,"stats":{"Line":0}},{"line":70,"address":[12047376],"length":1,"stats":{"Line":0}},{"line":71,"address":[6890476],"length":1,"stats":{"Line":0}},{"line":74,"address":[6382126],"length":1,"stats":{"Line":0}},{"line":75,"address":[6382150,6382318,6382223],"length":1,"stats":{"Line":0}},{"line":78,"address":[5416499],"length":1,"stats":{"Line":0}},{"line":79,"address":[5416553],"length":1,"stats":{"Line":0}},{"line":81,"address":[5416588],"length":1,"stats":{"Line":0}},{"line":85,"address":[6382542],"length":1,"stats":{"Line":0}},{"line":86,"address":[5416851],"length":1,"stats":{"Line":0}},{"line":89,"address":[5416933,5416991],"length":1,"stats":{"Line":0}},{"line":92,"address":[9124522],"length":1,"stats":{"Line":0}},{"line":93,"address":[9635387],"length":1,"stats":{"Line":0}},{"line":94,"address":[5417228],"length":1,"stats":{"Line":0}},{"line":95,"address":[9635375],"length":1,"stats":{"Line":0}},{"line":102,"address":[9124714,9124538],"length":1,"stats":{"Line":0}},{"line":106,"address":[9635901,9635833],"length":1,"stats":{"Line":0}},{"line":107,"address":[9125267],"length":1,"stats":{"Line":0}},{"line":117,"address":[8611552],"length":1,"stats":{"Line":1}},{"line":118,"address":[5704240],"length":1,"stats":{"Line":2}},{"line":119,"address":[],"length":0,"stats":{"Line":5}},{"line":120,"address":[],"length":0,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":0}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":123,"address":[],"length":0,"stats":{"Line":1}}],"covered":4,"coverable":30},{"path":["/","home","vidyootsenthil","Documents","TheValut-nameTBD","crates","protocol","src","block.rs"],"content":"use std::time::{SystemTime, UNIX_EPOCH};\n\nuse bincode::{Decode, Encode};\nuse serde::{Deserialize, Serialize};\nuse sha2::{Digest, Sha256};\nuse types::errors::NodeError;\n\nuse crate::transaction::Transaction;\n\npub type BlockHash = [u8; 32];\npub type StateRoot = [u8; 32];\n\n/// Block header containing all metadata\n#[derive(Debug, Clone, Encode, Decode, Serialize, Deserialize, PartialEq)]\npub struct BlockHeader {\n    /// Version of the block structure\n    pub version: u32,\n\n    /// Hash of the previous block\n    pub previous_block_hash: BlockHash,\n\n    /// Merkle root of the transactions in the block\n    pub state_root: StateRoot,\n\n    /// Unix timestamp when block was created\n    pub timestamp: u64,\n\n    /// Block height/number in the chain\n    pub height: u64,\n\n    /// Proposer of this block (for PoS/PoA)\n    pub proposer: Vec\u003cu8\u003e,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize, Encode, Decode)]\npub struct GenesisBlock {\n    pub version: u32,\n    pub timestamp: u64,\n    pub initial_state: GenesisState,\n    pub extra_data: Vec\u003cu8\u003e,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize, Encode, Decode)]\npub struct GenesisState {\n    pub validators: Vec\u003cValidatorInfo\u003e,\n    pub vault_pub_key: Vec\u003cu8\u003e,\n    pub initial_balances: Vec\u003c(String, u64)\u003e,\n    pub chain_config: ChainConfig,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize, Encode, Decode)]\npub struct ValidatorInfo {\n    pub pub_key: Vec\u003cu8\u003e,\n    pub stake: u64,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize, Encode, Decode)]\npub struct ChainConfig {\n    pub min_signers: u16,\n    pub max_signers: u16,\n    pub min_stake: u64,\n    pub block_time_seconds: u64,\n    pub max_block_size: u64,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize, Encode, Decode)]\npub struct Block {\n    pub header: BlockHeader,\n    pub body: BlockBody,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize, Encode, Decode)]\npub struct BlockBody {\n    pub transactions: Vec\u003cTransaction\u003e,\n}\n\nimpl BlockBody {\n    pub fn new(transactions: Vec\u003cTransaction\u003e) -\u003e Self {\n        Self { transactions }\n    }\n}\n\nimpl BlockHeader {\n    pub fn calculate_hash(\u0026self) -\u003e BlockHash {\n        let mut hasher = Sha256::new();\n\n        hasher.update(self.version.to_le_bytes());\n        hasher.update(self.previous_block_hash);\n        hasher.update(self.state_root);\n        hasher.update(self.timestamp.to_le_bytes());\n        hasher.update(self.height.to_le_bytes());\n        hasher.update(\u0026self.proposer);\n\n        let result = hasher.finalize();\n        let mut hash = [0u8; 32];\n        hash.copy_from_slice(\u0026result);\n        hash\n    }\n}\n\nimpl Block {\n    /// Create a new block\n    pub fn new(\n        previous_block_hash: BlockHash,\n        state_root: StateRoot,\n        height: u64,\n        transactions: Vec\u003cTransaction\u003e,\n        proposer: Vec\u003cu8\u003e,\n        timestamp: u64,\n    ) -\u003e Self {\n        let header = BlockHeader {\n            version: 1,\n            previous_block_hash,\n            state_root,\n            timestamp,\n            height,\n            proposer,\n        };\n\n        Block {\n            header,\n            body: BlockBody { transactions },\n        }\n    }\n\n    pub fn hash(\u0026self) -\u003e BlockHash {\n        self.header.calculate_hash()\n    }\n\n    pub fn serialize(\u0026self) -\u003e Result\u003cVec\u003cu8\u003e, NodeError\u003e {\n        bincode::encode_to_vec(self, bincode::config::standard())\n            .map_err(|e| NodeError::Error(format!(\"Failed to serialize block: {}\", e)))\n    }\n\n    pub fn deserialize(data: \u0026[u8]) -\u003e Result\u003cSelf, NodeError\u003e {\n        let (block, _): (Self, _) =\n            bincode::decode_from_slice(data, bincode::config::standard())\n                .map_err(|e| NodeError::Error(format!(\"Failed to deserialize block: {}\", e)))?;\n        Ok(block)\n    }\n}\n\nimpl GenesisBlock {\n    /// Create a new genesis block\n    pub fn new(\n        validators: Vec\u003cValidatorInfo\u003e,\n        chain_config: ChainConfig,\n        vault_pub_key: Vec\u003cu8\u003e,\n    ) -\u003e Self {\n        GenesisBlock {\n            version: 1,\n            timestamp: SystemTime::now()\n                .duration_since(UNIX_EPOCH)\n                .unwrap()\n                .as_secs(),\n            initial_state: GenesisState {\n                validators,\n                vault_pub_key,\n                initial_balances: vec![],\n                chain_config,\n            },\n            extra_data: b\"Genesis Block\".to_vec(),\n        }\n    }\n\n    pub fn to_block(\u0026self) -\u003e Block {\n        let mut hasher = Sha256::new();\n        hasher.update(b\"GENESIS\");\n        hasher.update(self.timestamp.to_le_bytes());\n        let state_bytes =\n            bincode::encode_to_vec(\u0026self.initial_state, bincode::config::standard()).unwrap();\n        hasher.update(\u0026state_bytes);\n        let result = hasher.finalize();\n        let mut state_root = [0u8; 32];\n        state_root.copy_from_slice(\u0026result);\n\n        Block::new(\n            [0u8; 32], // No previous block\n            state_root,\n            0,      // Height 0\n            vec![], // No transactions in genesis\n            self.initial_state\n                .validators\n                .first()\n                .map(|v| v.pub_key.clone())\n                .unwrap_or_default(),\n            self.timestamp,\n        )\n    }\n\n    /// Get hash of genesis block\n    pub fn hash(\u0026self) -\u003e BlockHash {\n        self.to_block().hash()\n    }\n}\n","traces":[{"line":78,"address":[17702944],"length":1,"stats":{"Line":0}},{"line":84,"address":[17702976],"length":1,"stats":{"Line":1}},{"line":85,"address":[17703005],"length":1,"stats":{"Line":1}},{"line":87,"address":[17317196],"length":1,"stats":{"Line":1}},{"line":88,"address":[14253341],"length":1,"stats":{"Line":1}},{"line":89,"address":[2464353],"length":1,"stats":{"Line":1}},{"line":90,"address":[17317403],"length":1,"stats":{"Line":1}},{"line":91,"address":[14253555],"length":1,"stats":{"Line":1}},{"line":92,"address":[17317547],"length":1,"stats":{"Line":1}},{"line":94,"address":[2464575],"length":1,"stats":{"Line":1}},{"line":95,"address":[14253683],"length":1,"stats":{"Line":1}},{"line":96,"address":[17317623],"length":1,"stats":{"Line":1}},{"line":97,"address":[14253766],"length":1,"stats":{"Line":1}},{"line":103,"address":[17703568],"length":1,"stats":{"Line":1}},{"line":122,"address":[17317897],"length":1,"stats":{"Line":1}},{"line":126,"address":[14254096],"length":1,"stats":{"Line":1}},{"line":127,"address":[17703857],"length":1,"stats":{"Line":1}},{"line":130,"address":[14715792],"length":1,"stats":{"Line":0}},{"line":131,"address":[17318088],"length":1,"stats":{"Line":0}},{"line":132,"address":[2626144,2626174],"length":1,"stats":{"Line":0}},{"line":135,"address":[17703968],"length":1,"stats":{"Line":0}},{"line":136,"address":[14716079,14715915],"length":1,"stats":{"Line":0}},{"line":138,"address":[17785942,17785920],"length":1,"stats":{"Line":0}},{"line":139,"address":[17704252],"length":1,"stats":{"Line":0}},{"line":145,"address":[14716925,14716192,14716869],"length":1,"stats":{"Line":2}},{"line":152,"address":[17318598,17318496],"length":1,"stats":{"Line":4}},{"line":156,"address":[14716576],"length":1,"stats":{"Line":3}},{"line":162,"address":[17704791],"length":1,"stats":{"Line":3}},{"line":166,"address":[17320107,17320101,17319232],"length":1,"stats":{"Line":3}},{"line":167,"address":[17705086],"length":1,"stats":{"Line":3}},{"line":168,"address":[14717022],"length":1,"stats":{"Line":3}},{"line":169,"address":[14717043],"length":1,"stats":{"Line":3}},{"line":170,"address":[14717117],"length":1,"stats":{"Line":3}},{"line":172,"address":[17319469],"length":1,"stats":{"Line":3}},{"line":173,"address":[17319524],"length":1,"stats":{"Line":2}},{"line":174,"address":[14255737],"length":1,"stats":{"Line":1}},{"line":175,"address":[17319676],"length":1,"stats":{"Line":2}},{"line":178,"address":[2466706],"length":1,"stats":{"Line":3}},{"line":179,"address":[14255845],"length":1,"stats":{"Line":3}},{"line":181,"address":[14255877],"length":1,"stats":{"Line":3}},{"line":182,"address":[14255981,14255901],"length":1,"stats":{"Line":6}},{"line":185,"address":[17786192,17786176],"length":1,"stats":{"Line":6}},{"line":187,"address":[17705802],"length":1,"stats":{"Line":3}},{"line":192,"address":[2467174,2467056,2467168],"length":1,"stats":{"Line":0}},{"line":193,"address":[2467090],"length":1,"stats":{"Line":0}}],"covered":35,"coverable":45},{"path":["/","home","vidyootsenthil","Documents","TheValut-nameTBD","crates","protocol","src","chain_state.rs"],"content":"use std::collections::HashMap;\n\nuse bincode::{Decode, Encode};\nuse serde::{Deserialize, Serialize};\nuse types::errors::NodeError;\n\n#[derive(Debug, Clone, Serialize, Deserialize, Encode, Decode)]\npub struct Account {\n    pub address: String,\n    pub balance: u64,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize, Encode, Decode)]\npub struct ChainState {\n    // address -\u003e account\n    accounts: HashMap\u003cString, Account\u003e,\n    block_height: u64,\n}\n\nimpl Default for ChainState {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n\n// TODO: implement periodic flushing of chain state to rocksdb\nimpl ChainState {\n    pub fn new() -\u003e Self {\n        Self {\n            accounts: HashMap::new(),\n            block_height: 0,\n        }\n    }\n\n    pub fn new_with_accounts(accounts: HashMap\u003cString, Account\u003e, block_height: u64) -\u003e Self {\n        Self {\n            accounts,\n            block_height,\n        }\n    }\n\n    pub fn get_account(\u0026self, address: \u0026str) -\u003e Option\u003c\u0026Account\u003e {\n        self.accounts.get(address)\n    }\n\n    pub fn upsert_account(\u0026mut self, address: \u0026str, account: Account) {\n        self.accounts.insert(address.to_string(), account);\n    }\n\n    pub fn get_block_height(\u0026self) -\u003e u64 {\n        self.block_height\n    }\n\n    pub fn serialize(\u0026self) -\u003e Result\u003cVec\u003cu8\u003e, NodeError\u003e {\n        bincode::encode_to_vec(self, bincode::config::standard())\n            .map_err(|e| NodeError::Error(e.to_string()))\n    }\n\n    pub fn deserialize(data: \u0026[u8]) -\u003e Result\u003cSelf, NodeError\u003e {\n        let (chain_state, _): (Self, _) =\n            bincode::decode_from_slice(data, bincode::config::standard())\n                .map_err(|e| NodeError::Error(e.to_string()))?;\n        Ok(chain_state)\n    }\n}\n","traces":[{"line":21,"address":[14265792],"length":1,"stats":{"Line":0}},{"line":22,"address":[2490040],"length":1,"stats":{"Line":0}},{"line":28,"address":[14727472],"length":1,"stats":{"Line":1}},{"line":30,"address":[14727486],"length":1,"stats":{"Line":1}},{"line":35,"address":[2490144],"length":1,"stats":{"Line":8}},{"line":42,"address":[14265968],"length":1,"stats":{"Line":2}},{"line":43,"address":[14265986],"length":1,"stats":{"Line":3}},{"line":46,"address":[14727828,14727857,14727648],"length":1,"stats":{"Line":3}},{"line":47,"address":[14266108,14266041],"length":1,"stats":{"Line":6}},{"line":50,"address":[17330144],"length":1,"stats":{"Line":0}},{"line":51,"address":[14266229],"length":1,"stats":{"Line":0}},{"line":54,"address":[2490464],"length":1,"stats":{"Line":0}},{"line":55,"address":[17330184],"length":1,"stats":{"Line":0}},{"line":56,"address":[17372576,17372594],"length":1,"stats":{"Line":0}},{"line":59,"address":[14266320],"length":1,"stats":{"Line":0}},{"line":60,"address":[14728154,14728011],"length":1,"stats":{"Line":0}},{"line":62,"address":[2490688],"length":1,"stats":{"Line":0}},{"line":63,"address":[2490800],"length":1,"stats":{"Line":0}}],"covered":7,"coverable":18},{"path":["/","home","vidyootsenthil","Documents","TheValut-nameTBD","crates","protocol","src","executor.rs"],"content":"use std::collections::HashMap;\n\nuse bitcoin::{Txid, hashes::Hash};\n\nuse types::errors::NodeError;\n\nuse crate::{\n    chain_state::{Account, ChainState},\n    oracle::Oracle,\n    transaction::{Operation, Transaction},\n};\n\npub struct TransactionExecutor\u003cO: Oracle\u003e {\n    pub oracle: O,\n    pub allowance_list: HashMap\u003cString, u64\u003e,\n    pub stack: Vec\u003cVec\u003cu8\u003e\u003e,\n    pub error: Option\u003cNodeError\u003e,\n    pub new_chain_state: ChainState,\n}\n\nimpl\u003cO: Oracle\u003e TransactionExecutor\u003cO\u003e {\n    pub fn new(oracle: O) -\u003e Self {\n        Self {\n            oracle,\n            allowance_list: HashMap::new(),\n            stack: Vec::new(),\n            error: None,\n            new_chain_state: ChainState::new(),\n        }\n    }\n\n    pub async fn execute_transaction(\n        \u0026mut self,\n        transaction: Transaction,\n        chain_state: ChainState,\n    ) -\u003e Result\u003cChainState, NodeError\u003e {\n        self.new_chain_state = chain_state.clone();\n        for operation in transaction.operations {\n            match operation {\n                Operation::OpPush { value } =\u003e {\n                    self.push_to_stack(value);\n                }\n                Operation::OpCheckOracle =\u003e {\n                    self.op_check_oracle().await?;\n                }\n                Operation::OpIncrementBalance =\u003e {\n                    self.op_increment_balance().await?;\n                }\n            }\n        }\n        Ok(self.new_chain_state.clone())\n    }\n\n    pub fn push_to_stack(\u0026mut self, value: Vec\u003cu8\u003e) {\n        self.stack.push(value);\n    }\n\n    pub fn pop_from_stack(\u0026mut self) -\u003e Option\u003cVec\u003cu8\u003e\u003e {\n        self.stack.pop()\n    }\n\n    pub fn signal_error(\u0026mut self, error: NodeError) -\u003e NodeError {\n        self.stack.push(0u64.to_be_bytes().to_vec());\n        self.error = Some(error.clone());\n        error\n    }\n\n    pub async fn op_check_oracle(\u0026mut self) -\u003e Result\u003c(), NodeError\u003e {\n        let tx_hash = self\n            .pop_from_stack()\n            .ok_or_else(|| self.signal_error(NodeError::Error(\"Missing tx hash\".to_string())))?;\n\n        let tx_hash = Txid::from_slice(\u0026tx_hash)\n            .map_err(|e| self.signal_error(NodeError::Error(e.to_string())))?;\n\n        let address = self\n            .pop_from_stack()\n            .ok_or_else(|| self.signal_error(NodeError::Error(\"Missing address\".to_string())))?;\n\n        let address = String::from_utf8(address)\n            .map_err(|e| self.signal_error(NodeError::Error(e.to_string())))?;\n\n        let amount = self\n            .pop_from_stack()\n            .ok_or_else(|| self.signal_error(NodeError::Error(\"Missing amount\".to_string())))?;\n\n        let amount = u64::from_be_bytes(\n            amount\n                .try_into()\n                .map_err(|_| self.signal_error(NodeError::Error(\"Invalid amount\".to_string())))?,\n        );\n\n        let verified = self\n            .oracle\n            .validate_transaction(\u0026address, amount, tx_hash)\n            .await\n            .map_err(|e| self.signal_error(e))?;\n\n        if verified {\n            let current_allowance = self.allowance_list.get(\u0026address).copied().unwrap_or(0);\n            self.allowance_list\n                .insert(address, current_allowance + amount);\n\n            self.push_to_stack(1u64.to_be_bytes().to_vec());\n        } else {\n            self.push_to_stack(0u64.to_be_bytes().to_vec());\n        }\n\n        Ok(())\n    }\n\n    pub async fn op_increment_balance(\u0026mut self) -\u003e Result\u003c(), NodeError\u003e {\n        let address = self\n            .pop_from_stack()\n            .ok_or_else(|| self.signal_error(NodeError::Error(\"Missing address\".to_string())))?;\n\n        let amount = self\n            .pop_from_stack()\n            .ok_or_else(|| self.signal_error(NodeError::Error(\"Missing amount\".to_string())))?;\n\n        let address = String::from_utf8(address)\n            .map_err(|e| self.signal_error(NodeError::Error(e.to_string())))?;\n\n        let amount = u64::from_be_bytes(\n            amount\n                .try_into()\n                .map_err(|_| self.signal_error(NodeError::Error(\"Invalid amount\".to_string())))?,\n        );\n\n        let allowed = {\n            let allowance = self.allowance_list.get(\u0026address).copied().unwrap_or(0);\n            allowance \u003e= amount\n        };\n\n        if !allowed {\n            return Err(self.signal_error(NodeError::Error(\"Insufficient allowance\".to_string())));\n        }\n\n        // Deduct from allowance\n        let current_allowance = self.allowance_list.get(\u0026address).copied().unwrap_or(0);\n        self.allowance_list\n            .insert(address.clone(), current_allowance - amount);\n\n        let mut account = self\n            .new_chain_state\n            .get_account(\u0026address)\n            .cloned()\n            .unwrap_or(Account {\n                address: address.clone(),\n                balance: 0,\n            });\n\n        account.balance += amount;\n\n        self.new_chain_state.upsert_account(\u0026address, account);\n\n        // Push success to stack\n        self.push_to_stack(1u64.to_be_bytes().to_vec());\n\n        Ok(())\n    }\n}\n","traces":[{"line":22,"address":[],"length":0,"stats":{"Line":2}},{"line":25,"address":[6271631],"length":1,"stats":{"Line":6}},{"line":26,"address":[],"length":0,"stats":{"Line":1}},{"line":28,"address":[],"length":0,"stats":{"Line":5}},{"line":32,"address":[6265616],"length":1,"stats":{"Line":2}},{"line":37,"address":[6266098,6266071,6265941],"length":1,"stats":{"Line":10}},{"line":38,"address":[],"length":0,"stats":{"Line":15}},{"line":39,"address":[],"length":0,"stats":{"Line":3}},{"line":40,"address":[],"length":0,"stats":{"Line":6}},{"line":41,"address":[],"length":0,"stats":{"Line":8}},{"line":43,"address":[],"length":0,"stats":{"Line":3}},{"line":44,"address":[],"length":0,"stats":{"Line":10}},{"line":46,"address":[],"length":0,"stats":{"Line":3}},{"line":47,"address":[],"length":0,"stats":{"Line":4}},{"line":51,"address":[],"length":0,"stats":{"Line":2}},{"line":54,"address":[6260944],"length":1,"stats":{"Line":6}},{"line":55,"address":[],"length":0,"stats":{"Line":2}},{"line":58,"address":[],"length":0,"stats":{"Line":3}},{"line":59,"address":[6260993],"length":1,"stats":{"Line":5}},{"line":62,"address":[6260924,6260560],"length":1,"stats":{"Line":1}},{"line":63,"address":[],"length":0,"stats":{"Line":2}},{"line":64,"address":[],"length":0,"stats":{"Line":1}},{"line":65,"address":[],"length":0,"stats":{"Line":3}},{"line":68,"address":[],"length":0,"stats":{"Line":9}},{"line":69,"address":[],"length":0,"stats":{"Line":8}},{"line":71,"address":[],"length":0,"stats":{"Line":2}},{"line":73,"address":[],"length":0,"stats":{"Line":12}},{"line":74,"address":[6261653,6261731,6265200,6265229],"length":1,"stats":{"Line":4}},{"line":76,"address":[],"length":0,"stats":{"Line":8}},{"line":78,"address":[],"length":0,"stats":{"Line":4}},{"line":80,"address":[],"length":0,"stats":{"Line":8}},{"line":81,"address":[],"length":0,"stats":{"Line":4}},{"line":83,"address":[],"length":0,"stats":{"Line":8}},{"line":85,"address":[],"length":0,"stats":{"Line":4}},{"line":88,"address":[],"length":0,"stats":{"Line":8}},{"line":89,"address":[],"length":0,"stats":{"Line":0}},{"line":90,"address":[6264936,6262976,6264912,6262881],"length":1,"stats":{"Line":4}},{"line":93,"address":[],"length":0,"stats":{"Line":20}},{"line":94,"address":[],"length":0,"stats":{"Line":0}},{"line":95,"address":[],"length":0,"stats":{"Line":4}},{"line":96,"address":[],"length":0,"stats":{"Line":9}},{"line":97,"address":[],"length":0,"stats":{"Line":7}},{"line":99,"address":[],"length":0,"stats":{"Line":3}},{"line":100,"address":[6264164,6263988],"length":1,"stats":{"Line":4}},{"line":101,"address":[6264224,6264341],"length":1,"stats":{"Line":3}},{"line":102,"address":[],"length":0,"stats":{"Line":5}},{"line":104,"address":[],"length":0,"stats":{"Line":2}},{"line":106,"address":[],"length":0,"stats":{"Line":2}},{"line":109,"address":[],"length":0,"stats":{"Line":2}},{"line":112,"address":[],"length":0,"stats":{"Line":4}},{"line":113,"address":[6268125,6268233,6268313,6270978],"length":1,"stats":{"Line":2}},{"line":115,"address":[6268281,6271472,6271491],"length":1,"stats":{"Line":0}},{"line":117,"address":[6268598,6270922,6268518,6268438],"length":1,"stats":{"Line":2}},{"line":119,"address":[6268566,6271184,6271203],"length":1,"stats":{"Line":0}},{"line":121,"address":[],"length":0,"stats":{"Line":2}},{"line":122,"address":[],"length":0,"stats":{"Line":0}},{"line":125,"address":[6269246,6269147,6269016,6270842],"length":1,"stats":{"Line":2}},{"line":126,"address":[],"length":0,"stats":{"Line":0}},{"line":127,"address":[6271296,6269214,6271320],"length":1,"stats":{"Line":0}},{"line":130,"address":[],"length":0,"stats":{"Line":0}},{"line":131,"address":[],"length":0,"stats":{"Line":1}},{"line":132,"address":[6269499],"length":1,"stats":{"Line":1}},{"line":135,"address":[],"length":0,"stats":{"Line":1}},{"line":136,"address":[6269595,6269521],"length":1,"stats":{"Line":2}},{"line":140,"address":[],"length":0,"stats":{"Line":5}},{"line":141,"address":[],"length":0,"stats":{"Line":5}},{"line":142,"address":[],"length":0,"stats":{"Line":6}},{"line":144,"address":[],"length":0,"stats":{"Line":6}},{"line":145,"address":[],"length":0,"stats":{"Line":0}},{"line":146,"address":[],"length":0,"stats":{"Line":2}},{"line":148,"address":[],"length":0,"stats":{"Line":2}},{"line":149,"address":[],"length":0,"stats":{"Line":3}},{"line":150,"address":[],"length":0,"stats":{"Line":0}},{"line":153,"address":[],"length":0,"stats":{"Line":1}},{"line":155,"address":[],"length":0,"stats":{"Line":3}},{"line":158,"address":[],"length":0,"stats":{"Line":3}},{"line":160,"address":[],"length":0,"stats":{"Line":3}}],"covered":67,"coverable":77},{"path":["/","home","vidyootsenthil","Documents","TheValut-nameTBD","crates","protocol","src","lib.rs"],"content":"pub mod block;\npub mod chain_state;\npub mod executor;\npub mod oracle;\npub mod proposal;\npub mod transaction;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","vidyootsenthil","Documents","TheValut-nameTBD","crates","protocol","src","oracle.rs"],"content":"use bitcoin::Txid;\nuse esplora_client::{AsyncClient, Builder};\nuse types::errors::NodeError;\n\n#[async_trait::async_trait]\npub trait Oracle {\n    async fn validate_transaction(\n        \u0026self,\n        address: \u0026str,\n        amount: u64,\n        tx_hash: Txid,\n    ) -\u003e Result\u003cbool, NodeError\u003e;\n}\n\npub struct BitcoinOracle {\n    pub esplora_client: AsyncClient,\n}\n\nimpl Default for BitcoinOracle {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n\nimpl BitcoinOracle {\n    pub fn new() -\u003e Self {\n        const BLOCKSTREAM_API_URL: \u0026str = \"https://blockstream.info/api\";\n        let builder = Builder::new(BLOCKSTREAM_API_URL);\n        let async_client = builder.build_async().unwrap();\n\n        Self {\n            esplora_client: async_client,\n        }\n    }\n}\n\n#[async_trait::async_trait]\nimpl Oracle for BitcoinOracle {\n    async fn validate_transaction(\n        \u0026self,\n        _address: \u0026str,\n        amount: u64,\n        tx_hash: Txid,\n    ) -\u003e Result\u003cbool, NodeError\u003e {\n        let tx = self\n            .esplora_client\n            .get_tx_info(\u0026tx_hash)\n            .await\n            .map_err(|e| NodeError::Error(e.to_string()))?;\n\n        let tx = tx.ok_or(NodeError::Error(\"Transaction not found\".to_string()))?;\n\n        if !tx.status.confirmed {\n            return Err(NodeError::Error(\"Transaction not confirmed\".to_string()));\n        }\n\n        let mut total_output = 0;\n        for output in tx.vout {\n            total_output += output.value;\n        }\n\n        if total_output != amount {\n            return Err(NodeError::Error(\n                \"Transaction output value mismatch\".to_string(),\n            ));\n        }\n\n        Ok(true)\n    }\n}\n","traces":[{"line":20,"address":[2619616],"length":1,"stats":{"Line":0}},{"line":21,"address":[2619624],"length":1,"stats":{"Line":0}},{"line":26,"address":[2619648],"length":1,"stats":{"Line":0}},{"line":28,"address":[2619665],"length":1,"stats":{"Line":0}},{"line":29,"address":[2619688],"length":1,"stats":{"Line":0}},{"line":45,"address":[2488139,2487863,2488105,2487798,2489898,2488229],"length":1,"stats":{"Line":0}},{"line":47,"address":[14476921],"length":1,"stats":{"Line":0}},{"line":48,"address":[17624119],"length":1,"stats":{"Line":0}},{"line":49,"address":[17543024,17541289,17543042],"length":1,"stats":{"Line":0}},{"line":51,"address":[2488417,2489826,2488360,2489844,2488609],"length":1,"stats":{"Line":0}},{"line":53,"address":[14477950],"length":1,"stats":{"Line":0}},{"line":54,"address":[17541880,17542037],"length":1,"stats":{"Line":0}},{"line":57,"address":[14939639],"length":1,"stats":{"Line":0}},{"line":58,"address":[2489170,2488815,2489043],"length":1,"stats":{"Line":0}},{"line":59,"address":[17853671,17854130,17854100],"length":1,"stats":{"Line":0}},{"line":62,"address":[17542444],"length":1,"stats":{"Line":0}},{"line":63,"address":[17853888],"length":1,"stats":{"Line":0}},{"line":64,"address":[2489384],"length":1,"stats":{"Line":0}},{"line":68,"address":[2489339],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":19},{"path":["/","home","vidyootsenthil","Documents","TheValut-nameTBD","crates","protocol","src","proposal.rs"],"content":"use types::errors::NodeError;\n\nuse crate::{block::BlockBody, transaction::Transaction};\n\npub struct ProposedBlock {\n    block_body: BlockBody,\n}\n\nimpl Default for ProposedBlock {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n\nimpl ProposedBlock {\n    pub fn new() -\u003e Self {\n        Self {\n            block_body: BlockBody::new(vec![]),\n        }\n    }\n\n    pub fn add_transaction(\u0026mut self, transaction: Transaction) -\u003e Result\u003c(), NodeError\u003e {\n        self.block_body.transactions.push(transaction);\n        Ok(())\n    }\n}\n","traces":[{"line":10,"address":[2603200],"length":1,"stats":{"Line":0}},{"line":11,"address":[2603208],"length":1,"stats":{"Line":0}},{"line":16,"address":[2603232],"length":1,"stats":{"Line":0}},{"line":18,"address":[2603246],"length":1,"stats":{"Line":0}},{"line":22,"address":[2603312],"length":1,"stats":{"Line":0}},{"line":23,"address":[2603355],"length":1,"stats":{"Line":0}},{"line":24,"address":[2603377],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":7},{"path":["/","home","vidyootsenthil","Documents","TheValut-nameTBD","crates","protocol","src","transaction.rs"],"content":"use bincode::{Decode, Encode};\nuse serde::{Deserialize, Serialize};\nuse sha2::{Digest, Sha256};\n\npub type TransactionId = [u8; 32];\n\n#[derive(Debug, Clone, Serialize, Deserialize, Encode, Decode, PartialEq)]\npub struct Transaction {\n    pub version: u32,\n    pub timestamp: u64,\n    pub r#type: TransactionType,\n    pub operations: Vec\u003cOperation\u003e,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize, Encode, Decode, PartialEq)]\npub enum TransactionType {\n    Deposit,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize, Encode, Decode, PartialEq)]\npub enum Operation {\n    /// Push a value to the stack in bytes\n    /// Data types:\n    ///    - Numbers: u64\n    ///    - Strings: utf-8 encoded string\n    ///    - Booleans: u8 (0 or 1)\n    ///    - Tx Hash: [u8; 32]\n    OpPush { value: Vec\u003cu8\u003e },\n    /// Check if the transaction is on the Bitcoin network. Modifies allowance list to allow the address to spend the amount.\n    /// Pops from the stack:\n    ///   - 0: The tx hash\n    ///   - 1: The address\n    ///   - 2: The amount\n    ///\n    /// Pushes to the stack:\n    ///   - 0: The result (0 or 1)\n    OpCheckOracle,\n    /// Increment the balance of the address on the stack. Checks the allowance list to see if the address is allowed to spend the amount.\n    /// Pops from the stack:\n    ///   - 0: The address\n    ///   - 1: The amount\n    ///\n    /// Pushes to the stack:\n    ///   - 0: The result (0 or 1)\n    OpIncrementBalance,\n}\n\nimpl Transaction {\n    pub fn new(r#type: TransactionType, operations: Vec\u003cOperation\u003e) -\u003e Self {\n        Transaction {\n            version: 1,\n            timestamp: std::time::SystemTime::now()\n                .duration_since(std::time::UNIX_EPOCH)\n                .unwrap()\n                .as_secs(),\n            r#type,\n            operations,\n        }\n    }\n\n    pub fn id(\u0026self) -\u003e TransactionId {\n        let mut hasher = Sha256::new();\n        hasher.update(self.version.to_le_bytes());\n        hasher.update(self.timestamp.to_le_bytes());\n\n        for op in \u0026self.operations {\n            let op_bytes = bincode::encode_to_vec(op, bincode::config::standard()).unwrap();\n            hasher.update(\u0026op_bytes);\n        }\n\n        let result = hasher.finalize();\n        let mut id = [0u8; 32];\n        id.copy_from_slice(\u0026result);\n        id\n    }\n}\n","traces":[{"line":49,"address":[17797280,17797574],"length":1,"stats":{"Line":6}},{"line":52,"address":[17797372,17797302],"length":1,"stats":{"Line":9}},{"line":61,"address":[17798218,17798224,17797600],"length":1,"stats":{"Line":0}},{"line":62,"address":[14967262],"length":1,"stats":{"Line":0}},{"line":63,"address":[2614141],"length":1,"stats":{"Line":0}},{"line":64,"address":[17797712],"length":1,"stats":{"Line":0}},{"line":66,"address":[14505791,14505769],"length":1,"stats":{"Line":0}},{"line":67,"address":[17797881],"length":1,"stats":{"Line":0}},{"line":68,"address":[14505940],"length":1,"stats":{"Line":0}},{"line":71,"address":[17569879],"length":1,"stats":{"Line":0}},{"line":72,"address":[17798020],"length":1,"stats":{"Line":0}},{"line":73,"address":[2614518],"length":1,"stats":{"Line":0}},{"line":74,"address":[2614580],"length":1,"stats":{"Line":0}}],"covered":2,"coverable":13},{"path":["/","home","vidyootsenthil","Documents","TheValut-nameTBD","crates","types","src","errors.rs"],"content":"use std::error::Error;\n\nuse derive_more::Display;\n\n#[derive(Debug, Display, Clone)]\npub enum NodeError {\n    Error(String),\n}\n\n#[derive(Debug)]\npub enum NetworkError {\n    SendError(String),\n    RecvError,\n}\n\nimpl From\u003crocksdb::Error\u003e for NodeError {\n    fn from(e: rocksdb::Error) -\u003e Self {\n        NodeError::Error(e.to_string())\n    }\n}\n\nimpl Error for NodeError {}\n","traces":[{"line":17,"address":[624896,625011],"length":1,"stats":{"Line":0}},{"line":18,"address":[624969,624920],"length":1,"stats":{"Line":0}}],"covered":0,"coverable":2},{"path":["/","home","vidyootsenthil","Documents","TheValut-nameTBD","crates","types","src","lib.rs"],"content":"pub mod errors;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","vidyootsenthil","Documents","TheValut-nameTBD","tests","src","config.rs"],"content":"#[cfg(test)]\nmod config_test {\n    use node::NodeConfig;\n\n    #[test]\n    fn test_config_deserialization() {\n        let json_str = r#\"{\n            \"allowed_peers\": [\n                {\n                    \"public_key\": \"12D3KooWRdtE2nFybk8eMyp3D9B4NvunUYqpN6JDvBcVPTcrDsbF\",\n                    \"name\": \"node-four\"\n                }\n            ],\n            \"key_data\": {\n                \"public_key_b58\": \"12D3KooWQDHzW448RmDoUz1KbMfuD4XqeojRJDsxqUZSEYo7FSUz\",\n                \"encrypted_private_key_b64\": \"EnCF8bEe3tVyMV0EUIK29bOMNjH7gT7mx4ATyBr4WSdphw5ETfm1YdQHDAg+CzBBjt7K2FSbwv8Qkj1y3N4jTU/FkGHggfkwDDl5XkDc5rXi2BW/\",\n                \"encryption_params\": {\n                    \"kdf\": \"argon2id\",\n                    \"salt_b64\": \"TnErEFlx9F1BeU8mJcFzKQ\",\n                    \"iv_b64\": \"hybTge0qoPaxNUhP\"\n                }\n            }\n        }\"#;\n\n        let config: NodeConfig = serde_json::from_str(json_str).expect(\"Failed to deserialize\");\n        assert_eq!(config.allowed_peers.len(), 1);\n        assert_eq!(\n            config.key_data.public_key_b58,\n            \"12D3KooWQDHzW448RmDoUz1KbMfuD4XqeojRJDsxqUZSEYo7FSUz\"\n        );\n        assert!(config.dkg_keys.is_none());\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","vidyootsenthil","Documents","TheValut-nameTBD","tests","src","deposit","mod.rs"],"content":"#[cfg(test)]\nmod deposit_tests {\n    use std::str::FromStr;\n\n    use crate::mocks::network::MockNodeCluster;\n    use bitcoin::Address;\n    use node::{\n        db::Db,\n        grpc::{\n            grpc_handler::node_proto::{CreateDepositIntentRequest, CreateDepositIntentResponse},\n            grpc_operator,\n        },\n    };\n    use tokio::sync::mpsc::unbounded_channel;\n\n    #[tokio::test]\n    async fn deposit_intent_creates_valid_address_and_persists_on_node() {\n        let mut cluster = MockNodeCluster::new_with_keys(2, 2, 2).await;\n        cluster.setup().await;\n\n        let node_peer = *cluster.nodes.keys().next().unwrap();\n        let amount_sat = 50_000;\n        let (tx, mut rx) = unbounded_channel::\u003cCreateDepositIntentResponse\u003e();\n        let network = cluster.networks.get(\u0026node_peer).unwrap().clone();\n\n        tokio::spawn(async move {\n            let response = grpc_operator::create_deposit_intent(\n                \u0026network,\n                CreateDepositIntentRequest {\n                    amount_satoshis: amount_sat,\n                },\n            )\n            .await\n            .expect(\"Failed to create deposit intent\");\n            tx.send(response).unwrap();\n        });\n\n        cluster.run_n_iterations(10).await;\n\n        let response = rx.recv().await.unwrap();\n        let node = cluster.nodes.get(\u0026node_peer).unwrap();\n        let db = \u0026node.db;\n\n        // retrieve the first deposit intent stored\n        let intent_opt = db\n            .get_deposit_intent(\u0026response.deposit_tracking_id)\n            .unwrap();\n\n        assert!(intent_opt.is_some(), \"deposit intent not stored\");\n        let intent = intent_opt.unwrap();\n\n        // parse address and validate\n        let addr = Address::from_str(\u0026intent.deposit_address).unwrap();\n        assert!(addr.is_valid_for_network(bitcoin::Network::Signet));\n    }\n\n    #[tokio::test]\n    async fn deposit_intent_creates_valid_address_and_persists_on_node_and_is_broadcasted() {\n        let mut cluster = MockNodeCluster::new_with_keys(2, 2, 2).await;\n        cluster.setup().await;\n\n        let node_peer = *cluster.nodes.keys().next().unwrap();\n        let amount_sat = 50_000;\n        let network = cluster.networks.get(\u0026node_peer).unwrap().clone();\n        let (tx, mut rx) = unbounded_channel::\u003cCreateDepositIntentResponse\u003e();\n\n        tokio::spawn(async move {\n            let response = grpc_operator::create_deposit_intent(\n                \u0026network,\n                CreateDepositIntentRequest {\n                    amount_satoshis: amount_sat,\n                },\n            )\n            .await\n            .expect(\"Failed to create deposit intent\");\n            tx.send(response).unwrap();\n        });\n\n        cluster.run_n_iterations(10).await;\n\n        let response = rx.recv().await.unwrap();\n\n        for (_, node) in cluster.nodes.iter() {\n            let intent_opt = node\n                .db\n                .get_deposit_intent(\u0026response.deposit_tracking_id)\n                .unwrap();\n            assert!(intent_opt.is_some(), \"deposit intent not stored\");\n            let intent = intent_opt.unwrap();\n            assert_eq!(intent.deposit_address, response.deposit_address);\n        }\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","vidyootsenthil","Documents","TheValut-nameTBD","tests","src","dkg","mod.rs"],"content":"#[cfg(test)]\nmod dkg_test {\n    use crate::mocks::network::MockNodeCluster;\n    use bincode;\n    use env_logger;\n    use log::info;\n    use node::db::Db;\n    use node::swarm_manager::DirectMessage;\n    use node::swarm_manager::NetworkEvent;\n    use protocol::block::{ChainConfig, ValidatorInfo};\n    use sha2::{Digest, Sha256};\n\n    fn setup() {\n        let _ = env_logger::builder().is_test(true).try_init();\n    }\n\n    #[tokio::test]\n    async fn peers_send_start_dkg_at_startup() {\n        setup();\n        let mut cluster = MockNodeCluster::new(2, 2, 2).await;\n        cluster.setup().await;\n        info!(\"Ran setup\");\n\n        cluster.run_n_iterations(1).await;\n        info!(\"Ran 1 iterations\");\n\n        for (_, node) in cluster.nodes.iter() {\n            assert_eq!(node.peers.len(), 1);\n        }\n\n        for (peer, sender) in cluster.senders.iter() {\n            info!(\n                \"Peer {} has {} pending events\",\n                peer,\n                sender.pending_events.len()\n            );\n        }\n\n        cluster.tear_down().await;\n        info!(\"Ran teardown\");\n    }\n\n    #[tokio::test]\n    async fn test_dkg_round1_broadcasts() {\n        setup();\n        let mut cluster = MockNodeCluster::new(3, 2, 3).await;\n\n        cluster.setup().await;\n        info!(\"Started DKG Round1 test with {} nodes\", cluster.nodes.len());\n\n        // Run exactly one iteration to trigger DKG start and round1\n        cluster.run_n_iterations(1).await;\n\n        // Count the different types of messages that were generated\n        let mut start_dkg_broadcasts = 0;\n        let mut round1_broadcasts = 0;\n        let mut other_messages = 0;\n\n        // Check all pending events across all networks\n        for (from_peer, sender) in cluster.senders.iter() {\n            let pending_events = \u0026sender.pending_events;\n            info!(\n                \"Peer {} has {} pending events\",\n                from_peer,\n                pending_events.len()\n            );\n\n            for event in pending_events.iter() {\n                match \u0026event {\n                    NetworkEvent::GossipsubMessage(msg) =\u003e {\n                        let topic_str = format!(\"{:?}\", msg.topic);\n                        let data_str = String::from_utf8_lossy(\u0026msg.data);\n\n                        if topic_str.contains(\"start-dkg\") {\n                            start_dkg_broadcasts += 1;\n                        } else if data_str.contains(\"Round1\") || topic_str.contains(\"round1\") {\n                            round1_broadcasts += 1;\n                        } else {\n                            other_messages += 1;\n                        }\n                    }\n                    _ =\u003e {\n                        other_messages += 1;\n                        info!(\"  Other event from {}: {:?}\", from_peer, event);\n                    }\n                }\n            }\n        }\n\n        info!(\"Message count summary:\");\n        info!(\"  Start-DKG broadcasts: {}\", start_dkg_broadcasts);\n        info!(\"  Round1 broadcasts: {}\", round1_broadcasts);\n        info!(\"  Other messages: {}\", other_messages);\n\n        // Verify each peer sent a start-dkg broadcast\n        assert!(\n            start_dkg_broadcasts \u003e= cluster.nodes.len(),\n            \"Expected at least {} start-dkg broadcasts, got {}\",\n            cluster.nodes.len(),\n            start_dkg_broadcasts\n        );\n\n        // After DKG starts, we expect round1 broadcasts from each peer\n        // Note: This might happen in the same iteration or the next one\n        info!(\"✅ DKG Round1 broadcast verification completed\");\n        cluster.tear_down().await;\n    }\n\n    #[tokio::test]\n    async fn test_dkg_round2_private_requests() {\n        setup();\n        let mut cluster = MockNodeCluster::new(3, 2, 3).await;\n\n        cluster.setup().await;\n        info!(\"Started DKG Round2 test with {} nodes\", cluster.nodes.len());\n\n        // Run several iterations to allow round1 to complete\n        let mut round1_complete = false;\n        let mut round2_private_requests = 0;\n\n        for iteration in 1..=10 {\n            info!(\"--- Iteration {} ---\", iteration);\n            cluster.run_n_iterations(1).await;\n\n            // Check for round2 private messages in the pending events\n            let mut current_round2_requests = 0;\n\n            for (_, sender) in cluster.senders.iter() {\n                let pending_events = \u0026sender.pending_events;\n                info!(\"  {} pending events\", pending_events.len());\n                for event in pending_events.iter() {\n                    match \u0026event {\n                        NetworkEvent::GossipsubMessage(msg) =\u003e {\n                            let data_str = String::from_utf8_lossy(\u0026msg.data);\n                            // This is a broadcast\n                            if data_str.contains(\"Round1\") {\n                                info!(\"  Still processing Round1 broadcasts\");\n                            }\n                        }\n                        NetworkEvent::MessageEvent((_, direct_message)) =\u003e {\n                            info!(\"  Found MessageEvent\");\n                            if let DirectMessage::Round2Package(_) = direct_message {\n                                info!(\"  Found Round2 private request\");\n                                current_round2_requests += 1;\n                            }\n                        }\n                        _ =\u003e {\n                            info!(\"  Other event: {:?}\", event);\n                        }\n                    }\n                }\n            }\n\n            if current_round2_requests \u003e 0 {\n                round2_private_requests += current_round2_requests;\n                round1_complete = true;\n                info!(\n                    \"  Found {} Round2 private requests in iteration {}\",\n                    current_round2_requests, iteration\n                );\n            }\n\n            // If we've seen round2 requests, we can verify our expectations\n            if round1_complete \u0026\u0026 round2_private_requests \u003e 0 {\n                break;\n            }\n        }\n\n        info!(\"Round2 private request summary:\");\n        info!(\"  Round1 complete: {}\", round1_complete);\n        info!(\"  Round2 private requests: {}\", round2_private_requests);\n\n        // Verify that round2 private requests were sent after round1\n        assert!(\n            round1_complete,\n            \"Round1 should complete and trigger Round2 private requests\"\n        );\n\n        assert!(\n            round2_private_requests \u003e 0,\n            \"Expected Round2 private requests after Round1 completion, got {}\",\n            round2_private_requests\n        );\n\n        info!(\"✅ DKG Round2 private request verification completed\");\n        cluster.tear_down().await;\n    }\n\n    #[tokio::test]\n    async fn test_dkg_completion() {\n        setup();\n        let mut cluster = MockNodeCluster::new(3, 2, 3).await;\n        cluster.setup().await;\n        info!(\"Started DKG test with {} nodes\", cluster.nodes.len());\n\n        // Keep running iterations until no events are left\n        let mut iteration_count = 0;\n        let max_iterations = 100; // Safety limit to prevent infinite loops\n\n        loop {\n            iteration_count += 1;\n\n            if iteration_count \u003e max_iterations {\n                panic!(\"DKG test exceeded maximum iterations ({})\", max_iterations);\n            }\n\n            // Run one iteration\n            cluster.run_n_iterations(1).await;\n\n            // Check if there are any pending events across all senders\n            let mut total_pending_events = 0;\n            for (_, sender) in cluster.senders.iter() {\n                total_pending_events += sender.pending_events.len();\n            }\n\n            // Also check network pending events\n            for (_, network) in cluster.networks.iter() {\n                let pending_events = network.pending_events.lock().unwrap();\n                total_pending_events += pending_events.len();\n            }\n\n            info!(\n                \"Iteration {}: {} total pending events\",\n                iteration_count, total_pending_events\n            );\n\n            if total_pending_events == 0 {\n                info!(\n                    \"No more pending events after {} iterations\",\n                    iteration_count\n                );\n                break;\n            }\n        }\n\n        // Verify that each node has DKG public and private key pairs\n        for (peer_id, node) in cluster.nodes.iter() {\n            assert!(\n                node.pubkey_package.is_some(),\n                \"Node {} should have a public key package after DKG completion\",\n                peer_id\n            );\n            assert!(\n                node.private_key_package.is_some(),\n                \"Node {} should have a private key package after DKG completion\",\n                peer_id\n            );\n            info!(\"✅ Node {} has both DKG public and private keys\", peer_id);\n        }\n\n        info!(\n            \"🎉 DKG completed successfully on all {} nodes!\",\n            cluster.nodes.len()\n        );\n        cluster.tear_down().await;\n    }\n\n    #[tokio::test]\n    async fn test_dkg_completes_within_5_iterations() {\n        setup();\n        let mut cluster = MockNodeCluster::new(3, 2, 3).await;\n        cluster.setup().await;\n        info!(\n            \"Started DKG completion test (within 5 iterations) with {} nodes\",\n            cluster.nodes.len()\n        );\n\n        let max_iterations = 5;\n        cluster.run_n_iterations(max_iterations).await;\n        info!(\"Ran {} iterations\", max_iterations);\n\n        for (peer_id, node) in cluster.nodes.iter() {\n            assert!(\n                node.pubkey_package.is_some(),\n                \"Node {} should have a public key package after {} iterations\",\n                peer_id,\n                max_iterations\n            );\n            assert!(\n                node.private_key_package.is_some(),\n                \"Node {} should have a private key package after {} iterations\",\n                peer_id,\n                max_iterations\n            );\n        }\n\n        info!(\n            \"🎉 DKG completed successfully on all {} nodes within {} iterations\",\n            cluster.nodes.len(),\n            max_iterations\n        );\n        cluster.tear_down().await;\n    }\n\n    #[tokio::test]\n    #[ignore] // ignoring because it takes a long time to run\n    async fn test_dkg_completion_256_nodes() {\n        setup();\n        let start_time = std::time::Instant::now();\n        let mut cluster = MockNodeCluster::new(256, 171, 256).await;\n        cluster.setup().await;\n        info!(\"Started DKG test with {} nodes\", cluster.nodes.len());\n\n        // Keep running iterations until no events are left\n        let mut iteration_count = 0;\n        let max_iterations = 200; // Safety limit to prevent infinite loops\n\n        loop {\n            iteration_count += 1;\n\n            if iteration_count \u003e max_iterations {\n                panic!(\"DKG test exceeded maximum iterations ({})\", max_iterations);\n            }\n\n            // Run one iteration\n            cluster.run_n_iterations(1).await;\n\n            // Check if there are any pending events across all senders\n            let mut total_pending_events = 0;\n            for (_, sender) in cluster.senders.iter() {\n                total_pending_events += sender.pending_events.len();\n            }\n\n            // Also check network pending events\n            for (_, network) in cluster.networks.iter() {\n                let pending_events = network.pending_events.lock().unwrap();\n                total_pending_events += pending_events.len();\n            }\n\n            info!(\n                \"Iteration {}: {} total pending events\",\n                iteration_count, total_pending_events\n            );\n\n            if total_pending_events == 0 {\n                info!(\n                    \"No more pending events after {} iterations\",\n                    iteration_count\n                );\n                break;\n            }\n        }\n\n        // Verify that each node has DKG public and private key pairs\n        for (peer_id, node) in cluster.nodes.iter() {\n            assert!(\n                node.pubkey_package.is_some(),\n                \"Node {} should have a public key package after DKG completion\",\n                peer_id\n            );\n            assert!(\n                node.private_key_package.is_some(),\n                \"Node {} should have a private key package after DKG completion\",\n                peer_id\n            );\n            info!(\"✅ Node {} has both DKG public and private keys\", peer_id);\n        }\n\n        let duration = start_time.elapsed();\n        info!(\"DKG completion for 256 nodes took: {:?}\", duration);\n\n        assert!(\n            duration \u003c std::time::Duration::from_secs(300),\n            \"DKG for 256 nodes took too long: {:?}\",\n            duration\n        );\n\n        info!(\n            \"🎉 DKG completed successfully on all {} nodes!\",\n            cluster.nodes.len()\n        );\n        cluster.tear_down().await;\n    }\n\n    #[tokio::test]\n    async fn test_genesis_block_contains_dkg_metadata() {\n        setup();\n        let mut cluster = MockNodeCluster::new(3, 2, 3).await;\n        cluster.setup().await;\n        info!(\n            \"Started genesis block DKG metadata test with {} nodes\",\n            cluster.nodes.len()\n        );\n\n        cluster.run_n_iterations(10).await;\n\n        for (peer_id, node) in cluster.nodes.iter() {\n            let genesis_block_from_db = node.db.get_block_by_height(0).unwrap().unwrap();\n\n            let dkg_pub_key = node.pubkey_package.clone().unwrap();\n            let mut validators: Vec\u003cValidatorInfo\u003e = node\n                .peers\n                .iter()\n                .map(|p| ValidatorInfo {\n                    pub_key: p.to_bytes(),\n                    stake: 100,\n                })\n                .collect();\n\n            validators.sort_by(|a, b| a.pub_key.cmp(\u0026b.pub_key));\n\n            let chain_config = ChainConfig {\n                min_signers: node.min_signers,\n                max_signers: node.max_signers,\n                min_stake: 100,\n                block_time_seconds: 10,\n                max_block_size: 1000,\n            };\n\n            let expected_initial_state = protocol::block::GenesisState {\n                validators,\n                vault_pub_key: dkg_pub_key.serialize().unwrap(),\n                initial_balances: vec![],\n                chain_config,\n            };\n\n            let mut hasher = Sha256::new();\n            hasher.update(b\"GENESIS\");\n            hasher.update(genesis_block_from_db.header.timestamp.to_le_bytes());\n            let state_bytes =\n                bincode::encode_to_vec(\u0026expected_initial_state, bincode::config::standard())\n                    .unwrap();\n            hasher.update(\u0026state_bytes);\n            let mut expected_state_root = [0u8; 32];\n            expected_state_root.copy_from_slice(\u0026hasher.finalize());\n\n            assert_eq!(\n                genesis_block_from_db.header.state_root, expected_state_root,\n                \"Node {} should have the correct genesis block state root\",\n                peer_id\n            );\n            info!(\"Genesis block metadata verified for node {}\", peer_id);\n        }\n\n        info!(\"Genesis block metadata verified for all nodes!\");\n        cluster.tear_down().await;\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","vidyootsenthil","Documents","TheValut-nameTBD","tests","src","esplora_client","mod.rs"],"content":"#[cfg(test)]\nmod esplora_client_test {\n    use bitcoin::{Address, Network};\n    use clients::{EsploraApiClient, WindowedConfirmedTransactionProvider};\n    use esplora_client::Builder;\n    use std::str::FromStr;\n\n    #[tokio::test]\n    async fn test_get_confirmed_transactions() {\n        let client = EsploraApiClient::new(\n            Builder::new(\"https://blockstream.info/api\")\n                .build_async()\n                .unwrap(),\n            100,\n            None,\n        );\n        let address = Address::from_str(\"bc1qezwz3yt46nsgzcwlg0dsw680nryjpq5u8pvzts\")\n            .unwrap()\n            .require_network(Network::Bitcoin)\n            .unwrap();\n        let transactions = client\n            .get_confirmed_transactions(vec![address.clone()], 899900, 899930)\n            .await\n            .unwrap();\n\n        let correct_txs = [\n            \"99c024e891c3110297513a1bc8c6f36948b36461096e664be72c3ac96e958c5c\",\n            \"1d0249929acaf31c2c6b6e6f9c72f44bd663a426cb146afe0b7bbaa66e0bc0df\",\n            \"fdcd9cf8d660e359a6ab2993d649276fca60be01c2b4327f95ad2527cbe3db08\",\n            \"3fd280c3ccc13f0f88433f0ce95aeebacc249565c8e8b671005302de0616babe\",\n            \"a8705186a9d6b5063484a8029b0e2c4064e3e2723ea61ea10b6bc38d0abbc77a\",\n        ];\n\n        assert_eq!(transactions.len(), correct_txs.len());\n\n        for tx in transactions {\n            assert!(correct_txs.contains(\u0026tx.compute_txid().to_string().as_str()));\n        }\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","vidyootsenthil","Documents","TheValut-nameTBD","tests","src","lib.rs"],"content":"pub mod deposit;\npub mod dkg;\npub mod esplora_client;\npub mod mocks;\npub mod protocol;\npub mod signing;\npub mod util;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","vidyootsenthil","Documents","TheValut-nameTBD","tests","src","mocks","db.rs"],"content":"use std::collections::HashMap;\n\nuse node::db::Db;\nuse node::deposit_intents::DepositIntent;\nuse protocol::{\n    block::{Block, BlockHash},\n    chain_state::ChainState,\n};\nuse types::errors::NodeError;\n\npub struct MockDb {\n    pub blocks: HashMap\u003cBlockHash, Block\u003e,\n    pub chain_state: ChainState,\n    pub height_map: HashMap\u003cu64, BlockHash\u003e,\n    pub tip_block_hash: Option\u003cBlockHash\u003e,\n    pub deposit_intents: HashMap\u003cString, DepositIntent\u003e,\n}\n\nimpl Default for MockDb {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n\nimpl MockDb {\n    pub fn new() -\u003e Self {\n        Self {\n            blocks: HashMap::new(),\n            chain_state: ChainState::new(),\n            height_map: HashMap::new(),\n            tip_block_hash: None,\n            deposit_intents: HashMap::new(),\n        }\n    }\n}\n\nimpl Db for MockDb {\n    fn get_block_by_height(\u0026self, height: u64) -\u003e Result\u003cOption\u003cBlock\u003e, NodeError\u003e {\n        let block_hash = self.height_map.get(\u0026height).cloned();\n        Ok(block_hash.and_then(|hash| self.blocks.get(\u0026hash).cloned()))\n    }\n\n    fn get_block_by_hash(\u0026self, hash: BlockHash) -\u003e Result\u003cOption\u003cBlock\u003e, NodeError\u003e {\n        Ok(self.blocks.get(\u0026hash).cloned())\n    }\n\n    fn get_tip_block_hash(\u0026self) -\u003e Result\u003cOption\u003cBlockHash\u003e, NodeError\u003e {\n        Ok(self.tip_block_hash)\n    }\n\n    fn insert_chain_state(\u0026mut self, chain_state: ChainState) -\u003e Result\u003c(), NodeError\u003e {\n        self.chain_state = chain_state;\n        Ok(())\n    }\n\n    fn get_chain_state(\u0026self) -\u003e Result\u003cOption\u003cChainState\u003e, NodeError\u003e {\n        Ok(Some(self.chain_state.clone()))\n    }\n\n    fn insert_block(\u0026mut self, block: Block) -\u003e Result\u003c(), NodeError\u003e {\n        self.blocks.insert(block.hash(), block.clone());\n        self.height_map.insert(block.header.height, block.hash());\n        self.tip_block_hash = Some(block.hash());\n        Ok(())\n    }\n\n    fn insert_deposit_intent(\u0026mut self, intent: DepositIntent) -\u003e Result\u003c(), NodeError\u003e {\n        self.deposit_intents\n            .insert(intent.deposit_tracking_id.clone(), intent);\n        Ok(())\n    }\n\n    fn get_deposit_intent(\u0026self, tracking_id: \u0026str) -\u003e Result\u003cOption\u003cDepositIntent\u003e, NodeError\u003e {\n        Ok(self.deposit_intents.get(tracking_id).cloned())\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","vidyootsenthil","Documents","TheValut-nameTBD","tests","src","mocks","mod.rs"],"content":"pub mod db;\npub mod network;\npub mod oracle;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","vidyootsenthil","Documents","TheValut-nameTBD","tests","src","mocks","network.rs"],"content":"use std::{\n    collections::BTreeMap,\n    path::PathBuf,\n    sync::{Arc, Mutex},\n    time::Duration,\n};\n\nuse frost_secp256k1::Identifier;\nuse node::{\n    NodeState,\n    swarm_manager::{DirectMessage, Network, NetworkEvent, NetworkResponseFuture, SelfResponse},\n};\nuse tokio::sync::{broadcast, mpsc::unbounded_channel};\nuse types::errors::{self, NetworkError};\n\n// Import MockDb from our mocks module\nuse crate::mocks::db::MockDb;\n\nuse crate::util::local_dkg::perform_distributed_key_generation;\n\n#[derive(Debug)]\npub struct SenderToNode {\n    pub pending_events: Vec\u003cNetworkEvent\u003e,\n    events_emitter_tx: broadcast::Sender\u003cNetworkEvent\u003e,\n}\n\nimpl SenderToNode {\n    fn new(events_emitter_tx: broadcast::Sender\u003cNetworkEvent\u003e) -\u003e Self {\n        Self {\n            pending_events: Vec::new(),\n            events_emitter_tx,\n        }\n    }\n\n    fn queue(\u0026mut self, event: NetworkEvent) {\n        self.pending_events.push(event);\n    }\n\n    fn flush(\u0026mut self) {\n        for event in self.pending_events.drain(..) {\n            self.events_emitter_tx.send(event).unwrap();\n        }\n    }\n}\n\n#[derive(Debug)]\npub struct PendingNetworkEvent {\n    pub from_peer: libp2p::PeerId,\n    pub event: NetworkEvent,\n    pub target_peers: Vec\u003clibp2p::PeerId\u003e, // Empty vec means broadcast to all\n}\n\n#[derive(Debug, Clone)]\n#[allow(dead_code)]\npub struct MockNetwork {\n    pub peer: libp2p::PeerId,\n    pub events_emitter_tx: broadcast::Sender\u003cNetworkEvent\u003e,\n    pub pending_events: Arc\u003cMutex\u003cVec\u003cPendingNetworkEvent\u003e\u003e\u003e,\n}\n\nimpl MockNetwork {\n    pub fn new(events_emitter_tx: broadcast::Sender\u003cNetworkEvent\u003e, peer: libp2p::PeerId) -\u003e Self {\n        Self {\n            events_emitter_tx,\n            peer,\n            pending_events: Arc::new(Mutex::new(Vec::new())),\n        }\n    }\n}\n\nimpl Network for MockNetwork {\n    fn peer_id(\u0026self) -\u003e libp2p::PeerId {\n        self.peer\n    }\n\n    fn send_broadcast(\n        \u0026self,\n        topic: libp2p::gossipsub::IdentTopic,\n        message: Vec\u003cu8\u003e,\n    ) -\u003e Result\u003c(), errors::NetworkError\u003e {\n        let gossip_message = libp2p::gossipsub::Message {\n            source: Some(self.peer),\n            data: message,\n            sequence_number: None,\n            topic: topic.hash(),\n        };\n\n        // Queue the event instead of sending immediately\n        let pending_event = PendingNetworkEvent {\n            from_peer: self.peer,\n            event: NetworkEvent::GossipsubMessage(gossip_message),\n            target_peers: Vec::new(), // Empty means broadcast to all\n        };\n\n        println!(\"Queuing broadcast event: {:?}\", pending_event);\n\n        self.pending_events.lock().unwrap().push(pending_event);\n        Ok(())\n    }\n\n    fn send_private_message(\n        \u0026self,\n        peer_id: libp2p::PeerId,\n        request: node::swarm_manager::DirectMessage,\n    ) -\u003e Result\u003c(), errors::NetworkError\u003e {\n        // For mock purposes, we'll create a simplified message event\n        // In a real implementation, this would use proper request-response channels\n        let pending_event = PendingNetworkEvent {\n            from_peer: self.peer,\n            event: NetworkEvent::MessageEvent((self.peer_id(), request)),\n            target_peers: vec![peer_id],\n        };\n\n        self.pending_events.lock().unwrap().push(pending_event);\n        Ok(())\n    }\n\n    #[allow(unused_variables)]\n    fn send_self_request(\n        \u0026self,\n        request: node::swarm_manager::SelfRequest,\n        sync: bool,\n    ) -\u003e Result\u003cOption\u003cNetworkResponseFuture\u003e, errors::NetworkError\u003e {\n        if sync {\n            let (tx, mut rx) = unbounded_channel::\u003cSelfResponse\u003e();\n\n            let network_message = NetworkEvent::SelfRequest {\n                request,\n                response_channel: Some(tx),\n            };\n\n            self.events_emitter_tx\n                .send(network_message)\n                .map_err(|e| NetworkError::SendError(e.to_string()))?;\n\n            Ok(Some(Box::pin(async move {\n                rx.recv().await.ok_or(NetworkError::RecvError)\n            })))\n        } else {\n            let network_message = NetworkEvent::SelfRequest {\n                request,\n                response_channel: None,\n            };\n\n            self.events_emitter_tx\n                .send(network_message)\n                .map_err(|e| NetworkError::SendError(e.to_string()))?;\n\n            Ok(None)\n        }\n    }\n}\n\npub struct MockNodeCluster {\n    pub nodes: BTreeMap\u003clibp2p::PeerId, NodeState\u003cMockNetwork, MockDb\u003e\u003e,\n    pub senders: BTreeMap\u003clibp2p::PeerId, SenderToNode\u003e,\n    pub networks: BTreeMap\u003clibp2p::PeerId, MockNetwork\u003e,\n}\n\nimpl MockNodeCluster {\n    pub async fn new(peers: u32, min_signers: u16, max_signers: u16) -\u003e Self {\n        let mut path = PathBuf::new();\n        path.push(\"config.json\");\n\n        let mut config_path = PathBuf::new();\n        config_path.push(\"config.toml\");\n\n        let node_config = node::NodeConfig::new(path.clone(), config_path, None, \"test-password\")\n            .expect(\"Failed to create node config\");\n\n        let mut nodes = BTreeMap::new();\n        let mut senders = BTreeMap::new();\n        let mut networks = BTreeMap::new();\n\n        for _i in 0..peers {\n            let peer_id = libp2p::PeerId::random();\n            let Ok((node, network)) =\n                create_node_network(peer_id, node_config.clone(), min_signers, max_signers)\n            else {\n                panic!(\"Failed to create node network\");\n            };\n\n            nodes.insert(peer_id, node);\n            senders.insert(\n                peer_id,\n                SenderToNode::new(network.events_emitter_tx.clone()),\n            );\n            networks.insert(peer_id, network);\n        }\n\n        Self {\n            nodes,\n            senders,\n            networks,\n        }\n    }\n\n    pub async fn setup(\u0026mut self) {\n        // Set environment variable for testing\n        #[allow(clippy::missing_safety_doc)]\n        unsafe {\n            std::env::set_var(\"KEY_PASSWORD\", \"test-password\");\n        }\n\n        let peers: Vec\u003clibp2p::PeerId\u003e = self.nodes.keys().cloned().collect();\n        for (receipient_peer, sender) in self.senders.iter_mut() {\n            sender.queue(NetworkEvent::PeersConnected(\n                peers\n                    .iter()\n                    .filter(|peer_id| *peer_id != receipient_peer)\n                    .map(|peer_id| (*peer_id, libp2p::Multiaddr::empty()))\n                    .collect(),\n            ));\n\n            for peer_id in peers.iter().filter(|peer_id| *peer_id != receipient_peer) {\n                sender.queue(NetworkEvent::Subscribed {\n                    peer_id: *peer_id,\n                    topic: libp2p::gossipsub::IdentTopic::new(\"start-dkg\").hash(),\n                });\n            }\n\n            sender.flush();\n        }\n    }\n\n    pub async fn tear_down(\u0026mut self) {\n        let peers: Vec\u003clibp2p::PeerId\u003e = self.nodes.keys().cloned().collect();\n        for (_, sender) in self.senders.iter_mut() {\n            sender.queue(NetworkEvent::PeersDisconnected(\n                peers\n                    .iter()\n                    .map(|peer_id| (*peer_id, libp2p::Multiaddr::empty()))\n                    .collect(),\n            ));\n        }\n    }\n\n    pub async fn run_n_iterations(\u0026mut self, iterations: u32) {\n        for _ in 0..iterations {\n            // Flush all messages\n            for (_, sender) in self.senders.iter_mut() {\n                sender.flush();\n            }\n\n            // Poll Nodes\n            for (_, node) in self.nodes.iter_mut() {\n                loop {\n                    let more = node.try_poll().await.expect(\"Failed to poll node\");\n                    if !more {\n                        break;\n                    }\n                }\n            }\n\n            // Process any network events generated during polling\n            self.process_network_events().await;\n            tokio::time::sleep(Duration::from_millis(100)).await;\n        }\n    }\n\n    // Process network events that were generated during node polling\n    async fn process_network_events(\u0026mut self) {\n        // Collect all pending events from all networks\n        let mut all_pending_events = Vec::new();\n\n        for (_, network) in self.networks.iter() {\n            let mut pending_events = network.pending_events.lock().unwrap();\n            all_pending_events.extend(pending_events.drain(..));\n        }\n\n        // Process each pending event\n        for pending_event in all_pending_events {\n            self.forward_event_to_peers(pending_event).await;\n        }\n    }\n\n    // Forward a single event to the appropriate target peers\n    async fn forward_event_to_peers(\u0026mut self, pending_event: PendingNetworkEvent) {\n        if pending_event.target_peers.is_empty() {\n            // Broadcast to all peers except the sender\n            let target_peers: Vec\u003clibp2p::PeerId\u003e = self\n                .senders\n                .keys()\n                .filter(|peer_id| **peer_id != pending_event.from_peer)\n                .cloned()\n                .collect();\n\n            for target_peer in target_peers {\n                if let Some(sender) = self.senders.get_mut(\u0026target_peer) {\n                    // We need to recreate the event for each peer since NetworkEvent doesn't implement Clone\n                    let event = match \u0026pending_event.event {\n                        NetworkEvent::GossipsubMessage(msg) =\u003e {\n                            NetworkEvent::GossipsubMessage(libp2p::gossipsub::Message {\n                                source: msg.source,\n                                data: msg.data.clone(),\n                                sequence_number: msg.sequence_number,\n                                topic: msg.topic.clone(),\n                            })\n                        }\n                        NetworkEvent::SelfRequest { request, .. } =\u003e NetworkEvent::SelfRequest {\n                            request: request.clone(),\n                            response_channel: None,\n                        },\n                        NetworkEvent::Subscribed { peer_id, topic } =\u003e NetworkEvent::Subscribed {\n                            peer_id: *peer_id,\n                            topic: topic.clone(),\n                        },\n                        NetworkEvent::MessageEvent((peer, message)) =\u003e {\n                            NetworkEvent::MessageEvent((*peer, message.clone()))\n                        }\n                        NetworkEvent::PeersConnected(items) =\u003e {\n                            NetworkEvent::PeersConnected(items.clone())\n                        }\n                        NetworkEvent::PeersDisconnected(items) =\u003e {\n                            NetworkEvent::PeersDisconnected(items.clone())\n                        }\n                        _ =\u003e {\n                            panic!(\"Unexpected event type: {:?}\", pending_event.event);\n                        }\n                    };\n                    sender.queue(event);\n                }\n            }\n        } else {\n            // Send to specific target peers\n            for target_peer in pending_event.target_peers {\n                if let Some(sender) = self.senders.get_mut(\u0026target_peer) {\n                    // Recreate the event for the target peer\n                    let event = match \u0026pending_event.event {\n                        NetworkEvent::SelfRequest { request, .. } =\u003e NetworkEvent::SelfRequest {\n                            request: request.clone(),\n                            response_channel: None,\n                        },\n                        NetworkEvent::GossipsubMessage(msg) =\u003e {\n                            NetworkEvent::GossipsubMessage(libp2p::gossipsub::Message {\n                                source: msg.source,\n                                data: msg.data.clone(),\n                                sequence_number: msg.sequence_number,\n                                topic: msg.topic.clone(),\n                            })\n                        }\n                        NetworkEvent::PeersConnected(items) =\u003e {\n                            NetworkEvent::PeersConnected(items.clone())\n                        }\n                        NetworkEvent::PeersDisconnected(items) =\u003e {\n                            NetworkEvent::PeersDisconnected(items.clone())\n                        }\n                        NetworkEvent::Subscribed { peer_id, topic } =\u003e NetworkEvent::Subscribed {\n                            peer_id: *peer_id,\n                            topic: topic.clone(),\n                        },\n                        NetworkEvent::MessageEvent((peer, message)) =\u003e {\n                            NetworkEvent::MessageEvent((*peer, message.clone()))\n                        }\n                        _ =\u003e {\n                            continue;\n                        }\n                    };\n                    sender.queue(event);\n                }\n            }\n        }\n    }\n\n    // Methods to send various types of network events for testing\n    pub fn send_broadcast_to_all(\n        \u0026mut self,\n        topic: libp2p::gossipsub::IdentTopic,\n        message: Vec\u003cu8\u003e,\n    ) {\n        let gossip_message = libp2p::gossipsub::Message {\n            source: None, // Simulate external broadcast\n            data: message,\n            sequence_number: None,\n            topic: topic.hash(),\n        };\n\n        for (_, sender) in self.senders.iter_mut() {\n            sender.queue(NetworkEvent::GossipsubMessage(gossip_message.clone()));\n        }\n    }\n\n    pub fn send_private_request_to_peer(\n        \u0026mut self,\n        _from_peer: libp2p::PeerId,\n        to_peer: libp2p::PeerId,\n        request: DirectMessage,\n    ) {\n        if let Some(sender) = self.senders.get_mut(\u0026to_peer) {\n            sender.queue(NetworkEvent::GossipsubMessage(libp2p::gossipsub::Message {\n                source: Some(_from_peer),\n                data: format!(\"private_request:{:?}\", request).into_bytes(),\n                sequence_number: None,\n                topic: libp2p::gossipsub::TopicHash::from_raw(\"private_request\"),\n            }));\n        }\n    }\n\n    pub fn send_self_request_to_peer(\n        \u0026mut self,\n        peer_id: libp2p::PeerId,\n        request: node::swarm_manager::SelfRequest,\n    ) {\n        if let Some(sender) = self.senders.get_mut(\u0026peer_id) {\n            sender.queue(NetworkEvent::SelfRequest {\n                request,\n                response_channel: None,\n            });\n        }\n    }\n\n    pub fn simulate_peer_disconnect(\u0026mut self, peer_id: libp2p::PeerId) {\n        for (recipient_peer, sender) in self.senders.iter_mut() {\n            if *recipient_peer != peer_id {\n                sender.queue(NetworkEvent::PeersDisconnected(vec![(\n                    peer_id,\n                    libp2p::Multiaddr::empty(),\n                )]));\n            }\n        }\n    }\n\n    pub fn simulate_peer_reconnect(\u0026mut self, peer_id: libp2p::PeerId) {\n        for (recipient_peer, sender) in self.senders.iter_mut() {\n            if *recipient_peer != peer_id {\n                sender.queue(NetworkEvent::PeersConnected(vec![(\n                    peer_id,\n                    libp2p::Multiaddr::empty(),\n                )]));\n            }\n        }\n    }\n\n    // Helper method to get peer IDs for testing\n    pub fn get_peer_ids(\u0026self) -\u003e Vec\u003clibp2p::PeerId\u003e {\n        self.nodes.keys().cloned().collect()\n    }\n\n    pub async fn new_with_keys(peers: u32, min_signers: u16, max_signers: u16) -\u003e Self {\n        let mut cluster = Self::new(peers, min_signers, max_signers).await;\n        let identifiers: Vec\u003cIdentifier\u003e = cluster\n            .nodes\n            .keys()\n            .map(node::peer_id_to_identifier)\n            .collect();\n\n        // Run offline DKG once and distribute keys\n        let dkg_out =\n            perform_distributed_key_generation(identifiers, max_signers, min_signers).unwrap();\n\n        for (peer_id, node) in cluster.nodes.iter_mut() {\n            let id = node::peer_id_to_identifier(peer_id);\n            let key_pkg = dkg_out\n                .key_packages\n                .get(\u0026id)\n                .expect(\"missing key package\")\n                .clone();\n            node.private_key_package = Some(key_pkg);\n            node.pubkey_package = Some(dkg_out.pubkey_package.clone());\n        }\n\n        cluster\n    }\n}\n\npub fn create_node_network(\n    peer_id: libp2p::PeerId,\n    node_config: node::NodeConfig,\n    min_signers: u16,\n    max_signers: u16,\n) -\u003e Result\u003c(NodeState\u003cMockNetwork, MockDb\u003e, MockNetwork), errors::NodeError\u003e {\n    let (events_emitter_tx, _) = broadcast::channel::\u003cNetworkEvent\u003e(256);\n    let (deposit_intent_tx, _) = broadcast::channel::\u003cString\u003e(100);\n\n    let network = MockNetwork {\n        events_emitter_tx: events_emitter_tx.clone(),\n        peer: peer_id,\n        pending_events: Arc::new(Mutex::new(Vec::new())),\n    };\n\n    let mock_db = MockDb::new();\n\n    let nodes_state = NodeState::new_from_config(\n        network.clone(),\n        min_signers,\n        max_signers,\n        node_config,\n        mock_db,\n        events_emitter_tx,\n        deposit_intent_tx,\n    )?;\n\n    Ok((nodes_state, network))\n}\n\n#[cfg(test)]\nmod node_tests {\n    use super::*;\n\n    #[tokio::test]\n    async fn peers_can_connect() {\n        let mut cluster = MockNodeCluster::new(2, 2, 2).await;\n        cluster.setup().await;\n        println!(\"Ran setup\");\n        cluster.run_n_iterations(1).await;\n        println!(\"Ran 1 iterations\");\n\n        for (_, node) in cluster.nodes.iter() {\n            assert_eq!(node.peers.len(), 1);\n        }\n\n        cluster.tear_down().await;\n        println!(\"Ran teardown\");\n    }\n\n    #[tokio::test]\n    async fn network_events_are_processed_correctly() {\n        let mut cluster = MockNodeCluster::new(3, 2, 3).await;\n        cluster.setup().await;\n\n        // Get peer IDs for testing\n        let peer_ids = cluster.get_peer_ids();\n        let first_peer = peer_ids[0];\n        let second_peer = peer_ids[1];\n\n        // Manually trigger some network events by calling network methods directly\n        {\n            let first_network = cluster.networks.get(\u0026first_peer).unwrap();\n\n            // Test broadcast\n            let topic = libp2p::gossipsub::IdentTopic::new(\"test-topic\");\n            first_network\n                .send_broadcast(topic, b\"broadcast message\".to_vec())\n                .unwrap();\n\n            // Check that events are queued\n            let pending_events = first_network.pending_events.lock().unwrap();\n            assert_eq!(pending_events.len(), 1, \"Should have 2 pending events\");\n        }\n\n        // Process the events\n        cluster.process_network_events().await;\n\n        // Check that events are cleared from the network after processing\n        {\n            let first_network = cluster.networks.get(\u0026first_peer).unwrap();\n            let pending_events = first_network.pending_events.lock().unwrap();\n            assert_eq!(\n                pending_events.len(),\n                0,\n                \"Pending events should be cleared after processing\"\n            );\n        }\n\n        // Check that events were queued in the appropriate senders\n        let second_sender = cluster.senders.get(\u0026second_peer).unwrap();\n        assert!(\n            !second_sender.pending_events.is_empty(),\n            \"Second peer should have received events\"\n        );\n\n        println!(\"Network event processing works correctly!\");\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","vidyootsenthil","Documents","TheValut-nameTBD","tests","src","mocks","oracle.rs"],"content":"use std::collections::HashMap;\n\nuse bitcoin::Txid;\nuse protocol::oracle::Oracle;\nuse types::errors::NodeError;\n\npub struct MockOracle {\n    // Map of tx_hash -\u003e (address, amount, is_valid)\n    pub transactions: HashMap\u003cString, (String, u64, bool)\u003e,\n}\n\nimpl Default for MockOracle {\n    fn default() -\u003e Self {\n        Self::new()\n    }\n}\n\nimpl MockOracle {\n    pub fn new() -\u003e Self {\n        Self {\n            transactions: HashMap::new(),\n        }\n    }\n\n    pub fn add_transaction(\u0026mut self, tx_hash: Txid, address: String, amount: u64, is_valid: bool) {\n        self.transactions\n            .insert(tx_hash.to_string(), (address, amount, is_valid));\n    }\n}\n\n#[async_trait::async_trait]\nimpl Oracle for MockOracle {\n    async fn validate_transaction(\n        \u0026self,\n        address: \u0026str,\n        amount: u64,\n        tx_hash: Txid,\n    ) -\u003e Result\u003cbool, NodeError\u003e {\n        let tx_hash_str = tx_hash.to_string();\n\n        match self.transactions.get(\u0026tx_hash_str) {\n            Some((expected_address, expected_amount, is_valid)) =\u003e {\n                if expected_address != address {\n                    return Err(NodeError::Error(format!(\n                        \"Address mismatch: expected {}, got {}\",\n                        expected_address, address\n                    )));\n                }\n\n                if *expected_amount != amount {\n                    return Err(NodeError::Error(format!(\n                        \"Amount mismatch: expected {}, got {}\",\n                        expected_amount, amount\n                    )));\n                }\n\n                Ok(*is_valid)\n            }\n            None =\u003e Err(NodeError::Error(\"Transaction not found\".to_string())),\n        }\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","vidyootsenthil","Documents","TheValut-nameTBD","tests","src","protocol","block.rs"],"content":"#[cfg(test)]\nmod block_test {\n    use protocol::block::Block;\n\n    #[test]\n    fn test_block_creation_and_hashing() {\n        let block = Block::new([0u8; 32], [0u8; 32], 1, vec![], vec![1, 2, 3], 0);\n\n        let hash1 = block.hash();\n        let hash2 = block.hash();\n        assert_eq!(hash1, hash2); // Hash should be deterministic\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","vidyootsenthil","Documents","TheValut-nameTBD","tests","src","protocol","deposits.rs"],"content":"#[cfg(test)]\nmod deposit_test {\n    use bitcoin::{Txid, hashes::Hash};\n    use std::collections::HashMap;\n\n    use crate::mocks::oracle::MockOracle;\n    use protocol::{\n        chain_state::{Account, ChainState},\n        executor::TransactionExecutor,\n        transaction::{Operation, Transaction, TransactionType},\n    };\n\n    fn get_test_chain_state() -\u003e ChainState {\n        let accounts = HashMap::from([\n            (\n                \"1\".to_string(),\n                Account {\n                    balance: 0,\n                    address: \"1\".to_string(),\n                },\n            ),\n            (\n                \"2\".to_string(),\n                Account {\n                    balance: 100,\n                    address: \"2\".to_string(),\n                },\n            ),\n            (\n                \"3\".to_string(),\n                Account {\n                    balance: 200,\n                    address: \"3\".to_string(),\n                },\n            ),\n        ]);\n        ChainState::new_with_accounts(accounts, 0)\n    }\n\n    fn create_test_tx_hash() -\u003e Txid {\n        Txid::from_slice(\u0026[1u8; 32]).unwrap()\n    }\n\n    fn create_mock_oracle(transactions: Vec\u003c(Txid, String, u64, bool)\u003e) -\u003e MockOracle {\n        let mut mock_oracle = MockOracle::new();\n        for (tx_hash, address, amount, is_valid) in transactions {\n            mock_oracle.add_transaction(tx_hash, address, amount, is_valid);\n        }\n        mock_oracle\n    }\n\n    #[tokio::test]\n    async fn test_execute_deposit_transaction() {\n        let accounts = HashMap::from([(\n            \"1\".to_string(),\n            Account {\n                balance: 0,\n                address: \"1\".to_string(),\n            },\n        )]);\n        let chain_state = ChainState::new_with_accounts(accounts, 0);\n\n        // Setup mock oracle\n        let tx_hash = create_test_tx_hash();\n        let mock_oracle = create_mock_oracle(vec![(tx_hash, \"1\".to_string(), 100, true)]);\n\n        let transaction = Transaction::new(\n            TransactionType::Deposit,\n            vec![\n                // First, validate the transaction with oracle\n                // OpCheckOracle pops: tx_hash, address, amount\n                // So we push in reverse: amount, address, tx_hash\n                Operation::OpPush {\n                    value: 100u64.to_be_bytes().to_vec(),\n                },\n                Operation::OpPush {\n                    value: \"1\".as_bytes().to_vec(),\n                },\n                Operation::OpPush {\n                    value: tx_hash.as_byte_array().to_vec(),\n                },\n                Operation::OpCheckOracle,\n                // Then increment the balance\n                // OpIncrementBalance pops: address, amount\n                // So we push in reverse: amount, address\n                Operation::OpPush {\n                    value: 100u64.to_be_bytes().to_vec(),\n                },\n                Operation::OpPush {\n                    value: \"1\".as_bytes().to_vec(),\n                },\n                Operation::OpIncrementBalance,\n            ],\n        );\n\n        let mut executor = TransactionExecutor::new(mock_oracle);\n        let result_state = executor\n            .execute_transaction(transaction, chain_state)\n            .await\n            .unwrap();\n        assert_eq!(result_state.get_account(\"1\").unwrap().balance, 100);\n    }\n\n    #[tokio::test]\n    async fn test_execute_deposit_transaction_with_multiple_deposits() {\n        let chain_state = get_test_chain_state();\n\n        // Setup mock oracle with multiple transactions\n        let tx_hash1 = Txid::from_slice(\u0026[1u8; 32]).unwrap();\n        let tx_hash2 = Txid::from_slice(\u0026[2u8; 32]).unwrap();\n        let tx_hash3 = Txid::from_slice(\u0026[3u8; 32]).unwrap();\n        let tx_hash4 = Txid::from_slice(\u0026[4u8; 32]).unwrap();\n\n        let mock_oracle = create_mock_oracle(vec![\n            (tx_hash1, \"1\".to_string(), 100, true),\n            (tx_hash2, \"2\".to_string(), 200, true),\n            (tx_hash3, \"1\".to_string(), 100, true),\n            (tx_hash4, \"3\".to_string(), 300, true),\n        ]);\n\n        let transaction = Transaction::new(\n            TransactionType::Deposit,\n            vec![\n                // First deposit to account 1\n                Operation::OpPush {\n                    value: 100u64.to_be_bytes().to_vec(),\n                },\n                Operation::OpPush {\n                    value: \"1\".as_bytes().to_vec(),\n                },\n                Operation::OpPush {\n                    value: tx_hash1.as_byte_array().to_vec(),\n                },\n                Operation::OpCheckOracle,\n                Operation::OpPush {\n                    value: 100u64.to_be_bytes().to_vec(),\n                },\n                Operation::OpPush {\n                    value: \"1\".as_bytes().to_vec(),\n                },\n                Operation::OpIncrementBalance,\n                // Second deposit to account 2\n                Operation::OpPush {\n                    value: 200u64.to_be_bytes().to_vec(),\n                },\n                Operation::OpPush {\n                    value: \"2\".as_bytes().to_vec(),\n                },\n                Operation::OpPush {\n                    value: tx_hash2.as_byte_array().to_vec(),\n                },\n                Operation::OpCheckOracle,\n                Operation::OpPush {\n                    value: 200u64.to_be_bytes().to_vec(),\n                },\n                Operation::OpPush {\n                    value: \"2\".as_bytes().to_vec(),\n                },\n                Operation::OpIncrementBalance,\n                // Third deposit to account 1 again\n                Operation::OpPush {\n                    value: 100u64.to_be_bytes().to_vec(),\n                },\n                Operation::OpPush {\n                    value: \"1\".as_bytes().to_vec(),\n                },\n                Operation::OpPush {\n                    value: tx_hash3.as_byte_array().to_vec(),\n                },\n                Operation::OpCheckOracle,\n                Operation::OpPush {\n                    value: 100u64.to_be_bytes().to_vec(),\n                },\n                Operation::OpPush {\n                    value: \"1\".as_bytes().to_vec(),\n                },\n                Operation::OpIncrementBalance,\n                // Fourth deposit to account 3\n                Operation::OpPush {\n                    value: 300u64.to_be_bytes().to_vec(),\n                },\n                Operation::OpPush {\n                    value: \"3\".as_bytes().to_vec(),\n                },\n                Operation::OpPush {\n                    value: tx_hash4.as_byte_array().to_vec(),\n                },\n                Operation::OpCheckOracle,\n                Operation::OpPush {\n                    value: 300u64.to_be_bytes().to_vec(),\n                },\n                Operation::OpPush {\n                    value: \"3\".as_bytes().to_vec(),\n                },\n                Operation::OpIncrementBalance,\n            ],\n        );\n\n        let mut executor = TransactionExecutor::new(mock_oracle);\n        let result_state = executor\n            .execute_transaction(transaction, chain_state)\n            .await\n            .unwrap();\n        assert_eq!(result_state.get_account(\"1\").unwrap().balance, 200);\n        assert_eq!(result_state.get_account(\"2\").unwrap().balance, 300);\n        assert_eq!(result_state.get_account(\"3\").unwrap().balance, 500);\n    }\n\n    #[tokio::test]\n    async fn test_execute_deposit_transaction_with_zero_amount() {\n        let chain_state = get_test_chain_state();\n\n        let tx_hash = create_test_tx_hash();\n        let mock_oracle = create_mock_oracle(vec![(tx_hash, \"1\".to_string(), 0, true)]);\n\n        let transaction = Transaction::new(\n            TransactionType::Deposit,\n            vec![\n                Operation::OpPush {\n                    value: 0u64.to_be_bytes().to_vec(),\n                },\n                Operation::OpPush {\n                    value: \"1\".as_bytes().to_vec(),\n                },\n                Operation::OpPush {\n                    value: tx_hash.as_byte_array().to_vec(),\n                },\n                Operation::OpCheckOracle,\n                Operation::OpPush {\n                    value: 0u64.to_be_bytes().to_vec(),\n                },\n                Operation::OpPush {\n                    value: \"1\".as_bytes().to_vec(),\n                },\n                Operation::OpIncrementBalance,\n            ],\n        );\n\n        let mut executor = TransactionExecutor::new(mock_oracle);\n        let result = executor.execute_transaction(transaction, chain_state).await;\n        assert!(result.is_ok());\n        let result_state = result.unwrap();\n        assert_eq!(result_state.get_account(\"1\").unwrap().balance, 0);\n    }\n\n    #[tokio::test]\n    async fn test_execute_deposit_transaction_with_invalid_account() {\n        let chain_state = ChainState::new();\n\n        let tx_hash = create_test_tx_hash();\n        let mock_oracle = create_mock_oracle(vec![(tx_hash, \"1\".to_string(), 100, true)]);\n\n        let transaction = Transaction::new(\n            TransactionType::Deposit,\n            vec![\n                Operation::OpPush {\n                    value: 100u64.to_be_bytes().to_vec(),\n                },\n                Operation::OpPush {\n                    value: \"1\".as_bytes().to_vec(),\n                },\n                Operation::OpPush {\n                    value: tx_hash.as_byte_array().to_vec(),\n                },\n                Operation::OpCheckOracle,\n                Operation::OpPush {\n                    value: 100u64.to_be_bytes().to_vec(),\n                },\n                Operation::OpPush {\n                    value: \"1\".as_bytes().to_vec(),\n                },\n                Operation::OpIncrementBalance,\n            ],\n        );\n\n        let mut executor = TransactionExecutor::new(mock_oracle);\n        let result = executor.execute_transaction(transaction, chain_state).await;\n        // Should succeed - account will be created if it doesn't exist\n        assert!(result.is_ok());\n        assert_eq!(result.unwrap().get_account(\"1\").unwrap().balance, 100);\n    }\n\n    #[tokio::test]\n    async fn test_execute_deposit_transaction_oracle_validation_fails() {\n        let chain_state = get_test_chain_state();\n\n        let tx_hash = create_test_tx_hash();\n        // Set validation to fail\n        let mock_oracle = create_mock_oracle(vec![(tx_hash, \"1\".to_string(), 100, false)]);\n\n        let transaction = Transaction::new(\n            TransactionType::Deposit,\n            vec![\n                Operation::OpPush {\n                    value: 100u64.to_be_bytes().to_vec(),\n                },\n                Operation::OpPush {\n                    value: \"1\".as_bytes().to_vec(),\n                },\n                Operation::OpPush {\n                    value: tx_hash.as_byte_array().to_vec(),\n                },\n                Operation::OpCheckOracle,\n                Operation::OpPush {\n                    value: 100u64.to_be_bytes().to_vec(),\n                },\n                Operation::OpPush {\n                    value: \"1\".as_bytes().to_vec(),\n                },\n                Operation::OpIncrementBalance,\n            ],\n        );\n\n        let mut executor = TransactionExecutor::new(mock_oracle);\n        let result = executor.execute_transaction(transaction, chain_state).await;\n        // Should fail because allowance won't be granted\n        assert!(result.is_err());\n    }\n\n    #[tokio::test]\n    async fn test_execute_deposit_transaction_wrong_amount_in_oracle() {\n        let chain_state = get_test_chain_state();\n\n        let tx_hash = create_test_tx_hash();\n        // Oracle expects 200 but we'll try to validate 100\n        let mock_oracle = create_mock_oracle(vec![(tx_hash, \"1\".to_string(), 200, true)]);\n\n        let transaction = Transaction::new(\n            TransactionType::Deposit,\n            vec![\n                Operation::OpPush {\n                    value: 100u64.to_be_bytes().to_vec(),\n                },\n                Operation::OpPush {\n                    value: \"1\".as_bytes().to_vec(),\n                },\n                Operation::OpPush {\n                    value: tx_hash.as_byte_array().to_vec(),\n                },\n                Operation::OpCheckOracle,\n            ],\n        );\n\n        let mut executor = TransactionExecutor::new(mock_oracle);\n        let result = executor.execute_transaction(transaction, chain_state).await;\n        assert!(result.is_err());\n    }\n\n    #[tokio::test]\n    async fn test_execute_deposit_transaction_without_oracle_check() {\n        let chain_state = get_test_chain_state();\n\n        // Empty oracle since we're not checking any transactions\n        let mock_oracle = create_mock_oracle(vec![]);\n\n        // Try to increment balance without checking oracle first\n        let transaction = Transaction::new(\n            TransactionType::Deposit,\n            vec![\n                Operation::OpPush {\n                    value: 100u64.to_be_bytes().to_vec(),\n                },\n                Operation::OpPush {\n                    value: \"1\".as_bytes().to_vec(),\n                },\n                Operation::OpIncrementBalance,\n            ],\n        );\n\n        let mut executor = TransactionExecutor::new(mock_oracle);\n        let result = executor.execute_transaction(transaction, chain_state).await;\n        // Should fail due to insufficient allowance\n        assert!(result.is_err());\n    }\n\n    #[tokio::test]\n    async fn test_partial_allowance_spending() {\n        let chain_state = get_test_chain_state();\n\n        let tx_hash = create_test_tx_hash();\n        // Oracle validates 100\n        let mock_oracle = create_mock_oracle(vec![(tx_hash, \"1\".to_string(), 100, true)]);\n\n        let transaction = Transaction::new(\n            TransactionType::Deposit,\n            vec![\n                // Validate 100\n                Operation::OpPush {\n                    value: 100u64.to_be_bytes().to_vec(),\n                },\n                Operation::OpPush {\n                    value: \"1\".as_bytes().to_vec(),\n                },\n                Operation::OpPush {\n                    value: tx_hash.as_byte_array().to_vec(),\n                },\n                Operation::OpCheckOracle,\n                // Try to spend 50\n                Operation::OpPush {\n                    value: 50u64.to_be_bytes().to_vec(),\n                },\n                Operation::OpPush {\n                    value: \"1\".as_bytes().to_vec(),\n                },\n                Operation::OpIncrementBalance,\n                // Try to spend another 60 (should fail)\n                Operation::OpPush {\n                    value: 60u64.to_be_bytes().to_vec(),\n                },\n                Operation::OpPush {\n                    value: \"1\".as_bytes().to_vec(),\n                },\n                Operation::OpIncrementBalance,\n            ],\n        );\n\n        let mut executor = TransactionExecutor::new(mock_oracle);\n        let result = executor.execute_transaction(transaction, chain_state).await;\n        // Should fail on the second increment\n        assert!(result.is_err());\n    }\n\n    #[tokio::test]\n    async fn test_multiple_oracle_validations_same_account() {\n        let chain_state = get_test_chain_state();\n\n        let tx_hash1 = Txid::from_slice(\u0026[1u8; 32]).unwrap();\n        let tx_hash2 = Txid::from_slice(\u0026[2u8; 32]).unwrap();\n\n        let mock_oracle = create_mock_oracle(vec![\n            (tx_hash1, \"1\".to_string(), 100, true),\n            (tx_hash2, \"1\".to_string(), 50, true),\n        ]);\n\n        let transaction = Transaction::new(\n            TransactionType::Deposit,\n            vec![\n                // First validation\n                Operation::OpPush {\n                    value: 100u64.to_be_bytes().to_vec(),\n                },\n                Operation::OpPush {\n                    value: \"1\".as_bytes().to_vec(),\n                },\n                Operation::OpPush {\n                    value: tx_hash1.as_byte_array().to_vec(),\n                },\n                Operation::OpCheckOracle,\n                // Second validation\n                Operation::OpPush {\n                    value: 50u64.to_be_bytes().to_vec(),\n                },\n                Operation::OpPush {\n                    value: \"1\".as_bytes().to_vec(),\n                },\n                Operation::OpPush {\n                    value: tx_hash2.as_byte_array().to_vec(),\n                },\n                Operation::OpCheckOracle,\n                // Now we should have 150 allowance, spend it all\n                Operation::OpPush {\n                    value: 150u64.to_be_bytes().to_vec(),\n                },\n                Operation::OpPush {\n                    value: \"1\".as_bytes().to_vec(),\n                },\n                Operation::OpIncrementBalance,\n            ],\n        );\n\n        let mut executor = TransactionExecutor::new(mock_oracle);\n        let result_state = executor\n            .execute_transaction(transaction, chain_state)\n            .await\n            .unwrap();\n        assert_eq!(result_state.get_account(\"1\").unwrap().balance, 150);\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","vidyootsenthil","Documents","TheValut-nameTBD","tests","src","protocol","mod.rs"],"content":"pub mod block;\npub mod deposits;\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","vidyootsenthil","Documents","TheValut-nameTBD","tests","src","signing","mod.rs"],"content":"#[cfg(test)]\npub mod signing_tests {\n    use crate::mocks::network::MockNodeCluster;\n    use node::swarm_manager::{DirectMessage, NetworkEvent, SelfRequest};\n    use rand::RngCore;\n\n    #[tokio::test]\n    async fn signing_flow_completes_and_produces_shares() {\n        let peers = 3;\n        let min_signers = 2;\n        let max_signers = 3;\n\n        // Build cluster with pre-generated FROST keys – no DKG needed\n        let mut cluster = MockNodeCluster::new_with_keys(peers, min_signers, max_signers).await;\n        cluster.setup().await;\n\n        // ── start signing ──\n        let initiator = *cluster.nodes.keys().next().unwrap();\n        let mut msg = [0u8; 32];\n        rand::rng().fill_bytes(\u0026mut msg);\n        let hex_msg = hex::encode(msg);\n\n        cluster.send_self_request_to_peer(\n            initiator,\n            SelfRequest::StartSigningSession {\n                hex_message: hex_msg,\n            },\n        );\n\n        // ── drive the network and count messages ──\n        let (mut req, mut comm, mut pack, mut share) = (0, 0, 0, 0);\n        for _ in 0..100 {\n            cluster.run_n_iterations(1).await;\n\n            // count DirectMessage traffic still queued in the mock senders\n            for sender in cluster.senders.values() {\n                for ev in \u0026sender.pending_events {\n                    if let NetworkEvent::MessageEvent((_, dm)) = ev {\n                        match dm {\n                            DirectMessage::SignRequest { .. } =\u003e req += 1,\n                            DirectMessage::Commitments { .. } =\u003e comm += 1,\n                            DirectMessage::SignPackage { .. } =\u003e pack += 1,\n                            DirectMessage::SignatureShare { .. } =\u003e share += 1,\n                            _ =\u003e {}\n                        }\n                    }\n                }\n            }\n            // // break once no messages are left in either channel\n            if cluster\n                .senders\n                .values()\n                .all(|s| s.pending_events.is_empty())\n                \u0026\u0026 cluster\n                    .networks\n                    .values()\n                    .all(|n| n.pending_events.lock().unwrap().is_empty())\n            {\n                break;\n            }\n        }\n\n        // ── explicit assertions ──\n        assert!(req \u003e= min_signers as usize - 1, \"missing SignRequest(s)\");\n        assert!(comm \u003e= min_signers as usize - 1, \"missing Commitments\");\n        assert!(pack \u003e= min_signers as usize - 1, \"missing SignPackage\");\n        assert!(share \u003e= min_signers as usize - 1, \"missing SignatureShare\");\n\n        // protocol should be finished – no pending spends\n        for node in cluster.nodes.values() {\n            let signing_state = node\n                .handlers\n                .iter()\n                .find_map(|h| h.downcast_ref::\u003cnode::signing::SigningState\u003e());\n            assert!(\n                signing_state.unwrap().active_signing.is_none(),\n                \"node still has pending signing {:?}\",\n                node.peer_id\n            );\n        }\n    }\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","vidyootsenthil","Documents","TheValut-nameTBD","tests","src","util","local_dkg.rs"],"content":"use frost_secp256k1 as frost;\nuse frost_secp256k1::keys::{KeyPackage, PublicKeyPackage};\nuse std::collections::BTreeMap;\n\n/// Result of DKG process containing key packages for all participants\n#[derive(Debug, Clone)]\npub struct DkgResult {\n    /// Key packages for each participant (contains their secret shares)\n    pub key_packages: BTreeMap\u003cfrost::Identifier, KeyPackage\u003e,\n    /// Public key package (same for all participants)\n    pub pubkey_package: PublicKeyPackage,\n}\n\n/// Error types for DKG operations\n#[derive(Debug)]\npub enum DkgError {\n    FrostError(frost::Error),\n    InvalidParticipant(String),\n    CommunicationError(String),\n}\n\nimpl std::fmt::Display for DkgError {\n    fn fmt(\u0026self, f: \u0026mut std::fmt::Formatter\u003c'_\u003e) -\u003e std::fmt::Result {\n        match self {\n            DkgError::FrostError(e) =\u003e write!(f, \"FROST error: {}\", e),\n            DkgError::InvalidParticipant(msg) =\u003e write!(f, \"Invalid participant: {}\", msg),\n            DkgError::CommunicationError(msg) =\u003e write!(f, \"Communication error: {}\", msg),\n        }\n    }\n}\n\nimpl std::error::Error for DkgError {}\n\nimpl From\u003cfrost::Error\u003e for DkgError {\n    fn from(e: frost::Error) -\u003e Self {\n        DkgError::FrostError(e)\n    }\n}\n\n/// Perform a full dealer-less DKG entirely in-memory.\npub fn perform_distributed_key_generation(\n    peers: Vec\u003cfrost::Identifier\u003e,\n    max_signers: u16,\n    min_signers: u16,\n) -\u003e Result\u003cDkgResult, DkgError\u003e {\n    use frost::keys::dkg::{round1, round2};\n\n    if min_signers == 0 || max_signers == 0 || min_signers \u003e max_signers {\n        return Err(DkgError::InvalidParticipant(\n            \"Invalid signer parameters\".to_string(),\n        ));\n    }\n    let rng = frost::rand_core::OsRng;\n\n    // Round1 secret/package maps\n    let mut r1_secret: BTreeMap\u003c_, round1::SecretPackage\u003e = BTreeMap::new();\n    let mut r1_pkg_sent: BTreeMap\u003c_, BTreeMap\u003c_, round1::Package\u003e\u003e = BTreeMap::new();\n\n    for id in peers.clone() {\n        let (sec, pkg) = frost::keys::dkg::part1(id, max_signers, min_signers, rng)?;\n        r1_secret.insert(id, sec);\n        // broadcast pkg to others\n        for recv_id in peers.clone() {\n            if recv_id == id {\n                continue;\n            }\n            r1_pkg_sent\n                .entry(recv_id)\n                .or_default()\n                .insert(id, pkg.clone());\n        }\n    }\n\n    // Round2\n    let mut r2_secret: BTreeMap\u003c_, round2::SecretPackage\u003e = BTreeMap::new();\n    let mut r2_pkg_sent: BTreeMap\u003c_, BTreeMap\u003c_, round2::Package\u003e\u003e = BTreeMap::new();\n\n    for id in peers.clone() {\n        let sec1 = r1_secret.get(\u0026id).unwrap().clone();\n        let r1_recv = r1_pkg_sent.get(\u0026id).unwrap();\n        let (sec2, pkgs2) = frost::keys::dkg::part2(sec1, r1_recv)?;\n        r2_secret.insert(id, sec2);\n        for (recv_id, pkg) in pkgs2 {\n            r2_pkg_sent.entry(recv_id).or_default().insert(id, pkg);\n        }\n    }\n\n    // Round3, build key packages\n    let mut key_pkgs = BTreeMap::new();\n    let mut group_pub: Option\u003cPublicKeyPackage\u003e = None;\n\n    for id in peers {\n        let sec2 = r2_secret.get(\u0026id).unwrap();\n        let r1_recv = r1_pkg_sent.get(\u0026id).unwrap();\n        let r2_recv = r2_pkg_sent.get(\u0026id).unwrap();\n        let (key_pkg, pub_pkg) = frost::keys::dkg::part3(sec2, r1_recv, r2_recv)?;\n        if group_pub.is_none() {\n            group_pub = Some(pub_pkg.clone());\n        }\n        key_pkgs.insert(id, key_pkg);\n    }\n\n    Ok(DkgResult {\n        key_packages: key_pkgs,\n        pubkey_package: group_pub.expect(\"pubkey package\"),\n    })\n}\n","traces":[],"covered":0,"coverable":0},{"path":["/","home","vidyootsenthil","Documents","TheValut-nameTBD","tests","src","util","mod.rs"],"content":"pub mod local_dkg;\n","traces":[],"covered":0,"coverable":0}]};
    </script>
    <script crossorigin>/** @license React v16.13.1
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
'use strict';(function(d,r){"object"===typeof exports&&"undefined"!==typeof module?r(exports):"function"===typeof define&&define.amd?define(["exports"],r):(d=d||self,r(d.React={}))})(this,function(d){function r(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
function w(a,b,c){this.props=a;this.context=b;this.refs=ba;this.updater=c||ca}function da(){}function L(a,b,c){this.props=a;this.context=b;this.refs=ba;this.updater=c||ca}function ea(a,b,c){var g,e={},fa=null,d=null;if(null!=b)for(g in void 0!==b.ref&&(d=b.ref),void 0!==b.key&&(fa=""+b.key),b)ha.call(b,g)&&!ia.hasOwnProperty(g)&&(e[g]=b[g]);var h=arguments.length-2;if(1===h)e.children=c;else if(1<h){for(var k=Array(h),f=0;f<h;f++)k[f]=arguments[f+2];e.children=k}if(a&&a.defaultProps)for(g in h=a.defaultProps,
h)void 0===e[g]&&(e[g]=h[g]);return{$$typeof:x,type:a,key:fa,ref:d,props:e,_owner:M.current}}function va(a,b){return{$$typeof:x,type:a.type,key:b,ref:a.ref,props:a.props,_owner:a._owner}}function N(a){return"object"===typeof a&&null!==a&&a.$$typeof===x}function wa(a){var b={"=":"=0",":":"=2"};return"$"+(""+a).replace(/[=:]/g,function(a){return b[a]})}function ja(a,b,c,g){if(C.length){var e=C.pop();e.result=a;e.keyPrefix=b;e.func=c;e.context=g;e.count=0;return e}return{result:a,keyPrefix:b,func:c,
context:g,count:0}}function ka(a){a.result=null;a.keyPrefix=null;a.func=null;a.context=null;a.count=0;10>C.length&&C.push(a)}function O(a,b,c,g){var e=typeof a;if("undefined"===e||"boolean"===e)a=null;var d=!1;if(null===a)d=!0;else switch(e){case "string":case "number":d=!0;break;case "object":switch(a.$$typeof){case x:case xa:d=!0}}if(d)return c(g,a,""===b?"."+P(a,0):b),1;d=0;b=""===b?".":b+":";if(Array.isArray(a))for(var f=0;f<a.length;f++){e=a[f];var h=b+P(e,f);d+=O(e,h,c,g)}else if(null===a||
"object"!==typeof a?h=null:(h=la&&a[la]||a["@@iterator"],h="function"===typeof h?h:null),"function"===typeof h)for(a=h.call(a),f=0;!(e=a.next()).done;)e=e.value,h=b+P(e,f++),d+=O(e,h,c,g);else if("object"===e)throw c=""+a,Error(r(31,"[object Object]"===c?"object with keys {"+Object.keys(a).join(", ")+"}":c,""));return d}function Q(a,b,c){return null==a?0:O(a,"",b,c)}function P(a,b){return"object"===typeof a&&null!==a&&null!=a.key?wa(a.key):b.toString(36)}function ya(a,b,c){a.func.call(a.context,b,
a.count++)}function za(a,b,c){var g=a.result,e=a.keyPrefix;a=a.func.call(a.context,b,a.count++);Array.isArray(a)?R(a,g,c,function(a){return a}):null!=a&&(N(a)&&(a=va(a,e+(!a.key||b&&b.key===a.key?"":(""+a.key).replace(ma,"$&/")+"/")+c)),g.push(a))}function R(a,b,c,g,e){var d="";null!=c&&(d=(""+c).replace(ma,"$&/")+"/");b=ja(b,d,g,e);Q(a,za,b);ka(b)}function t(){var a=na.current;if(null===a)throw Error(r(321));return a}function S(a,b){var c=a.length;a.push(b);a:for(;;){var g=c-1>>>1,e=a[g];if(void 0!==
e&&0<D(e,b))a[g]=b,a[c]=e,c=g;else break a}}function n(a){a=a[0];return void 0===a?null:a}function E(a){var b=a[0];if(void 0!==b){var c=a.pop();if(c!==b){a[0]=c;a:for(var g=0,e=a.length;g<e;){var d=2*(g+1)-1,f=a[d],h=d+1,k=a[h];if(void 0!==f&&0>D(f,c))void 0!==k&&0>D(k,f)?(a[g]=k,a[h]=c,g=h):(a[g]=f,a[d]=c,g=d);else if(void 0!==k&&0>D(k,c))a[g]=k,a[h]=c,g=h;else break a}}return b}return null}function D(a,b){var c=a.sortIndex-b.sortIndex;return 0!==c?c:a.id-b.id}function F(a){for(var b=n(u);null!==
b;){if(null===b.callback)E(u);else if(b.startTime<=a)E(u),b.sortIndex=b.expirationTime,S(p,b);else break;b=n(u)}}function T(a){y=!1;F(a);if(!v)if(null!==n(p))v=!0,z(U);else{var b=n(u);null!==b&&G(T,b.startTime-a)}}function U(a,b){v=!1;y&&(y=!1,V());H=!0;var c=m;try{F(b);for(l=n(p);null!==l&&(!(l.expirationTime>b)||a&&!W());){var g=l.callback;if(null!==g){l.callback=null;m=l.priorityLevel;var e=g(l.expirationTime<=b);b=q();"function"===typeof e?l.callback=e:l===n(p)&&E(p);F(b)}else E(p);l=n(p)}if(null!==
l)var d=!0;else{var f=n(u);null!==f&&G(T,f.startTime-b);d=!1}return d}finally{l=null,m=c,H=!1}}function oa(a){switch(a){case 1:return-1;case 2:return 250;case 5:return 1073741823;case 4:return 1E4;default:return 5E3}}var f="function"===typeof Symbol&&Symbol.for,x=f?Symbol.for("react.element"):60103,xa=f?Symbol.for("react.portal"):60106,Aa=f?Symbol.for("react.fragment"):60107,Ba=f?Symbol.for("react.strict_mode"):60108,Ca=f?Symbol.for("react.profiler"):60114,Da=f?Symbol.for("react.provider"):60109,
Ea=f?Symbol.for("react.context"):60110,Fa=f?Symbol.for("react.forward_ref"):60112,Ga=f?Symbol.for("react.suspense"):60113,Ha=f?Symbol.for("react.memo"):60115,Ia=f?Symbol.for("react.lazy"):60116,la="function"===typeof Symbol&&Symbol.iterator,pa=Object.getOwnPropertySymbols,Ja=Object.prototype.hasOwnProperty,Ka=Object.prototype.propertyIsEnumerable,I=function(){try{if(!Object.assign)return!1;var a=new String("abc");a[5]="de";if("5"===Object.getOwnPropertyNames(a)[0])return!1;var b={};for(a=0;10>a;a++)b["_"+
String.fromCharCode(a)]=a;if("0123456789"!==Object.getOwnPropertyNames(b).map(function(a){return b[a]}).join(""))return!1;var c={};"abcdefghijklmnopqrst".split("").forEach(function(a){c[a]=a});return"abcdefghijklmnopqrst"!==Object.keys(Object.assign({},c)).join("")?!1:!0}catch(g){return!1}}()?Object.assign:function(a,b){if(null===a||void 0===a)throw new TypeError("Object.assign cannot be called with null or undefined");var c=Object(a);for(var g,e=1;e<arguments.length;e++){var d=Object(arguments[e]);
for(var f in d)Ja.call(d,f)&&(c[f]=d[f]);if(pa){g=pa(d);for(var h=0;h<g.length;h++)Ka.call(d,g[h])&&(c[g[h]]=d[g[h]])}}return c},ca={isMounted:function(a){return!1},enqueueForceUpdate:function(a,b,c){},enqueueReplaceState:function(a,b,c,d){},enqueueSetState:function(a,b,c,d){}},ba={};w.prototype.isReactComponent={};w.prototype.setState=function(a,b){if("object"!==typeof a&&"function"!==typeof a&&null!=a)throw Error(r(85));this.updater.enqueueSetState(this,a,b,"setState")};w.prototype.forceUpdate=
function(a){this.updater.enqueueForceUpdate(this,a,"forceUpdate")};da.prototype=w.prototype;f=L.prototype=new da;f.constructor=L;I(f,w.prototype);f.isPureReactComponent=!0;var M={current:null},ha=Object.prototype.hasOwnProperty,ia={key:!0,ref:!0,__self:!0,__source:!0},ma=/\/+/g,C=[],na={current:null},X;if("undefined"===typeof window||"function"!==typeof MessageChannel){var A=null,qa=null,ra=function(){if(null!==A)try{var a=q();A(!0,a);A=null}catch(b){throw setTimeout(ra,0),b;}},La=Date.now();var q=
function(){return Date.now()-La};var z=function(a){null!==A?setTimeout(z,0,a):(A=a,setTimeout(ra,0))};var G=function(a,b){qa=setTimeout(a,b)};var V=function(){clearTimeout(qa)};var W=function(){return!1};f=X=function(){}}else{var Y=window.performance,sa=window.Date,Ma=window.setTimeout,Na=window.clearTimeout;"undefined"!==typeof console&&(f=window.cancelAnimationFrame,"function"!==typeof window.requestAnimationFrame&&console.error("This browser doesn't support requestAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"),
"function"!==typeof f&&console.error("This browser doesn't support cancelAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"));if("object"===typeof Y&&"function"===typeof Y.now)q=function(){return Y.now()};else{var Oa=sa.now();q=function(){return sa.now()-Oa}}var J=!1,K=null,Z=-1,ta=5,ua=0;W=function(){return q()>=ua};f=function(){};X=function(a){0>a||125<a?console.error("forceFrameRate takes a positive int between 0 and 125, forcing framerates higher than 125 fps is not unsupported"):
ta=0<a?Math.floor(1E3/a):5};var B=new MessageChannel,aa=B.port2;B.port1.onmessage=function(){if(null!==K){var a=q();ua=a+ta;try{K(!0,a)?aa.postMessage(null):(J=!1,K=null)}catch(b){throw aa.postMessage(null),b;}}else J=!1};z=function(a){K=a;J||(J=!0,aa.postMessage(null))};G=function(a,b){Z=Ma(function(){a(q())},b)};V=function(){Na(Z);Z=-1}}var p=[],u=[],Pa=1,l=null,m=3,H=!1,v=!1,y=!1,Qa=0;B={ReactCurrentDispatcher:na,ReactCurrentOwner:M,IsSomeRendererActing:{current:!1},assign:I};I(B,{Scheduler:{__proto__:null,
unstable_ImmediatePriority:1,unstable_UserBlockingPriority:2,unstable_NormalPriority:3,unstable_IdlePriority:5,unstable_LowPriority:4,unstable_runWithPriority:function(a,b){switch(a){case 1:case 2:case 3:case 4:case 5:break;default:a=3}var c=m;m=a;try{return b()}finally{m=c}},unstable_next:function(a){switch(m){case 1:case 2:case 3:var b=3;break;default:b=m}var c=m;m=b;try{return a()}finally{m=c}},unstable_scheduleCallback:function(a,b,c){var d=q();if("object"===typeof c&&null!==c){var e=c.delay;
e="number"===typeof e&&0<e?d+e:d;c="number"===typeof c.timeout?c.timeout:oa(a)}else c=oa(a),e=d;c=e+c;a={id:Pa++,callback:b,priorityLevel:a,startTime:e,expirationTime:c,sortIndex:-1};e>d?(a.sortIndex=e,S(u,a),null===n(p)&&a===n(u)&&(y?V():y=!0,G(T,e-d))):(a.sortIndex=c,S(p,a),v||H||(v=!0,z(U)));return a},unstable_cancelCallback:function(a){a.callback=null},unstable_wrapCallback:function(a){var b=m;return function(){var c=m;m=b;try{return a.apply(this,arguments)}finally{m=c}}},unstable_getCurrentPriorityLevel:function(){return m},
unstable_shouldYield:function(){var a=q();F(a);var b=n(p);return b!==l&&null!==l&&null!==b&&null!==b.callback&&b.startTime<=a&&b.expirationTime<l.expirationTime||W()},unstable_requestPaint:f,unstable_continueExecution:function(){v||H||(v=!0,z(U))},unstable_pauseExecution:function(){},unstable_getFirstCallbackNode:function(){return n(p)},get unstable_now(){return q},get unstable_forceFrameRate(){return X},unstable_Profiling:null},SchedulerTracing:{__proto__:null,__interactionsRef:null,__subscriberRef:null,
unstable_clear:function(a){return a()},unstable_getCurrent:function(){return null},unstable_getThreadID:function(){return++Qa},unstable_trace:function(a,b,c){return c()},unstable_wrap:function(a){return a},unstable_subscribe:function(a){},unstable_unsubscribe:function(a){}}});d.Children={map:function(a,b,c){if(null==a)return a;var d=[];R(a,d,null,b,c);return d},forEach:function(a,b,c){if(null==a)return a;b=ja(null,null,b,c);Q(a,ya,b);ka(b)},count:function(a){return Q(a,function(){return null},null)},
toArray:function(a){var b=[];R(a,b,null,function(a){return a});return b},only:function(a){if(!N(a))throw Error(r(143));return a}};d.Component=w;d.Fragment=Aa;d.Profiler=Ca;d.PureComponent=L;d.StrictMode=Ba;d.Suspense=Ga;d.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=B;d.cloneElement=function(a,b,c){if(null===a||void 0===a)throw Error(r(267,a));var d=I({},a.props),e=a.key,f=a.ref,m=a._owner;if(null!=b){void 0!==b.ref&&(f=b.ref,m=M.current);void 0!==b.key&&(e=""+b.key);if(a.type&&a.type.defaultProps)var h=
a.type.defaultProps;for(k in b)ha.call(b,k)&&!ia.hasOwnProperty(k)&&(d[k]=void 0===b[k]&&void 0!==h?h[k]:b[k])}var k=arguments.length-2;if(1===k)d.children=c;else if(1<k){h=Array(k);for(var l=0;l<k;l++)h[l]=arguments[l+2];d.children=h}return{$$typeof:x,type:a.type,key:e,ref:f,props:d,_owner:m}};d.createContext=function(a,b){void 0===b&&(b=null);a={$$typeof:Ea,_calculateChangedBits:b,_currentValue:a,_currentValue2:a,_threadCount:0,Provider:null,Consumer:null};a.Provider={$$typeof:Da,_context:a};return a.Consumer=
a};d.createElement=ea;d.createFactory=function(a){var b=ea.bind(null,a);b.type=a;return b};d.createRef=function(){return{current:null}};d.forwardRef=function(a){return{$$typeof:Fa,render:a}};d.isValidElement=N;d.lazy=function(a){return{$$typeof:Ia,_ctor:a,_status:-1,_result:null}};d.memo=function(a,b){return{$$typeof:Ha,type:a,compare:void 0===b?null:b}};d.useCallback=function(a,b){return t().useCallback(a,b)};d.useContext=function(a,b){return t().useContext(a,b)};d.useDebugValue=function(a,b){};
d.useEffect=function(a,b){return t().useEffect(a,b)};d.useImperativeHandle=function(a,b,c){return t().useImperativeHandle(a,b,c)};d.useLayoutEffect=function(a,b){return t().useLayoutEffect(a,b)};d.useMemo=function(a,b){return t().useMemo(a,b)};d.useReducer=function(a,b,c){return t().useReducer(a,b,c)};d.useRef=function(a){return t().useRef(a)};d.useState=function(a){return t().useState(a)};d.version="16.13.1"});
</script>
    <script crossorigin>/** @license React v16.13.1
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/*
 Modernizr 3.0.0pre (Custom Build) | MIT
*/
'use strict';(function(I,ea){"object"===typeof exports&&"undefined"!==typeof module?ea(exports,require("react")):"function"===typeof define&&define.amd?define(["exports","react"],ea):(I=I||self,ea(I.ReactDOM={},I.React))})(this,function(I,ea){function k(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}
function ji(a,b,c,d,e,f,g,h,m){yb=!1;gc=null;ki.apply(li,arguments)}function mi(a,b,c,d,e,f,g,h,m){ji.apply(this,arguments);if(yb){if(yb){var n=gc;yb=!1;gc=null}else throw Error(k(198));hc||(hc=!0,pd=n)}}function lf(a,b,c){var d=a.type||"unknown-event";a.currentTarget=mf(c);mi(d,b,void 0,a);a.currentTarget=null}function nf(){if(ic)for(var a in cb){var b=cb[a],c=ic.indexOf(a);if(!(-1<c))throw Error(k(96,a));if(!jc[c]){if(!b.extractEvents)throw Error(k(97,a));jc[c]=b;c=b.eventTypes;for(var d in c){var e=
void 0;var f=c[d],g=b,h=d;if(qd.hasOwnProperty(h))throw Error(k(99,h));qd[h]=f;var m=f.phasedRegistrationNames;if(m){for(e in m)m.hasOwnProperty(e)&&of(m[e],g,h);e=!0}else f.registrationName?(of(f.registrationName,g,h),e=!0):e=!1;if(!e)throw Error(k(98,d,a));}}}}function of(a,b,c){if(db[a])throw Error(k(100,a));db[a]=b;rd[a]=b.eventTypes[c].dependencies}function pf(a){var b=!1,c;for(c in a)if(a.hasOwnProperty(c)){var d=a[c];if(!cb.hasOwnProperty(c)||cb[c]!==d){if(cb[c])throw Error(k(102,c));cb[c]=
d;b=!0}}b&&nf()}function qf(a){if(a=rf(a)){if("function"!==typeof sd)throw Error(k(280));var b=a.stateNode;b&&(b=td(b),sd(a.stateNode,a.type,b))}}function sf(a){eb?fb?fb.push(a):fb=[a]:eb=a}function tf(){if(eb){var a=eb,b=fb;fb=eb=null;qf(a);if(b)for(a=0;a<b.length;a++)qf(b[a])}}function ud(){if(null!==eb||null!==fb)vd(),tf()}function uf(a,b,c){if(wd)return a(b,c);wd=!0;try{return vf(a,b,c)}finally{wd=!1,ud()}}function ni(a){if(wf.call(xf,a))return!0;if(wf.call(yf,a))return!1;if(oi.test(a))return xf[a]=
!0;yf[a]=!0;return!1}function pi(a,b,c,d){if(null!==c&&0===c.type)return!1;switch(typeof b){case "function":case "symbol":return!0;case "boolean":if(d)return!1;if(null!==c)return!c.acceptsBooleans;a=a.toLowerCase().slice(0,5);return"data-"!==a&&"aria-"!==a;default:return!1}}function qi(a,b,c,d){if(null===b||"undefined"===typeof b||pi(a,b,c,d))return!0;if(d)return!1;if(null!==c)switch(c.type){case 3:return!b;case 4:return!1===b;case 5:return isNaN(b);case 6:return isNaN(b)||1>b}return!1}function L(a,
b,c,d,e,f){this.acceptsBooleans=2===b||3===b||4===b;this.attributeName=d;this.attributeNamespace=e;this.mustUseProperty=c;this.propertyName=a;this.type=b;this.sanitizeURL=f}function xd(a,b,c,d){var e=E.hasOwnProperty(b)?E[b]:null;var f=null!==e?0===e.type:d?!1:!(2<b.length)||"o"!==b[0]&&"O"!==b[0]||"n"!==b[1]&&"N"!==b[1]?!1:!0;f||(qi(b,c,e,d)&&(c=null),d||null===e?ni(b)&&(null===c?a.removeAttribute(b):a.setAttribute(b,""+c)):e.mustUseProperty?a[e.propertyName]=null===c?3===e.type?!1:"":c:(b=e.attributeName,
d=e.attributeNamespace,null===c?a.removeAttribute(b):(e=e.type,c=3===e||4===e&&!0===c?"":""+c,d?a.setAttributeNS(d,b,c):a.setAttribute(b,c))))}function zb(a){if(null===a||"object"!==typeof a)return null;a=zf&&a[zf]||a["@@iterator"];return"function"===typeof a?a:null}function ri(a){if(-1===a._status){a._status=0;var b=a._ctor;b=b();a._result=b;b.then(function(b){0===a._status&&(b=b.default,a._status=1,a._result=b)},function(b){0===a._status&&(a._status=2,a._result=b)})}}function na(a){if(null==a)return null;
if("function"===typeof a)return a.displayName||a.name||null;if("string"===typeof a)return a;switch(a){case Ma:return"Fragment";case gb:return"Portal";case kc:return"Profiler";case Af:return"StrictMode";case lc:return"Suspense";case yd:return"SuspenseList"}if("object"===typeof a)switch(a.$$typeof){case Bf:return"Context.Consumer";case Cf:return"Context.Provider";case zd:var b=a.render;b=b.displayName||b.name||"";return a.displayName||(""!==b?"ForwardRef("+b+")":"ForwardRef");case Ad:return na(a.type);
case Df:return na(a.render);case Ef:if(a=1===a._status?a._result:null)return na(a)}return null}function Bd(a){var b="";do{a:switch(a.tag){case 3:case 4:case 6:case 7:case 10:case 9:var c="";break a;default:var d=a._debugOwner,e=a._debugSource,f=na(a.type);c=null;d&&(c=na(d.type));d=f;f="";e?f=" (at "+e.fileName.replace(si,"")+":"+e.lineNumber+")":c&&(f=" (created by "+c+")");c="\n    in "+(d||"Unknown")+f}b+=c;a=a.return}while(a);return b}function va(a){switch(typeof a){case "boolean":case "number":case "object":case "string":case "undefined":return a;
default:return""}}function Ff(a){var b=a.type;return(a=a.nodeName)&&"input"===a.toLowerCase()&&("checkbox"===b||"radio"===b)}function ti(a){var b=Ff(a)?"checked":"value",c=Object.getOwnPropertyDescriptor(a.constructor.prototype,b),d=""+a[b];if(!a.hasOwnProperty(b)&&"undefined"!==typeof c&&"function"===typeof c.get&&"function"===typeof c.set){var e=c.get,f=c.set;Object.defineProperty(a,b,{configurable:!0,get:function(){return e.call(this)},set:function(a){d=""+a;f.call(this,a)}});Object.defineProperty(a,
b,{enumerable:c.enumerable});return{getValue:function(){return d},setValue:function(a){d=""+a},stopTracking:function(){a._valueTracker=null;delete a[b]}}}}function mc(a){a._valueTracker||(a._valueTracker=ti(a))}function Gf(a){if(!a)return!1;var b=a._valueTracker;if(!b)return!0;var c=b.getValue();var d="";a&&(d=Ff(a)?a.checked?"true":"false":a.value);a=d;return a!==c?(b.setValue(a),!0):!1}function Cd(a,b){var c=b.checked;return M({},b,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:null!=
c?c:a._wrapperState.initialChecked})}function Hf(a,b){var c=null==b.defaultValue?"":b.defaultValue,d=null!=b.checked?b.checked:b.defaultChecked;c=va(null!=b.value?b.value:c);a._wrapperState={initialChecked:d,initialValue:c,controlled:"checkbox"===b.type||"radio"===b.type?null!=b.checked:null!=b.value}}function If(a,b){b=b.checked;null!=b&&xd(a,"checked",b,!1)}function Dd(a,b){If(a,b);var c=va(b.value),d=b.type;if(null!=c)if("number"===d){if(0===c&&""===a.value||a.value!=c)a.value=""+c}else a.value!==
""+c&&(a.value=""+c);else if("submit"===d||"reset"===d){a.removeAttribute("value");return}b.hasOwnProperty("value")?Ed(a,b.type,c):b.hasOwnProperty("defaultValue")&&Ed(a,b.type,va(b.defaultValue));null==b.checked&&null!=b.defaultChecked&&(a.defaultChecked=!!b.defaultChecked)}function Jf(a,b,c){if(b.hasOwnProperty("value")||b.hasOwnProperty("defaultValue")){var d=b.type;if(!("submit"!==d&&"reset"!==d||void 0!==b.value&&null!==b.value))return;b=""+a._wrapperState.initialValue;c||b===a.value||(a.value=
b);a.defaultValue=b}c=a.name;""!==c&&(a.name="");a.defaultChecked=!!a._wrapperState.initialChecked;""!==c&&(a.name=c)}function Ed(a,b,c){if("number"!==b||a.ownerDocument.activeElement!==a)null==c?a.defaultValue=""+a._wrapperState.initialValue:a.defaultValue!==""+c&&(a.defaultValue=""+c)}function ui(a){var b="";ea.Children.forEach(a,function(a){null!=a&&(b+=a)});return b}function Fd(a,b){a=M({children:void 0},b);if(b=ui(b.children))a.children=b;return a}function hb(a,b,c,d){a=a.options;if(b){b={};
for(var e=0;e<c.length;e++)b["$"+c[e]]=!0;for(c=0;c<a.length;c++)e=b.hasOwnProperty("$"+a[c].value),a[c].selected!==e&&(a[c].selected=e),e&&d&&(a[c].defaultSelected=!0)}else{c=""+va(c);b=null;for(e=0;e<a.length;e++){if(a[e].value===c){a[e].selected=!0;d&&(a[e].defaultSelected=!0);return}null!==b||a[e].disabled||(b=a[e])}null!==b&&(b.selected=!0)}}function Gd(a,b){if(null!=b.dangerouslySetInnerHTML)throw Error(k(91));return M({},b,{value:void 0,defaultValue:void 0,children:""+a._wrapperState.initialValue})}
function Kf(a,b){var c=b.value;if(null==c){c=b.children;b=b.defaultValue;if(null!=c){if(null!=b)throw Error(k(92));if(Array.isArray(c)){if(!(1>=c.length))throw Error(k(93));c=c[0]}b=c}null==b&&(b="");c=b}a._wrapperState={initialValue:va(c)}}function Lf(a,b){var c=va(b.value),d=va(b.defaultValue);null!=c&&(c=""+c,c!==a.value&&(a.value=c),null==b.defaultValue&&a.defaultValue!==c&&(a.defaultValue=c));null!=d&&(a.defaultValue=""+d)}function Mf(a,b){b=a.textContent;b===a._wrapperState.initialValue&&""!==
b&&null!==b&&(a.value=b)}function Nf(a){switch(a){case "svg":return"http://www.w3.org/2000/svg";case "math":return"http://www.w3.org/1998/Math/MathML";default:return"http://www.w3.org/1999/xhtml"}}function Hd(a,b){return null==a||"http://www.w3.org/1999/xhtml"===a?Nf(b):"http://www.w3.org/2000/svg"===a&&"foreignObject"===b?"http://www.w3.org/1999/xhtml":a}function nc(a,b){var c={};c[a.toLowerCase()]=b.toLowerCase();c["Webkit"+a]="webkit"+b;c["Moz"+a]="moz"+b;return c}function oc(a){if(Id[a])return Id[a];
if(!ib[a])return a;var b=ib[a],c;for(c in b)if(b.hasOwnProperty(c)&&c in Of)return Id[a]=b[c];return a}function Jd(a){var b=Pf.get(a);void 0===b&&(b=new Map,Pf.set(a,b));return b}function Na(a){var b=a,c=a;if(a.alternate)for(;b.return;)b=b.return;else{a=b;do b=a,0!==(b.effectTag&1026)&&(c=b.return),a=b.return;while(a)}return 3===b.tag?c:null}function Qf(a){if(13===a.tag){var b=a.memoizedState;null===b&&(a=a.alternate,null!==a&&(b=a.memoizedState));if(null!==b)return b.dehydrated}return null}function Rf(a){if(Na(a)!==
a)throw Error(k(188));}function vi(a){var b=a.alternate;if(!b){b=Na(a);if(null===b)throw Error(k(188));return b!==a?null:a}for(var c=a,d=b;;){var e=c.return;if(null===e)break;var f=e.alternate;if(null===f){d=e.return;if(null!==d){c=d;continue}break}if(e.child===f.child){for(f=e.child;f;){if(f===c)return Rf(e),a;if(f===d)return Rf(e),b;f=f.sibling}throw Error(k(188));}if(c.return!==d.return)c=e,d=f;else{for(var g=!1,h=e.child;h;){if(h===c){g=!0;c=e;d=f;break}if(h===d){g=!0;d=e;c=f;break}h=h.sibling}if(!g){for(h=
f.child;h;){if(h===c){g=!0;c=f;d=e;break}if(h===d){g=!0;d=f;c=e;break}h=h.sibling}if(!g)throw Error(k(189));}}if(c.alternate!==d)throw Error(k(190));}if(3!==c.tag)throw Error(k(188));return c.stateNode.current===c?a:b}function Sf(a){a=vi(a);if(!a)return null;for(var b=a;;){if(5===b.tag||6===b.tag)return b;if(b.child)b.child.return=b,b=b.child;else{if(b===a)break;for(;!b.sibling;){if(!b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}}return null}function jb(a,b){if(null==
b)throw Error(k(30));if(null==a)return b;if(Array.isArray(a)){if(Array.isArray(b))return a.push.apply(a,b),a;a.push(b);return a}return Array.isArray(b)?[a].concat(b):[a,b]}function Kd(a,b,c){Array.isArray(a)?a.forEach(b,c):a&&b.call(c,a)}function pc(a){null!==a&&(Ab=jb(Ab,a));a=Ab;Ab=null;if(a){Kd(a,wi);if(Ab)throw Error(k(95));if(hc)throw a=pd,hc=!1,pd=null,a;}}function Ld(a){a=a.target||a.srcElement||window;a.correspondingUseElement&&(a=a.correspondingUseElement);return 3===a.nodeType?a.parentNode:
a}function Tf(a){if(!wa)return!1;a="on"+a;var b=a in document;b||(b=document.createElement("div"),b.setAttribute(a,"return;"),b="function"===typeof b[a]);return b}function Uf(a){a.topLevelType=null;a.nativeEvent=null;a.targetInst=null;a.ancestors.length=0;10>qc.length&&qc.push(a)}function Vf(a,b,c,d){if(qc.length){var e=qc.pop();e.topLevelType=a;e.eventSystemFlags=d;e.nativeEvent=b;e.targetInst=c;return e}return{topLevelType:a,eventSystemFlags:d,nativeEvent:b,targetInst:c,ancestors:[]}}function Wf(a){var b=
a.targetInst,c=b;do{if(!c){a.ancestors.push(c);break}var d=c;if(3===d.tag)d=d.stateNode.containerInfo;else{for(;d.return;)d=d.return;d=3!==d.tag?null:d.stateNode.containerInfo}if(!d)break;b=c.tag;5!==b&&6!==b||a.ancestors.push(c);c=Bb(d)}while(c);for(c=0;c<a.ancestors.length;c++){b=a.ancestors[c];var e=Ld(a.nativeEvent);d=a.topLevelType;var f=a.nativeEvent,g=a.eventSystemFlags;0===c&&(g|=64);for(var h=null,m=0;m<jc.length;m++){var n=jc[m];n&&(n=n.extractEvents(d,b,f,e,g))&&(h=jb(h,n))}pc(h)}}function Md(a,
b,c){if(!c.has(a)){switch(a){case "scroll":Cb(b,"scroll",!0);break;case "focus":case "blur":Cb(b,"focus",!0);Cb(b,"blur",!0);c.set("blur",null);c.set("focus",null);break;case "cancel":case "close":Tf(a)&&Cb(b,a,!0);break;case "invalid":case "submit":case "reset":break;default:-1===Db.indexOf(a)&&w(a,b)}c.set(a,null)}}function xi(a,b){var c=Jd(b);Nd.forEach(function(a){Md(a,b,c)});yi.forEach(function(a){Md(a,b,c)})}function Od(a,b,c,d,e){return{blockedOn:a,topLevelType:b,eventSystemFlags:c|32,nativeEvent:e,
container:d}}function Xf(a,b){switch(a){case "focus":case "blur":xa=null;break;case "dragenter":case "dragleave":ya=null;break;case "mouseover":case "mouseout":za=null;break;case "pointerover":case "pointerout":Eb.delete(b.pointerId);break;case "gotpointercapture":case "lostpointercapture":Fb.delete(b.pointerId)}}function Gb(a,b,c,d,e,f){if(null===a||a.nativeEvent!==f)return a=Od(b,c,d,e,f),null!==b&&(b=Hb(b),null!==b&&Yf(b)),a;a.eventSystemFlags|=d;return a}function zi(a,b,c,d,e){switch(b){case "focus":return xa=
Gb(xa,a,b,c,d,e),!0;case "dragenter":return ya=Gb(ya,a,b,c,d,e),!0;case "mouseover":return za=Gb(za,a,b,c,d,e),!0;case "pointerover":var f=e.pointerId;Eb.set(f,Gb(Eb.get(f)||null,a,b,c,d,e));return!0;case "gotpointercapture":return f=e.pointerId,Fb.set(f,Gb(Fb.get(f)||null,a,b,c,d,e)),!0}return!1}function Ai(a){var b=Bb(a.target);if(null!==b){var c=Na(b);if(null!==c)if(b=c.tag,13===b){if(b=Qf(c),null!==b){a.blockedOn=b;Pd(a.priority,function(){Bi(c)});return}}else if(3===b&&c.stateNode.hydrate){a.blockedOn=
3===c.tag?c.stateNode.containerInfo:null;return}}a.blockedOn=null}function rc(a){if(null!==a.blockedOn)return!1;var b=Qd(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);if(null!==b){var c=Hb(b);null!==c&&Yf(c);a.blockedOn=b;return!1}return!0}function Zf(a,b,c){rc(a)&&c.delete(b)}function Ci(){for(Rd=!1;0<fa.length;){var a=fa[0];if(null!==a.blockedOn){a=Hb(a.blockedOn);null!==a&&Di(a);break}var b=Qd(a.topLevelType,a.eventSystemFlags,a.container,a.nativeEvent);null!==b?a.blockedOn=b:fa.shift()}null!==
xa&&rc(xa)&&(xa=null);null!==ya&&rc(ya)&&(ya=null);null!==za&&rc(za)&&(za=null);Eb.forEach(Zf);Fb.forEach(Zf)}function Ib(a,b){a.blockedOn===b&&(a.blockedOn=null,Rd||(Rd=!0,$f(ag,Ci)))}function bg(a){if(0<fa.length){Ib(fa[0],a);for(var b=1;b<fa.length;b++){var c=fa[b];c.blockedOn===a&&(c.blockedOn=null)}}null!==xa&&Ib(xa,a);null!==ya&&Ib(ya,a);null!==za&&Ib(za,a);b=function(b){return Ib(b,a)};Eb.forEach(b);Fb.forEach(b);for(b=0;b<Jb.length;b++)c=Jb[b],c.blockedOn===a&&(c.blockedOn=null);for(;0<Jb.length&&
(b=Jb[0],null===b.blockedOn);)Ai(b),null===b.blockedOn&&Jb.shift()}function Sd(a,b){for(var c=0;c<a.length;c+=2){var d=a[c],e=a[c+1],f="on"+(e[0].toUpperCase()+e.slice(1));f={phasedRegistrationNames:{bubbled:f,captured:f+"Capture"},dependencies:[d],eventPriority:b};Td.set(d,b);cg.set(d,f);dg[e]=f}}function w(a,b){Cb(b,a,!1)}function Cb(a,b,c){var d=Td.get(b);switch(void 0===d?2:d){case 0:d=Ei.bind(null,b,1,a);break;case 1:d=Fi.bind(null,b,1,a);break;default:d=sc.bind(null,b,1,a)}c?a.addEventListener(b,
d,!0):a.addEventListener(b,d,!1)}function Ei(a,b,c,d){Oa||vd();var e=sc,f=Oa;Oa=!0;try{eg(e,a,b,c,d)}finally{(Oa=f)||ud()}}function Fi(a,b,c,d){Gi(Hi,sc.bind(null,a,b,c,d))}function sc(a,b,c,d){if(tc)if(0<fa.length&&-1<Nd.indexOf(a))a=Od(null,a,b,c,d),fa.push(a);else{var e=Qd(a,b,c,d);if(null===e)Xf(a,d);else if(-1<Nd.indexOf(a))a=Od(e,a,b,c,d),fa.push(a);else if(!zi(e,a,b,c,d)){Xf(a,d);a=Vf(a,d,null,b);try{uf(Wf,a)}finally{Uf(a)}}}}function Qd(a,b,c,d){c=Ld(d);c=Bb(c);if(null!==c){var e=Na(c);if(null===
e)c=null;else{var f=e.tag;if(13===f){c=Qf(e);if(null!==c)return c;c=null}else if(3===f){if(e.stateNode.hydrate)return 3===e.tag?e.stateNode.containerInfo:null;c=null}else e!==c&&(c=null)}}a=Vf(a,d,c,b);try{uf(Wf,a)}finally{Uf(a)}return null}function fg(a,b,c){return null==b||"boolean"===typeof b||""===b?"":c||"number"!==typeof b||0===b||Kb.hasOwnProperty(a)&&Kb[a]?(""+b).trim():b+"px"}function gg(a,b){a=a.style;for(var c in b)if(b.hasOwnProperty(c)){var d=0===c.indexOf("--"),e=fg(c,b[c],d);"float"===
c&&(c="cssFloat");d?a.setProperty(c,e):a[c]=e}}function Ud(a,b){if(b){if(Ii[a]&&(null!=b.children||null!=b.dangerouslySetInnerHTML))throw Error(k(137,a,""));if(null!=b.dangerouslySetInnerHTML){if(null!=b.children)throw Error(k(60));if(!("object"===typeof b.dangerouslySetInnerHTML&&"__html"in b.dangerouslySetInnerHTML))throw Error(k(61));}if(null!=b.style&&"object"!==typeof b.style)throw Error(k(62,""));}}function Vd(a,b){if(-1===a.indexOf("-"))return"string"===typeof b.is;switch(a){case "annotation-xml":case "color-profile":case "font-face":case "font-face-src":case "font-face-uri":case "font-face-format":case "font-face-name":case "missing-glyph":return!1;
default:return!0}}function oa(a,b){a=9===a.nodeType||11===a.nodeType?a:a.ownerDocument;var c=Jd(a);b=rd[b];for(var d=0;d<b.length;d++)Md(b[d],a,c)}function uc(){}function Wd(a){a=a||("undefined"!==typeof document?document:void 0);if("undefined"===typeof a)return null;try{return a.activeElement||a.body}catch(b){return a.body}}function hg(a){for(;a&&a.firstChild;)a=a.firstChild;return a}function ig(a,b){var c=hg(a);a=0;for(var d;c;){if(3===c.nodeType){d=a+c.textContent.length;if(a<=b&&d>=b)return{node:c,
offset:b-a};a=d}a:{for(;c;){if(c.nextSibling){c=c.nextSibling;break a}c=c.parentNode}c=void 0}c=hg(c)}}function jg(a,b){return a&&b?a===b?!0:a&&3===a.nodeType?!1:b&&3===b.nodeType?jg(a,b.parentNode):"contains"in a?a.contains(b):a.compareDocumentPosition?!!(a.compareDocumentPosition(b)&16):!1:!1}function kg(){for(var a=window,b=Wd();b instanceof a.HTMLIFrameElement;){try{var c="string"===typeof b.contentWindow.location.href}catch(d){c=!1}if(c)a=b.contentWindow;else break;b=Wd(a.document)}return b}
function Xd(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return b&&("input"===b&&("text"===a.type||"search"===a.type||"tel"===a.type||"url"===a.type||"password"===a.type)||"textarea"===b||"true"===a.contentEditable)}function lg(a,b){switch(a){case "button":case "input":case "select":case "textarea":return!!b.autoFocus}return!1}function Yd(a,b){return"textarea"===a||"option"===a||"noscript"===a||"string"===typeof b.children||"number"===typeof b.children||"object"===typeof b.dangerouslySetInnerHTML&&
null!==b.dangerouslySetInnerHTML&&null!=b.dangerouslySetInnerHTML.__html}function kb(a){for(;null!=a;a=a.nextSibling){var b=a.nodeType;if(1===b||3===b)break}return a}function mg(a){a=a.previousSibling;for(var b=0;a;){if(8===a.nodeType){var c=a.data;if(c===ng||c===Zd||c===$d){if(0===b)return a;b--}else c===og&&b++}a=a.previousSibling}return null}function Bb(a){var b=a[Aa];if(b)return b;for(var c=a.parentNode;c;){if(b=c[Lb]||c[Aa]){c=b.alternate;if(null!==b.child||null!==c&&null!==c.child)for(a=mg(a);null!==
a;){if(c=a[Aa])return c;a=mg(a)}return b}a=c;c=a.parentNode}return null}function Hb(a){a=a[Aa]||a[Lb];return!a||5!==a.tag&&6!==a.tag&&13!==a.tag&&3!==a.tag?null:a}function Pa(a){if(5===a.tag||6===a.tag)return a.stateNode;throw Error(k(33));}function ae(a){return a[vc]||null}function pa(a){do a=a.return;while(a&&5!==a.tag);return a?a:null}function pg(a,b){var c=a.stateNode;if(!c)return null;var d=td(c);if(!d)return null;c=d[b];a:switch(b){case "onClick":case "onClickCapture":case "onDoubleClick":case "onDoubleClickCapture":case "onMouseDown":case "onMouseDownCapture":case "onMouseMove":case "onMouseMoveCapture":case "onMouseUp":case "onMouseUpCapture":case "onMouseEnter":(d=
!d.disabled)||(a=a.type,d=!("button"===a||"input"===a||"select"===a||"textarea"===a));a=!d;break a;default:a=!1}if(a)return null;if(c&&"function"!==typeof c)throw Error(k(231,b,typeof c));return c}function qg(a,b,c){if(b=pg(a,c.dispatchConfig.phasedRegistrationNames[b]))c._dispatchListeners=jb(c._dispatchListeners,b),c._dispatchInstances=jb(c._dispatchInstances,a)}function Ji(a){if(a&&a.dispatchConfig.phasedRegistrationNames){for(var b=a._targetInst,c=[];b;)c.push(b),b=pa(b);for(b=c.length;0<b--;)qg(c[b],
"captured",a);for(b=0;b<c.length;b++)qg(c[b],"bubbled",a)}}function be(a,b,c){a&&c&&c.dispatchConfig.registrationName&&(b=pg(a,c.dispatchConfig.registrationName))&&(c._dispatchListeners=jb(c._dispatchListeners,b),c._dispatchInstances=jb(c._dispatchInstances,a))}function Ki(a){a&&a.dispatchConfig.registrationName&&be(a._targetInst,null,a)}function lb(a){Kd(a,Ji)}function rg(){if(wc)return wc;var a,b=ce,c=b.length,d,e="value"in Ba?Ba.value:Ba.textContent,f=e.length;for(a=0;a<c&&b[a]===e[a];a++);var g=
c-a;for(d=1;d<=g&&b[c-d]===e[f-d];d++);return wc=e.slice(a,1<d?1-d:void 0)}function xc(){return!0}function yc(){return!1}function R(a,b,c,d){this.dispatchConfig=a;this._targetInst=b;this.nativeEvent=c;a=this.constructor.Interface;for(var e in a)a.hasOwnProperty(e)&&((b=a[e])?this[e]=b(c):"target"===e?this.target=d:this[e]=c[e]);this.isDefaultPrevented=(null!=c.defaultPrevented?c.defaultPrevented:!1===c.returnValue)?xc:yc;this.isPropagationStopped=yc;return this}function Li(a,b,c,d){if(this.eventPool.length){var e=
this.eventPool.pop();this.call(e,a,b,c,d);return e}return new this(a,b,c,d)}function Mi(a){if(!(a instanceof this))throw Error(k(279));a.destructor();10>this.eventPool.length&&this.eventPool.push(a)}function sg(a){a.eventPool=[];a.getPooled=Li;a.release=Mi}function tg(a,b){switch(a){case "keyup":return-1!==Ni.indexOf(b.keyCode);case "keydown":return 229!==b.keyCode;case "keypress":case "mousedown":case "blur":return!0;default:return!1}}function ug(a){a=a.detail;return"object"===typeof a&&"data"in
a?a.data:null}function Oi(a,b){switch(a){case "compositionend":return ug(b);case "keypress":if(32!==b.which)return null;vg=!0;return wg;case "textInput":return a=b.data,a===wg&&vg?null:a;default:return null}}function Pi(a,b){if(mb)return"compositionend"===a||!de&&tg(a,b)?(a=rg(),wc=ce=Ba=null,mb=!1,a):null;switch(a){case "paste":return null;case "keypress":if(!(b.ctrlKey||b.altKey||b.metaKey)||b.ctrlKey&&b.altKey){if(b.char&&1<b.char.length)return b.char;if(b.which)return String.fromCharCode(b.which)}return null;
case "compositionend":return xg&&"ko"!==b.locale?null:b.data;default:return null}}function yg(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return"input"===b?!!Qi[a.type]:"textarea"===b?!0:!1}function zg(a,b,c){a=R.getPooled(Ag.change,a,b,c);a.type="change";sf(c);lb(a);return a}function Ri(a){pc(a)}function zc(a){var b=Pa(a);if(Gf(b))return a}function Si(a,b){if("change"===a)return b}function Bg(){Mb&&(Mb.detachEvent("onpropertychange",Cg),Nb=Mb=null)}function Cg(a){if("value"===a.propertyName&&
zc(Nb))if(a=zg(Nb,a,Ld(a)),Oa)pc(a);else{Oa=!0;try{ee(Ri,a)}finally{Oa=!1,ud()}}}function Ti(a,b,c){"focus"===a?(Bg(),Mb=b,Nb=c,Mb.attachEvent("onpropertychange",Cg)):"blur"===a&&Bg()}function Ui(a,b){if("selectionchange"===a||"keyup"===a||"keydown"===a)return zc(Nb)}function Vi(a,b){if("click"===a)return zc(b)}function Wi(a,b){if("input"===a||"change"===a)return zc(b)}function Xi(a){var b=this.nativeEvent;return b.getModifierState?b.getModifierState(a):(a=Yi[a])?!!b[a]:!1}function fe(a){return Xi}
function Zi(a,b){return a===b&&(0!==a||1/a===1/b)||a!==a&&b!==b}function Ob(a,b){if(Qa(a,b))return!0;if("object"!==typeof a||null===a||"object"!==typeof b||null===b)return!1;var c=Object.keys(a),d=Object.keys(b);if(c.length!==d.length)return!1;for(d=0;d<c.length;d++)if(!$i.call(b,c[d])||!Qa(a[c[d]],b[c[d]]))return!1;return!0}function Dg(a,b){var c=b.window===b?b.document:9===b.nodeType?b:b.ownerDocument;if(ge||null==nb||nb!==Wd(c))return null;c=nb;"selectionStart"in c&&Xd(c)?c={start:c.selectionStart,
end:c.selectionEnd}:(c=(c.ownerDocument&&c.ownerDocument.defaultView||window).getSelection(),c={anchorNode:c.anchorNode,anchorOffset:c.anchorOffset,focusNode:c.focusNode,focusOffset:c.focusOffset});return Pb&&Ob(Pb,c)?null:(Pb=c,a=R.getPooled(Eg.select,he,a,b),a.type="select",a.target=nb,lb(a),a)}function Ac(a){var b=a.keyCode;"charCode"in a?(a=a.charCode,0===a&&13===b&&(a=13)):a=b;10===a&&(a=13);return 32<=a||13===a?a:0}function q(a,b){0>ob||(a.current=ie[ob],ie[ob]=null,ob--)}function y(a,b,c){ob++;
ie[ob]=a.current;a.current=b}function pb(a,b){var c=a.type.contextTypes;if(!c)return Ca;var d=a.stateNode;if(d&&d.__reactInternalMemoizedUnmaskedChildContext===b)return d.__reactInternalMemoizedMaskedChildContext;var e={},f;for(f in c)e[f]=b[f];d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=b,a.__reactInternalMemoizedMaskedChildContext=e);return e}function N(a){a=a.childContextTypes;return null!==a&&void 0!==a}function Fg(a,b,c){if(B.current!==Ca)throw Error(k(168));y(B,b);y(G,c)}
function Gg(a,b,c){var d=a.stateNode;a=b.childContextTypes;if("function"!==typeof d.getChildContext)return c;d=d.getChildContext();for(var e in d)if(!(e in a))throw Error(k(108,na(b)||"Unknown",e));return M({},c,{},d)}function Bc(a){a=(a=a.stateNode)&&a.__reactInternalMemoizedMergedChildContext||Ca;Ra=B.current;y(B,a);y(G,G.current);return!0}function Hg(a,b,c){var d=a.stateNode;if(!d)throw Error(k(169));c?(a=Gg(a,b,Ra),d.__reactInternalMemoizedMergedChildContext=a,q(G),q(B),y(B,a)):q(G);y(G,c)}function Cc(){switch(aj()){case Dc:return 99;
case Ig:return 98;case Jg:return 97;case Kg:return 96;case Lg:return 95;default:throw Error(k(332));}}function Mg(a){switch(a){case 99:return Dc;case 98:return Ig;case 97:return Jg;case 96:return Kg;case 95:return Lg;default:throw Error(k(332));}}function Da(a,b){a=Mg(a);return bj(a,b)}function Ng(a,b,c){a=Mg(a);return je(a,b,c)}function Og(a){null===qa?(qa=[a],Ec=je(Dc,Pg)):qa.push(a);return Qg}function ha(){if(null!==Ec){var a=Ec;Ec=null;Rg(a)}Pg()}function Pg(){if(!ke&&null!==qa){ke=!0;var a=0;
try{var b=qa;Da(99,function(){for(;a<b.length;a++){var c=b[a];do c=c(!0);while(null!==c)}});qa=null}catch(c){throw null!==qa&&(qa=qa.slice(a+1)),je(Dc,ha),c;}finally{ke=!1}}}function Fc(a,b,c){c/=10;return 1073741821-(((1073741821-a+b/10)/c|0)+1)*c}function aa(a,b){if(a&&a.defaultProps){b=M({},b);a=a.defaultProps;for(var c in a)void 0===b[c]&&(b[c]=a[c])}return b}function le(){Gc=qb=Hc=null}function me(a){var b=Ic.current;q(Ic);a.type._context._currentValue=b}function Sg(a,b){for(;null!==a;){var c=
a.alternate;if(a.childExpirationTime<b)a.childExpirationTime=b,null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);else if(null!==c&&c.childExpirationTime<b)c.childExpirationTime=b;else break;a=a.return}}function rb(a,b){Hc=a;Gc=qb=null;a=a.dependencies;null!==a&&null!==a.firstContext&&(a.expirationTime>=b&&(ia=!0),a.firstContext=null)}function W(a,b){if(Gc!==a&&!1!==b&&0!==b){if("number"!==typeof b||1073741823===b)Gc=a,b=1073741823;b={context:a,observedBits:b,next:null};if(null===qb){if(null===
Hc)throw Error(k(308));qb=b;Hc.dependencies={expirationTime:0,firstContext:b,responders:null}}else qb=qb.next=b}return a._currentValue}function ne(a){a.updateQueue={baseState:a.memoizedState,baseQueue:null,shared:{pending:null},effects:null}}function oe(a,b){a=a.updateQueue;b.updateQueue===a&&(b.updateQueue={baseState:a.baseState,baseQueue:a.baseQueue,shared:a.shared,effects:a.effects})}function Ea(a,b){a={expirationTime:a,suspenseConfig:b,tag:Tg,payload:null,callback:null,next:null};return a.next=
a}function Fa(a,b){a=a.updateQueue;if(null!==a){a=a.shared;var c=a.pending;null===c?b.next=b:(b.next=c.next,c.next=b);a.pending=b}}function Ug(a,b){var c=a.alternate;null!==c&&oe(c,a);a=a.updateQueue;c=a.baseQueue;null===c?(a.baseQueue=b.next=b,b.next=b):(b.next=c.next,c.next=b)}function Qb(a,b,c,d){var e=a.updateQueue;Ga=!1;var f=e.baseQueue,g=e.shared.pending;if(null!==g){if(null!==f){var h=f.next;f.next=g.next;g.next=h}f=g;e.shared.pending=null;h=a.alternate;null!==h&&(h=h.updateQueue,null!==h&&
(h.baseQueue=g))}if(null!==f){h=f.next;var m=e.baseState,n=0,k=null,ba=null,l=null;if(null!==h){var p=h;do{g=p.expirationTime;if(g<d){var t={expirationTime:p.expirationTime,suspenseConfig:p.suspenseConfig,tag:p.tag,payload:p.payload,callback:p.callback,next:null};null===l?(ba=l=t,k=m):l=l.next=t;g>n&&(n=g)}else{null!==l&&(l=l.next={expirationTime:1073741823,suspenseConfig:p.suspenseConfig,tag:p.tag,payload:p.payload,callback:p.callback,next:null});Vg(g,p.suspenseConfig);a:{var q=a,r=p;g=b;t=c;switch(r.tag){case 1:q=
r.payload;if("function"===typeof q){m=q.call(t,m,g);break a}m=q;break a;case 3:q.effectTag=q.effectTag&-4097|64;case Tg:q=r.payload;g="function"===typeof q?q.call(t,m,g):q;if(null===g||void 0===g)break a;m=M({},m,g);break a;case Jc:Ga=!0}}null!==p.callback&&(a.effectTag|=32,g=e.effects,null===g?e.effects=[p]:g.push(p))}p=p.next;if(null===p||p===h)if(g=e.shared.pending,null===g)break;else p=f.next=g.next,g.next=h,e.baseQueue=f=g,e.shared.pending=null}while(1)}null===l?k=m:l.next=ba;e.baseState=k;e.baseQueue=
l;Kc(n);a.expirationTime=n;a.memoizedState=m}}function Wg(a,b,c){a=b.effects;b.effects=null;if(null!==a)for(b=0;b<a.length;b++){var d=a[b],e=d.callback;if(null!==e){d.callback=null;d=e;e=c;if("function"!==typeof d)throw Error(k(191,d));d.call(e)}}}function Lc(a,b,c,d){b=a.memoizedState;c=c(d,b);c=null===c||void 0===c?b:M({},b,c);a.memoizedState=c;0===a.expirationTime&&(a.updateQueue.baseState=c)}function Xg(a,b,c,d,e,f,g){a=a.stateNode;return"function"===typeof a.shouldComponentUpdate?a.shouldComponentUpdate(d,
f,g):b.prototype&&b.prototype.isPureReactComponent?!Ob(c,d)||!Ob(e,f):!0}function Yg(a,b,c){var d=!1,e=Ca;var f=b.contextType;"object"===typeof f&&null!==f?f=W(f):(e=N(b)?Ra:B.current,d=b.contextTypes,f=(d=null!==d&&void 0!==d)?pb(a,e):Ca);b=new b(c,f);a.memoizedState=null!==b.state&&void 0!==b.state?b.state:null;b.updater=Mc;a.stateNode=b;b._reactInternalFiber=a;d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=e,a.__reactInternalMemoizedMaskedChildContext=f);return b}function Zg(a,
b,c,d){a=b.state;"function"===typeof b.componentWillReceiveProps&&b.componentWillReceiveProps(c,d);"function"===typeof b.UNSAFE_componentWillReceiveProps&&b.UNSAFE_componentWillReceiveProps(c,d);b.state!==a&&Mc.enqueueReplaceState(b,b.state,null)}function pe(a,b,c,d){var e=a.stateNode;e.props=c;e.state=a.memoizedState;e.refs=$g;ne(a);var f=b.contextType;"object"===typeof f&&null!==f?e.context=W(f):(f=N(b)?Ra:B.current,e.context=pb(a,f));Qb(a,c,e,d);e.state=a.memoizedState;f=b.getDerivedStateFromProps;
"function"===typeof f&&(Lc(a,b,f,c),e.state=a.memoizedState);"function"===typeof b.getDerivedStateFromProps||"function"===typeof e.getSnapshotBeforeUpdate||"function"!==typeof e.UNSAFE_componentWillMount&&"function"!==typeof e.componentWillMount||(b=e.state,"function"===typeof e.componentWillMount&&e.componentWillMount(),"function"===typeof e.UNSAFE_componentWillMount&&e.UNSAFE_componentWillMount(),b!==e.state&&Mc.enqueueReplaceState(e,e.state,null),Qb(a,c,e,d),e.state=a.memoizedState);"function"===
typeof e.componentDidMount&&(a.effectTag|=4)}function Rb(a,b,c){a=c.ref;if(null!==a&&"function"!==typeof a&&"object"!==typeof a){if(c._owner){c=c._owner;if(c){if(1!==c.tag)throw Error(k(309));var d=c.stateNode}if(!d)throw Error(k(147,a));var e=""+a;if(null!==b&&null!==b.ref&&"function"===typeof b.ref&&b.ref._stringRef===e)return b.ref;b=function(a){var b=d.refs;b===$g&&(b=d.refs={});null===a?delete b[e]:b[e]=a};b._stringRef=e;return b}if("string"!==typeof a)throw Error(k(284));if(!c._owner)throw Error(k(290,
a));}return a}function Nc(a,b){if("textarea"!==a.type)throw Error(k(31,"[object Object]"===Object.prototype.toString.call(b)?"object with keys {"+Object.keys(b).join(", ")+"}":b,""));}function ah(a){function b(b,c){if(a){var d=b.lastEffect;null!==d?(d.nextEffect=c,b.lastEffect=c):b.firstEffect=b.lastEffect=c;c.nextEffect=null;c.effectTag=8}}function c(c,d){if(!a)return null;for(;null!==d;)b(c,d),d=d.sibling;return null}function d(a,b){for(a=new Map;null!==b;)null!==b.key?a.set(b.key,b):a.set(b.index,
b),b=b.sibling;return a}function e(a,b){a=Sa(a,b);a.index=0;a.sibling=null;return a}function f(b,c,d){b.index=d;if(!a)return c;d=b.alternate;if(null!==d)return d=d.index,d<c?(b.effectTag=2,c):d;b.effectTag=2;return c}function g(b){a&&null===b.alternate&&(b.effectTag=2);return b}function h(a,b,c,d){if(null===b||6!==b.tag)return b=qe(c,a.mode,d),b.return=a,b;b=e(b,c);b.return=a;return b}function m(a,b,c,d){if(null!==b&&b.elementType===c.type)return d=e(b,c.props),d.ref=Rb(a,b,c),d.return=a,d;d=Oc(c.type,
c.key,c.props,null,a.mode,d);d.ref=Rb(a,b,c);d.return=a;return d}function n(a,b,c,d){if(null===b||4!==b.tag||b.stateNode.containerInfo!==c.containerInfo||b.stateNode.implementation!==c.implementation)return b=re(c,a.mode,d),b.return=a,b;b=e(b,c.children||[]);b.return=a;return b}function l(a,b,c,d,f){if(null===b||7!==b.tag)return b=Ha(c,a.mode,d,f),b.return=a,b;b=e(b,c);b.return=a;return b}function ba(a,b,c){if("string"===typeof b||"number"===typeof b)return b=qe(""+b,a.mode,c),b.return=a,b;if("object"===
typeof b&&null!==b){switch(b.$$typeof){case Pc:return c=Oc(b.type,b.key,b.props,null,a.mode,c),c.ref=Rb(a,null,b),c.return=a,c;case gb:return b=re(b,a.mode,c),b.return=a,b}if(Qc(b)||zb(b))return b=Ha(b,a.mode,c,null),b.return=a,b;Nc(a,b)}return null}function p(a,b,c,d){var e=null!==b?b.key:null;if("string"===typeof c||"number"===typeof c)return null!==e?null:h(a,b,""+c,d);if("object"===typeof c&&null!==c){switch(c.$$typeof){case Pc:return c.key===e?c.type===Ma?l(a,b,c.props.children,d,e):m(a,b,c,
d):null;case gb:return c.key===e?n(a,b,c,d):null}if(Qc(c)||zb(c))return null!==e?null:l(a,b,c,d,null);Nc(a,c)}return null}function t(a,b,c,d,e){if("string"===typeof d||"number"===typeof d)return a=a.get(c)||null,h(b,a,""+d,e);if("object"===typeof d&&null!==d){switch(d.$$typeof){case Pc:return a=a.get(null===d.key?c:d.key)||null,d.type===Ma?l(b,a,d.props.children,e,d.key):m(b,a,d,e);case gb:return a=a.get(null===d.key?c:d.key)||null,n(b,a,d,e)}if(Qc(d)||zb(d))return a=a.get(c)||null,l(b,a,d,e,null);
Nc(b,d)}return null}function q(e,g,h,m){for(var n=null,k=null,l=g,r=g=0,C=null;null!==l&&r<h.length;r++){l.index>r?(C=l,l=null):C=l.sibling;var O=p(e,l,h[r],m);if(null===O){null===l&&(l=C);break}a&&l&&null===O.alternate&&b(e,l);g=f(O,g,r);null===k?n=O:k.sibling=O;k=O;l=C}if(r===h.length)return c(e,l),n;if(null===l){for(;r<h.length;r++)l=ba(e,h[r],m),null!==l&&(g=f(l,g,r),null===k?n=l:k.sibling=l,k=l);return n}for(l=d(e,l);r<h.length;r++)C=t(l,e,r,h[r],m),null!==C&&(a&&null!==C.alternate&&l.delete(null===
C.key?r:C.key),g=f(C,g,r),null===k?n=C:k.sibling=C,k=C);a&&l.forEach(function(a){return b(e,a)});return n}function w(e,g,h,n){var m=zb(h);if("function"!==typeof m)throw Error(k(150));h=m.call(h);if(null==h)throw Error(k(151));for(var l=m=null,r=g,C=g=0,O=null,v=h.next();null!==r&&!v.done;C++,v=h.next()){r.index>C?(O=r,r=null):O=r.sibling;var q=p(e,r,v.value,n);if(null===q){null===r&&(r=O);break}a&&r&&null===q.alternate&&b(e,r);g=f(q,g,C);null===l?m=q:l.sibling=q;l=q;r=O}if(v.done)return c(e,r),m;
if(null===r){for(;!v.done;C++,v=h.next())v=ba(e,v.value,n),null!==v&&(g=f(v,g,C),null===l?m=v:l.sibling=v,l=v);return m}for(r=d(e,r);!v.done;C++,v=h.next())v=t(r,e,C,v.value,n),null!==v&&(a&&null!==v.alternate&&r.delete(null===v.key?C:v.key),g=f(v,g,C),null===l?m=v:l.sibling=v,l=v);a&&r.forEach(function(a){return b(e,a)});return m}return function(a,d,f,h){var m="object"===typeof f&&null!==f&&f.type===Ma&&null===f.key;m&&(f=f.props.children);var n="object"===typeof f&&null!==f;if(n)switch(f.$$typeof){case Pc:a:{n=
f.key;for(m=d;null!==m;){if(m.key===n){switch(m.tag){case 7:if(f.type===Ma){c(a,m.sibling);d=e(m,f.props.children);d.return=a;a=d;break a}break;default:if(m.elementType===f.type){c(a,m.sibling);d=e(m,f.props);d.ref=Rb(a,m,f);d.return=a;a=d;break a}}c(a,m);break}else b(a,m);m=m.sibling}f.type===Ma?(d=Ha(f.props.children,a.mode,h,f.key),d.return=a,a=d):(h=Oc(f.type,f.key,f.props,null,a.mode,h),h.ref=Rb(a,d,f),h.return=a,a=h)}return g(a);case gb:a:{for(m=f.key;null!==d;){if(d.key===m)if(4===d.tag&&d.stateNode.containerInfo===
f.containerInfo&&d.stateNode.implementation===f.implementation){c(a,d.sibling);d=e(d,f.children||[]);d.return=a;a=d;break a}else{c(a,d);break}else b(a,d);d=d.sibling}d=re(f,a.mode,h);d.return=a;a=d}return g(a)}if("string"===typeof f||"number"===typeof f)return f=""+f,null!==d&&6===d.tag?(c(a,d.sibling),d=e(d,f),d.return=a,a=d):(c(a,d),d=qe(f,a.mode,h),d.return=a,a=d),g(a);if(Qc(f))return q(a,d,f,h);if(zb(f))return w(a,d,f,h);n&&Nc(a,f);if("undefined"===typeof f&&!m)switch(a.tag){case 1:case 0:throw a=
a.type,Error(k(152,a.displayName||a.name||"Component"));}return c(a,d)}}function Ta(a){if(a===Sb)throw Error(k(174));return a}function se(a,b){y(Tb,b);y(Ub,a);y(ja,Sb);a=b.nodeType;switch(a){case 9:case 11:b=(b=b.documentElement)?b.namespaceURI:Hd(null,"");break;default:a=8===a?b.parentNode:b,b=a.namespaceURI||null,a=a.tagName,b=Hd(b,a)}q(ja);y(ja,b)}function tb(a){q(ja);q(Ub);q(Tb)}function bh(a){Ta(Tb.current);var b=Ta(ja.current);var c=Hd(b,a.type);b!==c&&(y(Ub,a),y(ja,c))}function te(a){Ub.current===
a&&(q(ja),q(Ub))}function Rc(a){for(var b=a;null!==b;){if(13===b.tag){var c=b.memoizedState;if(null!==c&&(c=c.dehydrated,null===c||c.data===$d||c.data===Zd))return b}else if(19===b.tag&&void 0!==b.memoizedProps.revealOrder){if(0!==(b.effectTag&64))return b}else if(null!==b.child){b.child.return=b;b=b.child;continue}if(b===a)break;for(;null===b.sibling;){if(null===b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}return null}function ue(a,b){return{responder:a,props:b}}
function S(){throw Error(k(321));}function ve(a,b){if(null===b)return!1;for(var c=0;c<b.length&&c<a.length;c++)if(!Qa(a[c],b[c]))return!1;return!0}function we(a,b,c,d,e,f){Ia=f;z=b;b.memoizedState=null;b.updateQueue=null;b.expirationTime=0;Sc.current=null===a||null===a.memoizedState?dj:ej;a=c(d,e);if(b.expirationTime===Ia){f=0;do{b.expirationTime=0;if(!(25>f))throw Error(k(301));f+=1;J=K=null;b.updateQueue=null;Sc.current=fj;a=c(d,e)}while(b.expirationTime===Ia)}Sc.current=Tc;b=null!==K&&null!==K.next;
Ia=0;J=K=z=null;Uc=!1;if(b)throw Error(k(300));return a}function ub(){var a={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};null===J?z.memoizedState=J=a:J=J.next=a;return J}function vb(){if(null===K){var a=z.alternate;a=null!==a?a.memoizedState:null}else a=K.next;var b=null===J?z.memoizedState:J.next;if(null!==b)J=b,K=a;else{if(null===a)throw Error(k(310));K=a;a={memoizedState:K.memoizedState,baseState:K.baseState,baseQueue:K.baseQueue,queue:K.queue,next:null};null===J?z.memoizedState=
J=a:J=J.next=a}return J}function Ua(a,b){return"function"===typeof b?b(a):b}function Vc(a,b,c){b=vb();c=b.queue;if(null===c)throw Error(k(311));c.lastRenderedReducer=a;var d=K,e=d.baseQueue,f=c.pending;if(null!==f){if(null!==e){var g=e.next;e.next=f.next;f.next=g}d.baseQueue=e=f;c.pending=null}if(null!==e){e=e.next;d=d.baseState;var h=g=f=null,m=e;do{var n=m.expirationTime;if(n<Ia){var l={expirationTime:m.expirationTime,suspenseConfig:m.suspenseConfig,action:m.action,eagerReducer:m.eagerReducer,eagerState:m.eagerState,
next:null};null===h?(g=h=l,f=d):h=h.next=l;n>z.expirationTime&&(z.expirationTime=n,Kc(n))}else null!==h&&(h=h.next={expirationTime:1073741823,suspenseConfig:m.suspenseConfig,action:m.action,eagerReducer:m.eagerReducer,eagerState:m.eagerState,next:null}),Vg(n,m.suspenseConfig),d=m.eagerReducer===a?m.eagerState:a(d,m.action);m=m.next}while(null!==m&&m!==e);null===h?f=d:h.next=g;Qa(d,b.memoizedState)||(ia=!0);b.memoizedState=d;b.baseState=f;b.baseQueue=h;c.lastRenderedState=d}return[b.memoizedState,
c.dispatch]}function Wc(a,b,c){b=vb();c=b.queue;if(null===c)throw Error(k(311));c.lastRenderedReducer=a;var d=c.dispatch,e=c.pending,f=b.memoizedState;if(null!==e){c.pending=null;var g=e=e.next;do f=a(f,g.action),g=g.next;while(g!==e);Qa(f,b.memoizedState)||(ia=!0);b.memoizedState=f;null===b.baseQueue&&(b.baseState=f);c.lastRenderedState=f}return[f,d]}function xe(a){var b=ub();"function"===typeof a&&(a=a());b.memoizedState=b.baseState=a;a=b.queue={pending:null,dispatch:null,lastRenderedReducer:Ua,
lastRenderedState:a};a=a.dispatch=ch.bind(null,z,a);return[b.memoizedState,a]}function ye(a,b,c,d){a={tag:a,create:b,destroy:c,deps:d,next:null};b=z.updateQueue;null===b?(b={lastEffect:null},z.updateQueue=b,b.lastEffect=a.next=a):(c=b.lastEffect,null===c?b.lastEffect=a.next=a:(d=c.next,c.next=a,a.next=d,b.lastEffect=a));return a}function dh(a){return vb().memoizedState}function ze(a,b,c,d){var e=ub();z.effectTag|=a;e.memoizedState=ye(1|b,c,void 0,void 0===d?null:d)}function Ae(a,b,c,d){var e=vb();
d=void 0===d?null:d;var f=void 0;if(null!==K){var g=K.memoizedState;f=g.destroy;if(null!==d&&ve(d,g.deps)){ye(b,c,f,d);return}}z.effectTag|=a;e.memoizedState=ye(1|b,c,f,d)}function eh(a,b){return ze(516,4,a,b)}function Xc(a,b){return Ae(516,4,a,b)}function fh(a,b){return Ae(4,2,a,b)}function gh(a,b){if("function"===typeof b)return a=a(),b(a),function(){b(null)};if(null!==b&&void 0!==b)return a=a(),b.current=a,function(){b.current=null}}function hh(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;
return Ae(4,2,gh.bind(null,b,a),c)}function Be(a,b){}function ih(a,b){ub().memoizedState=[a,void 0===b?null:b];return a}function Yc(a,b){var c=vb();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&ve(b,d[1]))return d[0];c.memoizedState=[a,b];return a}function jh(a,b){var c=vb();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&ve(b,d[1]))return d[0];a=a();c.memoizedState=[a,b];return a}function Ce(a,b,c){var d=Cc();Da(98>d?98:d,function(){a(!0)});Da(97<d?97:d,function(){var d=
X.suspense;X.suspense=void 0===b?null:b;try{a(!1),c()}finally{X.suspense=d}})}function ch(a,b,c){var d=ka(),e=Vb.suspense;d=Va(d,a,e);e={expirationTime:d,suspenseConfig:e,action:c,eagerReducer:null,eagerState:null,next:null};var f=b.pending;null===f?e.next=e:(e.next=f.next,f.next=e);b.pending=e;f=a.alternate;if(a===z||null!==f&&f===z)Uc=!0,e.expirationTime=Ia,z.expirationTime=Ia;else{if(0===a.expirationTime&&(null===f||0===f.expirationTime)&&(f=b.lastRenderedReducer,null!==f))try{var g=b.lastRenderedState,
h=f(g,c);e.eagerReducer=f;e.eagerState=h;if(Qa(h,g))return}catch(m){}finally{}Ja(a,d)}}function kh(a,b){var c=la(5,null,null,0);c.elementType="DELETED";c.type="DELETED";c.stateNode=b;c.return=a;c.effectTag=8;null!==a.lastEffect?(a.lastEffect.nextEffect=c,a.lastEffect=c):a.firstEffect=a.lastEffect=c}function lh(a,b){switch(a.tag){case 5:var c=a.type;b=1!==b.nodeType||c.toLowerCase()!==b.nodeName.toLowerCase()?null:b;return null!==b?(a.stateNode=b,!0):!1;case 6:return b=""===a.pendingProps||3!==b.nodeType?
null:b,null!==b?(a.stateNode=b,!0):!1;case 13:return!1;default:return!1}}function De(a){if(Wa){var b=Ka;if(b){var c=b;if(!lh(a,b)){b=kb(c.nextSibling);if(!b||!lh(a,b)){a.effectTag=a.effectTag&-1025|2;Wa=!1;ra=a;return}kh(ra,c)}ra=a;Ka=kb(b.firstChild)}else a.effectTag=a.effectTag&-1025|2,Wa=!1,ra=a}}function mh(a){for(a=a.return;null!==a&&5!==a.tag&&3!==a.tag&&13!==a.tag;)a=a.return;ra=a}function Zc(a){if(a!==ra)return!1;if(!Wa)return mh(a),Wa=!0,!1;var b=a.type;if(5!==a.tag||"head"!==b&&"body"!==
b&&!Yd(b,a.memoizedProps))for(b=Ka;b;)kh(a,b),b=kb(b.nextSibling);mh(a);if(13===a.tag){a=a.memoizedState;a=null!==a?a.dehydrated:null;if(!a)throw Error(k(317));a:{a=a.nextSibling;for(b=0;a;){if(8===a.nodeType){var c=a.data;if(c===og){if(0===b){Ka=kb(a.nextSibling);break a}b--}else c!==ng&&c!==Zd&&c!==$d||b++}a=a.nextSibling}Ka=null}}else Ka=ra?kb(a.stateNode.nextSibling):null;return!0}function Ee(){Ka=ra=null;Wa=!1}function T(a,b,c,d){b.child=null===a?Fe(b,null,c,d):wb(b,a.child,c,d)}function nh(a,
b,c,d,e){c=c.render;var f=b.ref;rb(b,e);d=we(a,b,c,d,f,e);if(null!==a&&!ia)return b.updateQueue=a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),sa(a,b,e);b.effectTag|=1;T(a,b,d,e);return b.child}function oh(a,b,c,d,e,f){if(null===a){var g=c.type;if("function"===typeof g&&!Ge(g)&&void 0===g.defaultProps&&null===c.compare&&void 0===c.defaultProps)return b.tag=15,b.type=g,ph(a,b,g,d,e,f);a=Oc(c.type,null,d,null,b.mode,f);a.ref=b.ref;a.return=b;return b.child=a}g=a.child;if(e<
f&&(e=g.memoizedProps,c=c.compare,c=null!==c?c:Ob,c(e,d)&&a.ref===b.ref))return sa(a,b,f);b.effectTag|=1;a=Sa(g,d);a.ref=b.ref;a.return=b;return b.child=a}function ph(a,b,c,d,e,f){return null!==a&&Ob(a.memoizedProps,d)&&a.ref===b.ref&&(ia=!1,e<f)?(b.expirationTime=a.expirationTime,sa(a,b,f)):He(a,b,c,d,f)}function qh(a,b){var c=b.ref;if(null===a&&null!==c||null!==a&&a.ref!==c)b.effectTag|=128}function He(a,b,c,d,e){var f=N(c)?Ra:B.current;f=pb(b,f);rb(b,e);c=we(a,b,c,d,f,e);if(null!==a&&!ia)return b.updateQueue=
a.updateQueue,b.effectTag&=-517,a.expirationTime<=e&&(a.expirationTime=0),sa(a,b,e);b.effectTag|=1;T(a,b,c,e);return b.child}function rh(a,b,c,d,e){if(N(c)){var f=!0;Bc(b)}else f=!1;rb(b,e);if(null===b.stateNode)null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),Yg(b,c,d),pe(b,c,d,e),d=!0;else if(null===a){var g=b.stateNode,h=b.memoizedProps;g.props=h;var m=g.context,n=c.contextType;"object"===typeof n&&null!==n?n=W(n):(n=N(c)?Ra:B.current,n=pb(b,n));var l=c.getDerivedStateFromProps,k="function"===
typeof l||"function"===typeof g.getSnapshotBeforeUpdate;k||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||m!==n)&&Zg(b,g,d,n);Ga=!1;var p=b.memoizedState;g.state=p;Qb(b,d,g,e);m=b.memoizedState;h!==d||p!==m||G.current||Ga?("function"===typeof l&&(Lc(b,c,l,d),m=b.memoizedState),(h=Ga||Xg(b,c,h,d,p,m,n))?(k||"function"!==typeof g.UNSAFE_componentWillMount&&"function"!==typeof g.componentWillMount||("function"===typeof g.componentWillMount&&
g.componentWillMount(),"function"===typeof g.UNSAFE_componentWillMount&&g.UNSAFE_componentWillMount()),"function"===typeof g.componentDidMount&&(b.effectTag|=4)):("function"===typeof g.componentDidMount&&(b.effectTag|=4),b.memoizedProps=d,b.memoizedState=m),g.props=d,g.state=m,g.context=n,d=h):("function"===typeof g.componentDidMount&&(b.effectTag|=4),d=!1)}else g=b.stateNode,oe(a,b),h=b.memoizedProps,g.props=b.type===b.elementType?h:aa(b.type,h),m=g.context,n=c.contextType,"object"===typeof n&&null!==
n?n=W(n):(n=N(c)?Ra:B.current,n=pb(b,n)),l=c.getDerivedStateFromProps,(k="function"===typeof l||"function"===typeof g.getSnapshotBeforeUpdate)||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==d||m!==n)&&Zg(b,g,d,n),Ga=!1,m=b.memoizedState,g.state=m,Qb(b,d,g,e),p=b.memoizedState,h!==d||m!==p||G.current||Ga?("function"===typeof l&&(Lc(b,c,l,d),p=b.memoizedState),(l=Ga||Xg(b,c,h,d,m,p,n))?(k||"function"!==typeof g.UNSAFE_componentWillUpdate&&
"function"!==typeof g.componentWillUpdate||("function"===typeof g.componentWillUpdate&&g.componentWillUpdate(d,p,n),"function"===typeof g.UNSAFE_componentWillUpdate&&g.UNSAFE_componentWillUpdate(d,p,n)),"function"===typeof g.componentDidUpdate&&(b.effectTag|=4),"function"===typeof g.getSnapshotBeforeUpdate&&(b.effectTag|=256)):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&m===
a.memoizedState||(b.effectTag|=256),b.memoizedProps=d,b.memoizedState=p),g.props=d,g.state=p,g.context=n,d=l):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&m===a.memoizedState||(b.effectTag|=256),d=!1);return Ie(a,b,c,d,f,e)}function Ie(a,b,c,d,e,f){qh(a,b);var g=0!==(b.effectTag&64);if(!d&&!g)return e&&Hg(b,c,!1),sa(a,b,f);d=b.stateNode;gj.current=b;var h=g&&"function"!==typeof c.getDerivedStateFromError?
null:d.render();b.effectTag|=1;null!==a&&g?(b.child=wb(b,a.child,null,f),b.child=wb(b,null,h,f)):T(a,b,h,f);b.memoizedState=d.state;e&&Hg(b,c,!0);return b.child}function sh(a){var b=a.stateNode;b.pendingContext?Fg(a,b.pendingContext,b.pendingContext!==b.context):b.context&&Fg(a,b.context,!1);se(a,b.containerInfo)}function th(a,b,c){var d=b.mode,e=b.pendingProps,f=D.current,g=!1,h;(h=0!==(b.effectTag&64))||(h=0!==(f&2)&&(null===a||null!==a.memoizedState));h?(g=!0,b.effectTag&=-65):null!==a&&null===
a.memoizedState||void 0===e.fallback||!0===e.unstable_avoidThisFallback||(f|=1);y(D,f&1);if(null===a){void 0!==e.fallback&&De(b);if(g){g=e.fallback;e=Ha(null,d,0,null);e.return=b;if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==a;)a.return=e,a=a.sibling;c=Ha(g,d,c,null);c.return=b;e.sibling=c;b.memoizedState=Je;b.child=e;return c}d=e.children;b.memoizedState=null;return b.child=Fe(b,null,d,c)}if(null!==a.memoizedState){a=a.child;d=a.sibling;if(g){e=e.fallback;
c=Sa(a,a.pendingProps);c.return=b;if(0===(b.mode&2)&&(g=null!==b.memoizedState?b.child.child:b.child,g!==a.child))for(c.child=g;null!==g;)g.return=c,g=g.sibling;d=Sa(d,e);d.return=b;c.sibling=d;c.childExpirationTime=0;b.memoizedState=Je;b.child=c;return d}c=wb(b,a.child,e.children,c);b.memoizedState=null;return b.child=c}a=a.child;if(g){g=e.fallback;e=Ha(null,d,0,null);e.return=b;e.child=a;null!==a&&(a.return=e);if(0===(b.mode&2))for(a=null!==b.memoizedState?b.child.child:b.child,e.child=a;null!==
a;)a.return=e,a=a.sibling;c=Ha(g,d,c,null);c.return=b;e.sibling=c;c.effectTag|=2;e.childExpirationTime=0;b.memoizedState=Je;b.child=e;return c}b.memoizedState=null;return b.child=wb(b,a,e.children,c)}function uh(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);Sg(a.return,b)}function Ke(a,b,c,d,e,f){var g=a.memoizedState;null===g?a.memoizedState={isBackwards:b,rendering:null,renderingStartTime:0,last:d,tail:c,tailExpiration:0,tailMode:e,
lastEffect:f}:(g.isBackwards=b,g.rendering=null,g.renderingStartTime=0,g.last=d,g.tail=c,g.tailExpiration=0,g.tailMode=e,g.lastEffect=f)}function vh(a,b,c){var d=b.pendingProps,e=d.revealOrder,f=d.tail;T(a,b,d.children,c);d=D.current;if(0!==(d&2))d=d&1|2,b.effectTag|=64;else{if(null!==a&&0!==(a.effectTag&64))a:for(a=b.child;null!==a;){if(13===a.tag)null!==a.memoizedState&&uh(a,c);else if(19===a.tag)uh(a,c);else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===b)break a;for(;null===a.sibling;){if(null===
a.return||a.return===b)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}d&=1}y(D,d);if(0===(b.mode&2))b.memoizedState=null;else switch(e){case "forwards":c=b.child;for(e=null;null!==c;)a=c.alternate,null!==a&&null===Rc(a)&&(e=c),c=c.sibling;c=e;null===c?(e=b.child,b.child=null):(e=c.sibling,c.sibling=null);Ke(b,!1,e,c,f,b.lastEffect);break;case "backwards":c=null;e=b.child;for(b.child=null;null!==e;){a=e.alternate;if(null!==a&&null===Rc(a)){b.child=e;break}a=e.sibling;e.sibling=c;c=e;e=a}Ke(b,
!0,c,null,f,b.lastEffect);break;case "together":Ke(b,!1,null,null,void 0,b.lastEffect);break;default:b.memoizedState=null}return b.child}function sa(a,b,c){null!==a&&(b.dependencies=a.dependencies);var d=b.expirationTime;0!==d&&Kc(d);if(b.childExpirationTime<c)return null;if(null!==a&&b.child!==a.child)throw Error(k(153));if(null!==b.child){a=b.child;c=Sa(a,a.pendingProps);b.child=c;for(c.return=b;null!==a.sibling;)a=a.sibling,c=c.sibling=Sa(a,a.pendingProps),c.return=b;c.sibling=null}return b.child}
function $c(a,b){switch(a.tailMode){case "hidden":b=a.tail;for(var c=null;null!==b;)null!==b.alternate&&(c=b),b=b.sibling;null===c?a.tail=null:c.sibling=null;break;case "collapsed":c=a.tail;for(var d=null;null!==c;)null!==c.alternate&&(d=c),c=c.sibling;null===d?b||null===a.tail?a.tail=null:a.tail.sibling=null:d.sibling=null}}function hj(a,b,c){var d=b.pendingProps;switch(b.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return null;case 1:return N(b.type)&&(q(G),q(B)),
null;case 3:return tb(),q(G),q(B),c=b.stateNode,c.pendingContext&&(c.context=c.pendingContext,c.pendingContext=null),null!==a&&null!==a.child||!Zc(b)||(b.effectTag|=4),wh(b),null;case 5:te(b);c=Ta(Tb.current);var e=b.type;if(null!==a&&null!=b.stateNode)ij(a,b,e,d,c),a.ref!==b.ref&&(b.effectTag|=128);else{if(!d){if(null===b.stateNode)throw Error(k(166));return null}a=Ta(ja.current);if(Zc(b)){d=b.stateNode;e=b.type;var f=b.memoizedProps;d[Aa]=b;d[vc]=f;switch(e){case "iframe":case "object":case "embed":w("load",
d);break;case "video":case "audio":for(a=0;a<Db.length;a++)w(Db[a],d);break;case "source":w("error",d);break;case "img":case "image":case "link":w("error",d);w("load",d);break;case "form":w("reset",d);w("submit",d);break;case "details":w("toggle",d);break;case "input":Hf(d,f);w("invalid",d);oa(c,"onChange");break;case "select":d._wrapperState={wasMultiple:!!f.multiple};w("invalid",d);oa(c,"onChange");break;case "textarea":Kf(d,f),w("invalid",d),oa(c,"onChange")}Ud(e,f);a=null;for(var g in f)if(f.hasOwnProperty(g)){var h=
f[g];"children"===g?"string"===typeof h?d.textContent!==h&&(a=["children",h]):"number"===typeof h&&d.textContent!==""+h&&(a=["children",""+h]):db.hasOwnProperty(g)&&null!=h&&oa(c,g)}switch(e){case "input":mc(d);Jf(d,f,!0);break;case "textarea":mc(d);Mf(d);break;case "select":case "option":break;default:"function"===typeof f.onClick&&(d.onclick=uc)}c=a;b.updateQueue=c;null!==c&&(b.effectTag|=4)}else{g=9===c.nodeType?c:c.ownerDocument;"http://www.w3.org/1999/xhtml"===a&&(a=Nf(e));"http://www.w3.org/1999/xhtml"===
a?"script"===e?(a=g.createElement("div"),a.innerHTML="<script>\x3c/script>",a=a.removeChild(a.firstChild)):"string"===typeof d.is?a=g.createElement(e,{is:d.is}):(a=g.createElement(e),"select"===e&&(g=a,d.multiple?g.multiple=!0:d.size&&(g.size=d.size))):a=g.createElementNS(a,e);a[Aa]=b;a[vc]=d;jj(a,b,!1,!1);b.stateNode=a;g=Vd(e,d);switch(e){case "iframe":case "object":case "embed":w("load",a);h=d;break;case "video":case "audio":for(h=0;h<Db.length;h++)w(Db[h],a);h=d;break;case "source":w("error",a);
h=d;break;case "img":case "image":case "link":w("error",a);w("load",a);h=d;break;case "form":w("reset",a);w("submit",a);h=d;break;case "details":w("toggle",a);h=d;break;case "input":Hf(a,d);h=Cd(a,d);w("invalid",a);oa(c,"onChange");break;case "option":h=Fd(a,d);break;case "select":a._wrapperState={wasMultiple:!!d.multiple};h=M({},d,{value:void 0});w("invalid",a);oa(c,"onChange");break;case "textarea":Kf(a,d);h=Gd(a,d);w("invalid",a);oa(c,"onChange");break;default:h=d}Ud(e,h);var m=h;for(f in m)if(m.hasOwnProperty(f)){var n=
m[f];"style"===f?gg(a,n):"dangerouslySetInnerHTML"===f?(n=n?n.__html:void 0,null!=n&&xh(a,n)):"children"===f?"string"===typeof n?("textarea"!==e||""!==n)&&Wb(a,n):"number"===typeof n&&Wb(a,""+n):"suppressContentEditableWarning"!==f&&"suppressHydrationWarning"!==f&&"autoFocus"!==f&&(db.hasOwnProperty(f)?null!=n&&oa(c,f):null!=n&&xd(a,f,n,g))}switch(e){case "input":mc(a);Jf(a,d,!1);break;case "textarea":mc(a);Mf(a);break;case "option":null!=d.value&&a.setAttribute("value",""+va(d.value));break;case "select":a.multiple=
!!d.multiple;c=d.value;null!=c?hb(a,!!d.multiple,c,!1):null!=d.defaultValue&&hb(a,!!d.multiple,d.defaultValue,!0);break;default:"function"===typeof h.onClick&&(a.onclick=uc)}lg(e,d)&&(b.effectTag|=4)}null!==b.ref&&(b.effectTag|=128)}return null;case 6:if(a&&null!=b.stateNode)kj(a,b,a.memoizedProps,d);else{if("string"!==typeof d&&null===b.stateNode)throw Error(k(166));c=Ta(Tb.current);Ta(ja.current);Zc(b)?(c=b.stateNode,d=b.memoizedProps,c[Aa]=b,c.nodeValue!==d&&(b.effectTag|=4)):(c=(9===c.nodeType?
c:c.ownerDocument).createTextNode(d),c[Aa]=b,b.stateNode=c)}return null;case 13:q(D);d=b.memoizedState;if(0!==(b.effectTag&64))return b.expirationTime=c,b;c=null!==d;d=!1;null===a?void 0!==b.memoizedProps.fallback&&Zc(b):(e=a.memoizedState,d=null!==e,c||null===e||(e=a.child.sibling,null!==e&&(f=b.firstEffect,null!==f?(b.firstEffect=e,e.nextEffect=f):(b.firstEffect=b.lastEffect=e,e.nextEffect=null),e.effectTag=8)));if(c&&!d&&0!==(b.mode&2))if(null===a&&!0!==b.memoizedProps.unstable_avoidThisFallback||
0!==(D.current&1))F===Xa&&(F=ad);else{if(F===Xa||F===ad)F=bd;0!==Xb&&null!==U&&(Ya(U,P),yh(U,Xb))}if(c||d)b.effectTag|=4;return null;case 4:return tb(),wh(b),null;case 10:return me(b),null;case 17:return N(b.type)&&(q(G),q(B)),null;case 19:q(D);d=b.memoizedState;if(null===d)return null;e=0!==(b.effectTag&64);f=d.rendering;if(null===f)if(e)$c(d,!1);else{if(F!==Xa||null!==a&&0!==(a.effectTag&64))for(f=b.child;null!==f;){a=Rc(f);if(null!==a){b.effectTag|=64;$c(d,!1);e=a.updateQueue;null!==e&&(b.updateQueue=
e,b.effectTag|=4);null===d.lastEffect&&(b.firstEffect=null);b.lastEffect=d.lastEffect;for(d=b.child;null!==d;)e=d,f=c,e.effectTag&=2,e.nextEffect=null,e.firstEffect=null,e.lastEffect=null,a=e.alternate,null===a?(e.childExpirationTime=0,e.expirationTime=f,e.child=null,e.memoizedProps=null,e.memoizedState=null,e.updateQueue=null,e.dependencies=null):(e.childExpirationTime=a.childExpirationTime,e.expirationTime=a.expirationTime,e.child=a.child,e.memoizedProps=a.memoizedProps,e.memoizedState=a.memoizedState,
e.updateQueue=a.updateQueue,f=a.dependencies,e.dependencies=null===f?null:{expirationTime:f.expirationTime,firstContext:f.firstContext,responders:f.responders}),d=d.sibling;y(D,D.current&1|2);return b.child}f=f.sibling}}else{if(!e)if(a=Rc(f),null!==a){if(b.effectTag|=64,e=!0,c=a.updateQueue,null!==c&&(b.updateQueue=c,b.effectTag|=4),$c(d,!0),null===d.tail&&"hidden"===d.tailMode&&!f.alternate)return b=b.lastEffect=d.lastEffect,null!==b&&(b.nextEffect=null),null}else 2*Y()-d.renderingStartTime>d.tailExpiration&&
1<c&&(b.effectTag|=64,e=!0,$c(d,!1),b.expirationTime=b.childExpirationTime=c-1);d.isBackwards?(f.sibling=b.child,b.child=f):(c=d.last,null!==c?c.sibling=f:b.child=f,d.last=f)}return null!==d.tail?(0===d.tailExpiration&&(d.tailExpiration=Y()+500),c=d.tail,d.rendering=c,d.tail=c.sibling,d.lastEffect=b.lastEffect,d.renderingStartTime=Y(),c.sibling=null,b=D.current,y(D,e?b&1|2:b&1),c):null}throw Error(k(156,b.tag));}function lj(a,b){switch(a.tag){case 1:return N(a.type)&&(q(G),q(B)),b=a.effectTag,b&4096?
(a.effectTag=b&-4097|64,a):null;case 3:tb();q(G);q(B);b=a.effectTag;if(0!==(b&64))throw Error(k(285));a.effectTag=b&-4097|64;return a;case 5:return te(a),null;case 13:return q(D),b=a.effectTag,b&4096?(a.effectTag=b&-4097|64,a):null;case 19:return q(D),null;case 4:return tb(),null;case 10:return me(a),null;default:return null}}function Le(a,b){return{value:a,source:b,stack:Bd(b)}}function Me(a,b){var c=b.source,d=b.stack;null===d&&null!==c&&(d=Bd(c));null!==c&&na(c.type);b=b.value;null!==a&&1===a.tag&&
na(a.type);try{console.error(b)}catch(e){setTimeout(function(){throw e;})}}function mj(a,b){try{b.props=a.memoizedProps,b.state=a.memoizedState,b.componentWillUnmount()}catch(c){Za(a,c)}}function zh(a){var b=a.ref;if(null!==b)if("function"===typeof b)try{b(null)}catch(c){Za(a,c)}else b.current=null}function nj(a,b){switch(b.tag){case 0:case 11:case 15:case 22:return;case 1:if(b.effectTag&256&&null!==a){var c=a.memoizedProps,d=a.memoizedState;a=b.stateNode;b=a.getSnapshotBeforeUpdate(b.elementType===
b.type?c:aa(b.type,c),d);a.__reactInternalSnapshotBeforeUpdate=b}return;case 3:case 5:case 6:case 4:case 17:return}throw Error(k(163));}function Ah(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.destroy;c.destroy=void 0;void 0!==d&&d()}c=c.next}while(c!==b)}}function Bh(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.create;c.destroy=d()}c=c.next}while(c!==b)}}function oj(a,b,c,d){switch(c.tag){case 0:case 11:case 15:case 22:Bh(3,
c);return;case 1:a=c.stateNode;c.effectTag&4&&(null===b?a.componentDidMount():(d=c.elementType===c.type?b.memoizedProps:aa(c.type,b.memoizedProps),a.componentDidUpdate(d,b.memoizedState,a.__reactInternalSnapshotBeforeUpdate)));b=c.updateQueue;null!==b&&Wg(c,b,a);return;case 3:b=c.updateQueue;if(null!==b){a=null;if(null!==c.child)switch(c.child.tag){case 5:a=c.child.stateNode;break;case 1:a=c.child.stateNode}Wg(c,b,a)}return;case 5:a=c.stateNode;null===b&&c.effectTag&4&&lg(c.type,c.memoizedProps)&&
a.focus();return;case 6:return;case 4:return;case 12:return;case 13:null===c.memoizedState&&(c=c.alternate,null!==c&&(c=c.memoizedState,null!==c&&(c=c.dehydrated,null!==c&&bg(c))));return;case 19:case 17:case 20:case 21:return}throw Error(k(163));}function Ch(a,b,c){"function"===typeof Ne&&Ne(b);switch(b.tag){case 0:case 11:case 14:case 15:case 22:a=b.updateQueue;if(null!==a&&(a=a.lastEffect,null!==a)){var d=a.next;Da(97<c?97:c,function(){var a=d;do{var c=a.destroy;if(void 0!==c){var g=b;try{c()}catch(h){Za(g,
h)}}a=a.next}while(a!==d)})}break;case 1:zh(b);c=b.stateNode;"function"===typeof c.componentWillUnmount&&mj(b,c);break;case 5:zh(b);break;case 4:Dh(a,b,c)}}function Eh(a){var b=a.alternate;a.return=null;a.child=null;a.memoizedState=null;a.updateQueue=null;a.dependencies=null;a.alternate=null;a.firstEffect=null;a.lastEffect=null;a.pendingProps=null;a.memoizedProps=null;a.stateNode=null;null!==b&&Eh(b)}function Fh(a){return 5===a.tag||3===a.tag||4===a.tag}function Gh(a){a:{for(var b=a.return;null!==
b;){if(Fh(b)){var c=b;break a}b=b.return}throw Error(k(160));}b=c.stateNode;switch(c.tag){case 5:var d=!1;break;case 3:b=b.containerInfo;d=!0;break;case 4:b=b.containerInfo;d=!0;break;default:throw Error(k(161));}c.effectTag&16&&(Wb(b,""),c.effectTag&=-17);a:b:for(c=a;;){for(;null===c.sibling;){if(null===c.return||Fh(c.return)){c=null;break a}c=c.return}c.sibling.return=c.return;for(c=c.sibling;5!==c.tag&&6!==c.tag&&18!==c.tag;){if(c.effectTag&2)continue b;if(null===c.child||4===c.tag)continue b;
else c.child.return=c,c=c.child}if(!(c.effectTag&2)){c=c.stateNode;break a}}d?Oe(a,c,b):Pe(a,c,b)}function Oe(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?8===c.nodeType?c.parentNode.insertBefore(a,b):c.insertBefore(a,b):(8===c.nodeType?(b=c.parentNode,b.insertBefore(a,c)):(b=c,b.appendChild(a)),c=c._reactRootContainer,null!==c&&void 0!==c||null!==b.onclick||(b.onclick=uc));else if(4!==d&&(a=a.child,null!==a))for(Oe(a,b,c),a=a.sibling;null!==a;)Oe(a,b,c),a=a.sibling}
function Pe(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?c.insertBefore(a,b):c.appendChild(a);else if(4!==d&&(a=a.child,null!==a))for(Pe(a,b,c),a=a.sibling;null!==a;)Pe(a,b,c),a=a.sibling}function Dh(a,b,c){for(var d=b,e=!1,f,g;;){if(!e){e=d.return;a:for(;;){if(null===e)throw Error(k(160));f=e.stateNode;switch(e.tag){case 5:g=!1;break a;case 3:f=f.containerInfo;g=!0;break a;case 4:f=f.containerInfo;g=!0;break a}e=e.return}e=!0}if(5===d.tag||6===d.tag){a:for(var h=
a,m=d,n=c,l=m;;)if(Ch(h,l,n),null!==l.child&&4!==l.tag)l.child.return=l,l=l.child;else{if(l===m)break a;for(;null===l.sibling;){if(null===l.return||l.return===m)break a;l=l.return}l.sibling.return=l.return;l=l.sibling}g?(h=f,m=d.stateNode,8===h.nodeType?h.parentNode.removeChild(m):h.removeChild(m)):f.removeChild(d.stateNode)}else if(4===d.tag){if(null!==d.child){f=d.stateNode.containerInfo;g=!0;d.child.return=d;d=d.child;continue}}else if(Ch(a,d,c),null!==d.child){d.child.return=d;d=d.child;continue}if(d===
b)break;for(;null===d.sibling;){if(null===d.return||d.return===b)return;d=d.return;4===d.tag&&(e=!1)}d.sibling.return=d.return;d=d.sibling}}function Qe(a,b){switch(b.tag){case 0:case 11:case 14:case 15:case 22:Ah(3,b);return;case 1:return;case 5:var c=b.stateNode;if(null!=c){var d=b.memoizedProps,e=null!==a?a.memoizedProps:d;a=b.type;var f=b.updateQueue;b.updateQueue=null;if(null!==f){c[vc]=d;"input"===a&&"radio"===d.type&&null!=d.name&&If(c,d);Vd(a,e);b=Vd(a,d);for(e=0;e<f.length;e+=2){var g=f[e],
h=f[e+1];"style"===g?gg(c,h):"dangerouslySetInnerHTML"===g?xh(c,h):"children"===g?Wb(c,h):xd(c,g,h,b)}switch(a){case "input":Dd(c,d);break;case "textarea":Lf(c,d);break;case "select":b=c._wrapperState.wasMultiple,c._wrapperState.wasMultiple=!!d.multiple,a=d.value,null!=a?hb(c,!!d.multiple,a,!1):b!==!!d.multiple&&(null!=d.defaultValue?hb(c,!!d.multiple,d.defaultValue,!0):hb(c,!!d.multiple,d.multiple?[]:"",!1))}}}return;case 6:if(null===b.stateNode)throw Error(k(162));b.stateNode.nodeValue=b.memoizedProps;
return;case 3:b=b.stateNode;b.hydrate&&(b.hydrate=!1,bg(b.containerInfo));return;case 12:return;case 13:c=b;null===b.memoizedState?d=!1:(d=!0,c=b.child,Re=Y());if(null!==c)a:for(a=c;;){if(5===a.tag)f=a.stateNode,d?(f=f.style,"function"===typeof f.setProperty?f.setProperty("display","none","important"):f.display="none"):(f=a.stateNode,e=a.memoizedProps.style,e=void 0!==e&&null!==e&&e.hasOwnProperty("display")?e.display:null,f.style.display=fg("display",e));else if(6===a.tag)a.stateNode.nodeValue=d?
"":a.memoizedProps;else if(13===a.tag&&null!==a.memoizedState&&null===a.memoizedState.dehydrated){f=a.child.sibling;f.return=a;a=f;continue}else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===c)break;for(;null===a.sibling;){if(null===a.return||a.return===c)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}Hh(b);return;case 19:Hh(b);return;case 17:return}throw Error(k(163));}function Hh(a){var b=a.updateQueue;if(null!==b){a.updateQueue=null;var c=a.stateNode;null===c&&(c=a.stateNode=
new pj);b.forEach(function(b){var d=qj.bind(null,a,b);c.has(b)||(c.add(b),b.then(d,d))})}}function Ih(a,b,c){c=Ea(c,null);c.tag=3;c.payload={element:null};var d=b.value;c.callback=function(){cd||(cd=!0,Se=d);Me(a,b)};return c}function Jh(a,b,c){c=Ea(c,null);c.tag=3;var d=a.type.getDerivedStateFromError;if("function"===typeof d){var e=b.value;c.payload=function(){Me(a,b);return d(e)}}var f=a.stateNode;null!==f&&"function"===typeof f.componentDidCatch&&(c.callback=function(){"function"!==typeof d&&
(null===La?La=new Set([this]):La.add(this),Me(a,b));var c=b.stack;this.componentDidCatch(b.value,{componentStack:null!==c?c:""})});return c}function ka(){return(p&(ca|ma))!==H?1073741821-(Y()/10|0):0!==dd?dd:dd=1073741821-(Y()/10|0)}function Va(a,b,c){b=b.mode;if(0===(b&2))return 1073741823;var d=Cc();if(0===(b&4))return 99===d?1073741823:1073741822;if((p&ca)!==H)return P;if(null!==c)a=Fc(a,c.timeoutMs|0||5E3,250);else switch(d){case 99:a=1073741823;break;case 98:a=Fc(a,150,100);break;case 97:case 96:a=
Fc(a,5E3,250);break;case 95:a=2;break;default:throw Error(k(326));}null!==U&&a===P&&--a;return a}function ed(a,b){a.expirationTime<b&&(a.expirationTime=b);var c=a.alternate;null!==c&&c.expirationTime<b&&(c.expirationTime=b);var d=a.return,e=null;if(null===d&&3===a.tag)e=a.stateNode;else for(;null!==d;){c=d.alternate;d.childExpirationTime<b&&(d.childExpirationTime=b);null!==c&&c.childExpirationTime<b&&(c.childExpirationTime=b);if(null===d.return&&3===d.tag){e=d.stateNode;break}d=d.return}null!==e&&
(U===e&&(Kc(b),F===bd&&Ya(e,P)),yh(e,b));return e}function fd(a){var b=a.lastExpiredTime;if(0!==b)return b;b=a.firstPendingTime;if(!Kh(a,b))return b;var c=a.lastPingedTime;a=a.nextKnownPendingLevel;a=c>a?c:a;return 2>=a&&b!==a?0:a}function V(a){if(0!==a.lastExpiredTime)a.callbackExpirationTime=1073741823,a.callbackPriority=99,a.callbackNode=Og(Te.bind(null,a));else{var b=fd(a),c=a.callbackNode;if(0===b)null!==c&&(a.callbackNode=null,a.callbackExpirationTime=0,a.callbackPriority=90);else{var d=ka();
1073741823===b?d=99:1===b||2===b?d=95:(d=10*(1073741821-b)-10*(1073741821-d),d=0>=d?99:250>=d?98:5250>=d?97:95);if(null!==c){var e=a.callbackPriority;if(a.callbackExpirationTime===b&&e>=d)return;c!==Qg&&Rg(c)}a.callbackExpirationTime=b;a.callbackPriority=d;b=1073741823===b?Og(Te.bind(null,a)):Ng(d,Lh.bind(null,a),{timeout:10*(1073741821-b)-Y()});a.callbackNode=b}}}function Lh(a,b){dd=0;if(b)return b=ka(),Ue(a,b),V(a),null;var c=fd(a);if(0!==c){b=a.callbackNode;if((p&(ca|ma))!==H)throw Error(k(327));
xb();a===U&&c===P||$a(a,c);if(null!==t){var d=p;p|=ca;var e=Mh();do try{rj();break}catch(h){Nh(a,h)}while(1);le();p=d;gd.current=e;if(F===hd)throw b=id,$a(a,c),Ya(a,c),V(a),b;if(null===t)switch(e=a.finishedWork=a.current.alternate,a.finishedExpirationTime=c,d=F,U=null,d){case Xa:case hd:throw Error(k(345));case Oh:Ue(a,2<c?2:c);break;case ad:Ya(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ve(e));if(1073741823===ta&&(e=Re+Ph-Y(),10<e)){if(jd){var f=a.lastPingedTime;if(0===f||f>=c){a.lastPingedTime=
c;$a(a,c);break}}f=fd(a);if(0!==f&&f!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}a.timeoutHandle=We(ab.bind(null,a),e);break}ab(a);break;case bd:Ya(a,c);d=a.lastSuspendedTime;c===d&&(a.nextKnownPendingLevel=Ve(e));if(jd&&(e=a.lastPingedTime,0===e||e>=c)){a.lastPingedTime=c;$a(a,c);break}e=fd(a);if(0!==e&&e!==c)break;if(0!==d&&d!==c){a.lastPingedTime=d;break}1073741823!==Yb?d=10*(1073741821-Yb)-Y():1073741823===ta?d=0:(d=10*(1073741821-ta)-5E3,e=Y(),c=10*(1073741821-c)-e,d=e-d,0>d&&(d=0),d=
(120>d?120:480>d?480:1080>d?1080:1920>d?1920:3E3>d?3E3:4320>d?4320:1960*sj(d/1960))-d,c<d&&(d=c));if(10<d){a.timeoutHandle=We(ab.bind(null,a),d);break}ab(a);break;case Xe:if(1073741823!==ta&&null!==kd){f=ta;var g=kd;d=g.busyMinDurationMs|0;0>=d?d=0:(e=g.busyDelayMs|0,f=Y()-(10*(1073741821-f)-(g.timeoutMs|0||5E3)),d=f<=e?0:e+d-f);if(10<d){Ya(a,c);a.timeoutHandle=We(ab.bind(null,a),d);break}}ab(a);break;default:throw Error(k(329));}V(a);if(a.callbackNode===b)return Lh.bind(null,a)}}return null}function Te(a){var b=
a.lastExpiredTime;b=0!==b?b:1073741823;if((p&(ca|ma))!==H)throw Error(k(327));xb();a===U&&b===P||$a(a,b);if(null!==t){var c=p;p|=ca;var d=Mh();do try{tj();break}catch(e){Nh(a,e)}while(1);le();p=c;gd.current=d;if(F===hd)throw c=id,$a(a,b),Ya(a,b),V(a),c;if(null!==t)throw Error(k(261));a.finishedWork=a.current.alternate;a.finishedExpirationTime=b;U=null;ab(a);V(a)}return null}function uj(){if(null!==bb){var a=bb;bb=null;a.forEach(function(a,c){Ue(c,a);V(c)});ha()}}function Qh(a,b){var c=p;p|=1;try{return a(b)}finally{p=
c,p===H&&ha()}}function Rh(a,b){var c=p;p&=-2;p|=Ye;try{return a(b)}finally{p=c,p===H&&ha()}}function $a(a,b){a.finishedWork=null;a.finishedExpirationTime=0;var c=a.timeoutHandle;-1!==c&&(a.timeoutHandle=-1,vj(c));if(null!==t)for(c=t.return;null!==c;){var d=c;switch(d.tag){case 1:d=d.type.childContextTypes;null!==d&&void 0!==d&&(q(G),q(B));break;case 3:tb();q(G);q(B);break;case 5:te(d);break;case 4:tb();break;case 13:q(D);break;case 19:q(D);break;case 10:me(d)}c=c.return}U=a;t=Sa(a.current,null);
P=b;F=Xa;id=null;Yb=ta=1073741823;kd=null;Xb=0;jd=!1}function Nh(a,b){do{try{le();Sc.current=Tc;if(Uc)for(var c=z.memoizedState;null!==c;){var d=c.queue;null!==d&&(d.pending=null);c=c.next}Ia=0;J=K=z=null;Uc=!1;if(null===t||null===t.return)return F=hd,id=b,t=null;a:{var e=a,f=t.return,g=t,h=b;b=P;g.effectTag|=2048;g.firstEffect=g.lastEffect=null;if(null!==h&&"object"===typeof h&&"function"===typeof h.then){var m=h;if(0===(g.mode&2)){var n=g.alternate;n?(g.updateQueue=n.updateQueue,g.memoizedState=
n.memoizedState,g.expirationTime=n.expirationTime):(g.updateQueue=null,g.memoizedState=null)}var l=0!==(D.current&1),k=f;do{var p;if(p=13===k.tag){var q=k.memoizedState;if(null!==q)p=null!==q.dehydrated?!0:!1;else{var w=k.memoizedProps;p=void 0===w.fallback?!1:!0!==w.unstable_avoidThisFallback?!0:l?!1:!0}}if(p){var y=k.updateQueue;if(null===y){var r=new Set;r.add(m);k.updateQueue=r}else y.add(m);if(0===(k.mode&2)){k.effectTag|=64;g.effectTag&=-2981;if(1===g.tag)if(null===g.alternate)g.tag=17;else{var O=
Ea(1073741823,null);O.tag=Jc;Fa(g,O)}g.expirationTime=1073741823;break a}h=void 0;g=b;var v=e.pingCache;null===v?(v=e.pingCache=new wj,h=new Set,v.set(m,h)):(h=v.get(m),void 0===h&&(h=new Set,v.set(m,h)));if(!h.has(g)){h.add(g);var x=xj.bind(null,e,m,g);m.then(x,x)}k.effectTag|=4096;k.expirationTime=b;break a}k=k.return}while(null!==k);h=Error((na(g.type)||"A React component")+" suspended while rendering, but no fallback UI was specified.\n\nAdd a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display."+
Bd(g))}F!==Xe&&(F=Oh);h=Le(h,g);k=f;do{switch(k.tag){case 3:m=h;k.effectTag|=4096;k.expirationTime=b;var A=Ih(k,m,b);Ug(k,A);break a;case 1:m=h;var u=k.type,B=k.stateNode;if(0===(k.effectTag&64)&&("function"===typeof u.getDerivedStateFromError||null!==B&&"function"===typeof B.componentDidCatch&&(null===La||!La.has(B)))){k.effectTag|=4096;k.expirationTime=b;var H=Jh(k,m,b);Ug(k,H);break a}}k=k.return}while(null!==k)}t=Sh(t)}catch(cj){b=cj;continue}break}while(1)}function Mh(a){a=gd.current;gd.current=
Tc;return null===a?Tc:a}function Vg(a,b){a<ta&&2<a&&(ta=a);null!==b&&a<Yb&&2<a&&(Yb=a,kd=b)}function Kc(a){a>Xb&&(Xb=a)}function tj(){for(;null!==t;)t=Th(t)}function rj(){for(;null!==t&&!yj();)t=Th(t)}function Th(a){var b=zj(a.alternate,a,P);a.memoizedProps=a.pendingProps;null===b&&(b=Sh(a));Uh.current=null;return b}function Sh(a){t=a;do{var b=t.alternate;a=t.return;if(0===(t.effectTag&2048)){b=hj(b,t,P);if(1===P||1!==t.childExpirationTime){for(var c=0,d=t.child;null!==d;){var e=d.expirationTime,
f=d.childExpirationTime;e>c&&(c=e);f>c&&(c=f);d=d.sibling}t.childExpirationTime=c}if(null!==b)return b;null!==a&&0===(a.effectTag&2048)&&(null===a.firstEffect&&(a.firstEffect=t.firstEffect),null!==t.lastEffect&&(null!==a.lastEffect&&(a.lastEffect.nextEffect=t.firstEffect),a.lastEffect=t.lastEffect),1<t.effectTag&&(null!==a.lastEffect?a.lastEffect.nextEffect=t:a.firstEffect=t,a.lastEffect=t))}else{b=lj(t);if(null!==b)return b.effectTag&=2047,b;null!==a&&(a.firstEffect=a.lastEffect=null,a.effectTag|=
2048)}b=t.sibling;if(null!==b)return b;t=a}while(null!==t);F===Xa&&(F=Xe);return null}function Ve(a){var b=a.expirationTime;a=a.childExpirationTime;return b>a?b:a}function ab(a){var b=Cc();Da(99,Aj.bind(null,a,b));return null}function Aj(a,b){do xb();while(null!==Zb);if((p&(ca|ma))!==H)throw Error(k(327));var c=a.finishedWork,d=a.finishedExpirationTime;if(null===c)return null;a.finishedWork=null;a.finishedExpirationTime=0;if(c===a.current)throw Error(k(177));a.callbackNode=null;a.callbackExpirationTime=
0;a.callbackPriority=90;a.nextKnownPendingLevel=0;var e=Ve(c);a.firstPendingTime=e;d<=a.lastSuspendedTime?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:d<=a.firstSuspendedTime&&(a.firstSuspendedTime=d-1);d<=a.lastPingedTime&&(a.lastPingedTime=0);d<=a.lastExpiredTime&&(a.lastExpiredTime=0);a===U&&(t=U=null,P=0);1<c.effectTag?null!==c.lastEffect?(c.lastEffect.nextEffect=c,e=c.firstEffect):e=c:e=c.firstEffect;if(null!==e){var f=p;p|=ma;Uh.current=null;Ze=tc;var g=kg();if(Xd(g)){if("selectionStart"in
g)var h={start:g.selectionStart,end:g.selectionEnd};else a:{h=(h=g.ownerDocument)&&h.defaultView||window;var m=h.getSelection&&h.getSelection();if(m&&0!==m.rangeCount){h=m.anchorNode;var n=m.anchorOffset,q=m.focusNode;m=m.focusOffset;try{h.nodeType,q.nodeType}catch(sb){h=null;break a}var ba=0,w=-1,y=-1,B=0,D=0,r=g,z=null;b:for(;;){for(var v;;){r!==h||0!==n&&3!==r.nodeType||(w=ba+n);r!==q||0!==m&&3!==r.nodeType||(y=ba+m);3===r.nodeType&&(ba+=r.nodeValue.length);if(null===(v=r.firstChild))break;z=r;
r=v}for(;;){if(r===g)break b;z===h&&++B===n&&(w=ba);z===q&&++D===m&&(y=ba);if(null!==(v=r.nextSibling))break;r=z;z=r.parentNode}r=v}h=-1===w||-1===y?null:{start:w,end:y}}else h=null}h=h||{start:0,end:0}}else h=null;$e={activeElementDetached:null,focusedElem:g,selectionRange:h};tc=!1;l=e;do try{Bj()}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);l=e;do try{for(g=a,h=b;null!==l;){var x=l.effectTag;x&16&&Wb(l.stateNode,"");if(x&128){var A=l.alternate;if(null!==A){var u=
A.ref;null!==u&&("function"===typeof u?u(null):u.current=null)}}switch(x&1038){case 2:Gh(l);l.effectTag&=-3;break;case 6:Gh(l);l.effectTag&=-3;Qe(l.alternate,l);break;case 1024:l.effectTag&=-1025;break;case 1028:l.effectTag&=-1025;Qe(l.alternate,l);break;case 4:Qe(l.alternate,l);break;case 8:n=l,Dh(g,n,h),Eh(n)}l=l.nextEffect}}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);u=$e;A=kg();x=u.focusedElem;h=u.selectionRange;if(A!==x&&x&&x.ownerDocument&&jg(x.ownerDocument.documentElement,
x)){null!==h&&Xd(x)&&(A=h.start,u=h.end,void 0===u&&(u=A),"selectionStart"in x?(x.selectionStart=A,x.selectionEnd=Math.min(u,x.value.length)):(u=(A=x.ownerDocument||document)&&A.defaultView||window,u.getSelection&&(u=u.getSelection(),n=x.textContent.length,g=Math.min(h.start,n),h=void 0===h.end?g:Math.min(h.end,n),!u.extend&&g>h&&(n=h,h=g,g=n),n=ig(x,g),q=ig(x,h),n&&q&&(1!==u.rangeCount||u.anchorNode!==n.node||u.anchorOffset!==n.offset||u.focusNode!==q.node||u.focusOffset!==q.offset)&&(A=A.createRange(),
A.setStart(n.node,n.offset),u.removeAllRanges(),g>h?(u.addRange(A),u.extend(q.node,q.offset)):(A.setEnd(q.node,q.offset),u.addRange(A))))));A=[];for(u=x;u=u.parentNode;)1===u.nodeType&&A.push({element:u,left:u.scrollLeft,top:u.scrollTop});"function"===typeof x.focus&&x.focus();for(x=0;x<A.length;x++)u=A[x],u.element.scrollLeft=u.left,u.element.scrollTop=u.top}tc=!!Ze;$e=Ze=null;a.current=c;l=e;do try{for(x=a;null!==l;){var F=l.effectTag;F&36&&oj(x,l.alternate,l);if(F&128){A=void 0;var E=l.ref;if(null!==
E){var G=l.stateNode;switch(l.tag){case 5:A=G;break;default:A=G}"function"===typeof E?E(A):E.current=A}}l=l.nextEffect}}catch(sb){if(null===l)throw Error(k(330));Za(l,sb);l=l.nextEffect}while(null!==l);l=null;Cj();p=f}else a.current=c;if(ld)ld=!1,Zb=a,$b=b;else for(l=e;null!==l;)b=l.nextEffect,l.nextEffect=null,l=b;b=a.firstPendingTime;0===b&&(La=null);1073741823===b?a===af?ac++:(ac=0,af=a):ac=0;"function"===typeof bf&&bf(c.stateNode,d);V(a);if(cd)throw cd=!1,a=Se,Se=null,a;if((p&Ye)!==H)return null;
ha();return null}function Bj(){for(;null!==l;){var a=l.effectTag;0!==(a&256)&&nj(l.alternate,l);0===(a&512)||ld||(ld=!0,Ng(97,function(){xb();return null}));l=l.nextEffect}}function xb(){if(90!==$b){var a=97<$b?97:$b;$b=90;return Da(a,Dj)}}function Dj(){if(null===Zb)return!1;var a=Zb;Zb=null;if((p&(ca|ma))!==H)throw Error(k(331));var b=p;p|=ma;for(a=a.current.firstEffect;null!==a;){try{var c=a;if(0!==(c.effectTag&512))switch(c.tag){case 0:case 11:case 15:case 22:Ah(5,c),Bh(5,c)}}catch(d){if(null===
a)throw Error(k(330));Za(a,d)}c=a.nextEffect;a.nextEffect=null;a=c}p=b;ha();return!0}function Vh(a,b,c){b=Le(c,b);b=Ih(a,b,1073741823);Fa(a,b);a=ed(a,1073741823);null!==a&&V(a)}function Za(a,b){if(3===a.tag)Vh(a,a,b);else for(var c=a.return;null!==c;){if(3===c.tag){Vh(c,a,b);break}else if(1===c.tag){var d=c.stateNode;if("function"===typeof c.type.getDerivedStateFromError||"function"===typeof d.componentDidCatch&&(null===La||!La.has(d))){a=Le(b,a);a=Jh(c,a,1073741823);Fa(c,a);c=ed(c,1073741823);null!==
c&&V(c);break}}c=c.return}}function xj(a,b,c){var d=a.pingCache;null!==d&&d.delete(b);U===a&&P===c?F===bd||F===ad&&1073741823===ta&&Y()-Re<Ph?$a(a,P):jd=!0:Kh(a,c)&&(b=a.lastPingedTime,0!==b&&b<c||(a.lastPingedTime=c,V(a)))}function qj(a,b){var c=a.stateNode;null!==c&&c.delete(b);b=0;0===b&&(b=ka(),b=Va(b,a,null));a=ed(a,b);null!==a&&V(a)}function Ej(a){if("undefined"===typeof __REACT_DEVTOOLS_GLOBAL_HOOK__)return!1;var b=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(b.isDisabled||!b.supportsFiber)return!0;try{var c=
b.inject(a);bf=function(a,e){try{b.onCommitFiberRoot(c,a,void 0,64===(a.current.effectTag&64))}catch(f){}};Ne=function(a){try{b.onCommitFiberUnmount(c,a)}catch(e){}}}catch(d){}return!0}function Fj(a,b,c,d){this.tag=a;this.key=c;this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null;this.index=0;this.ref=null;this.pendingProps=b;this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null;this.mode=d;this.effectTag=0;this.lastEffect=this.firstEffect=this.nextEffect=
null;this.childExpirationTime=this.expirationTime=0;this.alternate=null}function Ge(a){a=a.prototype;return!(!a||!a.isReactComponent)}function Gj(a){if("function"===typeof a)return Ge(a)?1:0;if(void 0!==a&&null!==a){a=a.$$typeof;if(a===zd)return 11;if(a===Ad)return 14}return 2}function Sa(a,b){var c=a.alternate;null===c?(c=la(a.tag,b,a.key,a.mode),c.elementType=a.elementType,c.type=a.type,c.stateNode=a.stateNode,c.alternate=a,a.alternate=c):(c.pendingProps=b,c.effectTag=0,c.nextEffect=null,c.firstEffect=
null,c.lastEffect=null);c.childExpirationTime=a.childExpirationTime;c.expirationTime=a.expirationTime;c.child=a.child;c.memoizedProps=a.memoizedProps;c.memoizedState=a.memoizedState;c.updateQueue=a.updateQueue;b=a.dependencies;c.dependencies=null===b?null:{expirationTime:b.expirationTime,firstContext:b.firstContext,responders:b.responders};c.sibling=a.sibling;c.index=a.index;c.ref=a.ref;return c}function Oc(a,b,c,d,e,f){var g=2;d=a;if("function"===typeof a)Ge(a)&&(g=1);else if("string"===typeof a)g=
5;else a:switch(a){case Ma:return Ha(c.children,e,f,b);case Hj:g=8;e|=7;break;case Af:g=8;e|=1;break;case kc:return a=la(12,c,b,e|8),a.elementType=kc,a.type=kc,a.expirationTime=f,a;case lc:return a=la(13,c,b,e),a.type=lc,a.elementType=lc,a.expirationTime=f,a;case yd:return a=la(19,c,b,e),a.elementType=yd,a.expirationTime=f,a;default:if("object"===typeof a&&null!==a)switch(a.$$typeof){case Cf:g=10;break a;case Bf:g=9;break a;case zd:g=11;break a;case Ad:g=14;break a;case Ef:g=16;d=null;break a;case Df:g=
22;break a}throw Error(k(130,null==a?a:typeof a,""));}b=la(g,c,b,e);b.elementType=a;b.type=d;b.expirationTime=f;return b}function Ha(a,b,c,d){a=la(7,a,d,b);a.expirationTime=c;return a}function qe(a,b,c){a=la(6,a,null,b);a.expirationTime=c;return a}function re(a,b,c){b=la(4,null!==a.children?a.children:[],a.key,b);b.expirationTime=c;b.stateNode={containerInfo:a.containerInfo,pendingChildren:null,implementation:a.implementation};return b}function Ij(a,b,c){this.tag=b;this.current=null;this.containerInfo=
a;this.pingCache=this.pendingChildren=null;this.finishedExpirationTime=0;this.finishedWork=null;this.timeoutHandle=-1;this.pendingContext=this.context=null;this.hydrate=c;this.callbackNode=null;this.callbackPriority=90;this.lastExpiredTime=this.lastPingedTime=this.nextKnownPendingLevel=this.lastSuspendedTime=this.firstSuspendedTime=this.firstPendingTime=0}function Kh(a,b){var c=a.firstSuspendedTime;a=a.lastSuspendedTime;return 0!==c&&c>=b&&a<=b}function Ya(a,b){var c=a.firstSuspendedTime,d=a.lastSuspendedTime;
c<b&&(a.firstSuspendedTime=b);if(d>b||0===c)a.lastSuspendedTime=b;b<=a.lastPingedTime&&(a.lastPingedTime=0);b<=a.lastExpiredTime&&(a.lastExpiredTime=0)}function yh(a,b){b>a.firstPendingTime&&(a.firstPendingTime=b);var c=a.firstSuspendedTime;0!==c&&(b>=c?a.firstSuspendedTime=a.lastSuspendedTime=a.nextKnownPendingLevel=0:b>=a.lastSuspendedTime&&(a.lastSuspendedTime=b+1),b>a.nextKnownPendingLevel&&(a.nextKnownPendingLevel=b))}function Ue(a,b){var c=a.lastExpiredTime;if(0===c||c>b)a.lastExpiredTime=b}
function md(a,b,c,d){var e=b.current,f=ka(),g=Vb.suspense;f=Va(f,e,g);a:if(c){c=c._reactInternalFiber;b:{if(Na(c)!==c||1!==c.tag)throw Error(k(170));var h=c;do{switch(h.tag){case 3:h=h.stateNode.context;break b;case 1:if(N(h.type)){h=h.stateNode.__reactInternalMemoizedMergedChildContext;break b}}h=h.return}while(null!==h);throw Error(k(171));}if(1===c.tag){var m=c.type;if(N(m)){c=Gg(c,m,h);break a}}c=h}else c=Ca;null===b.context?b.context=c:b.pendingContext=c;b=Ea(f,g);b.payload={element:a};d=void 0===
d?null:d;null!==d&&(b.callback=d);Fa(e,b);Ja(e,f);return f}function cf(a){a=a.current;if(!a.child)return null;switch(a.child.tag){case 5:return a.child.stateNode;default:return a.child.stateNode}}function Wh(a,b){a=a.memoizedState;null!==a&&null!==a.dehydrated&&a.retryTime<b&&(a.retryTime=b)}function df(a,b){Wh(a,b);(a=a.alternate)&&Wh(a,b)}function ef(a,b,c){c=null!=c&&!0===c.hydrate;var d=new Ij(a,b,c),e=la(3,null,null,2===b?7:1===b?3:0);d.current=e;e.stateNode=d;ne(e);a[Lb]=d.current;c&&0!==b&&
xi(a,9===a.nodeType?a:a.ownerDocument);this._internalRoot=d}function bc(a){return!(!a||1!==a.nodeType&&9!==a.nodeType&&11!==a.nodeType&&(8!==a.nodeType||" react-mount-point-unstable "!==a.nodeValue))}function Jj(a,b){b||(b=a?9===a.nodeType?a.documentElement:a.firstChild:null,b=!(!b||1!==b.nodeType||!b.hasAttribute("data-reactroot")));if(!b)for(var c;c=a.lastChild;)a.removeChild(c);return new ef(a,0,b?{hydrate:!0}:void 0)}function nd(a,b,c,d,e){var f=c._reactRootContainer;if(f){var g=f._internalRoot;
if("function"===typeof e){var h=e;e=function(){var a=cf(g);h.call(a)}}md(b,g,a,e)}else{f=c._reactRootContainer=Jj(c,d);g=f._internalRoot;if("function"===typeof e){var m=e;e=function(){var a=cf(g);m.call(a)}}Rh(function(){md(b,g,a,e)})}return cf(g)}function Kj(a,b,c){var d=3<arguments.length&&void 0!==arguments[3]?arguments[3]:null;return{$$typeof:gb,key:null==d?null:""+d,children:a,containerInfo:b,implementation:c}}function Xh(a,b){var c=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null;
if(!bc(b))throw Error(k(200));return Kj(a,b,null,c)}if(!ea)throw Error(k(227));var ki=function(a,b,c,d,e,f,g,h,m){var n=Array.prototype.slice.call(arguments,3);try{b.apply(c,n)}catch(C){this.onError(C)}},yb=!1,gc=null,hc=!1,pd=null,li={onError:function(a){yb=!0;gc=a}},td=null,rf=null,mf=null,ic=null,cb={},jc=[],qd={},db={},rd={},wa=!("undefined"===typeof window||"undefined"===typeof window.document||"undefined"===typeof window.document.createElement),M=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.assign,
sd=null,eb=null,fb=null,ee=function(a,b){return a(b)},eg=function(a,b,c,d,e){return a(b,c,d,e)},vd=function(){},vf=ee,Oa=!1,wd=!1,Z=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.Scheduler,Lj=Z.unstable_cancelCallback,ff=Z.unstable_now,$f=Z.unstable_scheduleCallback,Mj=Z.unstable_shouldYield,Yh=Z.unstable_requestPaint,Pd=Z.unstable_runWithPriority,Nj=Z.unstable_getCurrentPriorityLevel,Oj=Z.unstable_ImmediatePriority,Zh=Z.unstable_UserBlockingPriority,ag=Z.unstable_NormalPriority,Pj=Z.unstable_LowPriority,
Qj=Z.unstable_IdlePriority,oi=/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,wf=Object.prototype.hasOwnProperty,yf={},xf={},E={};"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a){E[a]=
new L(a,0,!1,a,null,!1)});[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach(function(a){var b=a[0];E[b]=new L(b,1,!1,a[1],null,!1)});["contentEditable","draggable","spellCheck","value"].forEach(function(a){E[a]=new L(a,2,!1,a.toLowerCase(),null,!1)});["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach(function(a){E[a]=new L(a,2,!1,a,null,!1)});"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a){E[a]=
new L(a,3,!1,a.toLowerCase(),null,!1)});["checked","multiple","muted","selected"].forEach(function(a){E[a]=new L(a,3,!0,a,null,!1)});["capture","download"].forEach(function(a){E[a]=new L(a,4,!1,a,null,!1)});["cols","rows","size","span"].forEach(function(a){E[a]=new L(a,6,!1,a,null,!1)});["rowSpan","start"].forEach(function(a){E[a]=new L(a,5,!1,a.toLowerCase(),null,!1)});var gf=/[\-:]([a-z])/g,hf=function(a){return a[1].toUpperCase()};"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a){var b=
a.replace(gf,hf);E[b]=new L(b,1,!1,a,null,!1)});"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a){var b=a.replace(gf,hf);E[b]=new L(b,1,!1,a,"http://www.w3.org/1999/xlink",!1)});["xml:base","xml:lang","xml:space"].forEach(function(a){var b=a.replace(gf,hf);E[b]=new L(b,1,!1,a,"http://www.w3.org/XML/1998/namespace",!1)});["tabIndex","crossOrigin"].forEach(function(a){E[a]=new L(a,1,!1,a.toLowerCase(),null,!1)});E.xlinkHref=new L("xlinkHref",1,
!1,"xlink:href","http://www.w3.org/1999/xlink",!0);["src","href","action","formAction"].forEach(function(a){E[a]=new L(a,1,!1,a.toLowerCase(),null,!0)});var da=ea.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;da.hasOwnProperty("ReactCurrentDispatcher")||(da.ReactCurrentDispatcher={current:null});da.hasOwnProperty("ReactCurrentBatchConfig")||(da.ReactCurrentBatchConfig={suspense:null});var si=/^(.*)[\\\/]/,Q="function"===typeof Symbol&&Symbol.for,Pc=Q?Symbol.for("react.element"):60103,gb=Q?Symbol.for("react.portal"):
60106,Ma=Q?Symbol.for("react.fragment"):60107,Af=Q?Symbol.for("react.strict_mode"):60108,kc=Q?Symbol.for("react.profiler"):60114,Cf=Q?Symbol.for("react.provider"):60109,Bf=Q?Symbol.for("react.context"):60110,Hj=Q?Symbol.for("react.concurrent_mode"):60111,zd=Q?Symbol.for("react.forward_ref"):60112,lc=Q?Symbol.for("react.suspense"):60113,yd=Q?Symbol.for("react.suspense_list"):60120,Ad=Q?Symbol.for("react.memo"):60115,Ef=Q?Symbol.for("react.lazy"):60116,Df=Q?Symbol.for("react.block"):60121,zf="function"===
typeof Symbol&&Symbol.iterator,od,xh=function(a){return"undefined"!==typeof MSApp&&MSApp.execUnsafeLocalFunction?function(b,c,d,e){MSApp.execUnsafeLocalFunction(function(){return a(b,c,d,e)})}:a}(function(a,b){if("http://www.w3.org/2000/svg"!==a.namespaceURI||"innerHTML"in a)a.innerHTML=b;else{od=od||document.createElement("div");od.innerHTML="<svg>"+b.valueOf().toString()+"</svg>";for(b=od.firstChild;a.firstChild;)a.removeChild(a.firstChild);for(;b.firstChild;)a.appendChild(b.firstChild)}}),Wb=function(a,
b){if(b){var c=a.firstChild;if(c&&c===a.lastChild&&3===c.nodeType){c.nodeValue=b;return}}a.textContent=b},ib={animationend:nc("Animation","AnimationEnd"),animationiteration:nc("Animation","AnimationIteration"),animationstart:nc("Animation","AnimationStart"),transitionend:nc("Transition","TransitionEnd")},Id={},Of={};wa&&(Of=document.createElement("div").style,"AnimationEvent"in window||(delete ib.animationend.animation,delete ib.animationiteration.animation,delete ib.animationstart.animation),"TransitionEvent"in
window||delete ib.transitionend.transition);var $h=oc("animationend"),ai=oc("animationiteration"),bi=oc("animationstart"),ci=oc("transitionend"),Db="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),Pf=new ("function"===typeof WeakMap?WeakMap:Map),Ab=null,wi=function(a){if(a){var b=a._dispatchListeners,c=a._dispatchInstances;
if(Array.isArray(b))for(var d=0;d<b.length&&!a.isPropagationStopped();d++)lf(a,b[d],c[d]);else b&&lf(a,b,c);a._dispatchListeners=null;a._dispatchInstances=null;a.isPersistent()||a.constructor.release(a)}},qc=[],Rd=!1,fa=[],xa=null,ya=null,za=null,Eb=new Map,Fb=new Map,Jb=[],Nd="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput close cancel copy cut paste click change contextmenu reset submit".split(" "),
yi="focus blur dragenter dragleave mouseover mouseout pointerover pointerout gotpointercapture lostpointercapture".split(" "),dg={},cg=new Map,Td=new Map,Rj=["abort","abort",$h,"animationEnd",ai,"animationIteration",bi,"animationStart","canplay","canPlay","canplaythrough","canPlayThrough","durationchange","durationChange","emptied","emptied","encrypted","encrypted","ended","ended","error","error","gotpointercapture","gotPointerCapture","load","load","loadeddata","loadedData","loadedmetadata","loadedMetadata",
"loadstart","loadStart","lostpointercapture","lostPointerCapture","playing","playing","progress","progress","seeking","seeking","stalled","stalled","suspend","suspend","timeupdate","timeUpdate",ci,"transitionEnd","waiting","waiting"];Sd("blur blur cancel cancel click click close close contextmenu contextMenu copy copy cut cut auxclick auxClick dblclick doubleClick dragend dragEnd dragstart dragStart drop drop focus focus input input invalid invalid keydown keyDown keypress keyPress keyup keyUp mousedown mouseDown mouseup mouseUp paste paste pause pause play play pointercancel pointerCancel pointerdown pointerDown pointerup pointerUp ratechange rateChange reset reset seeked seeked submit submit touchcancel touchCancel touchend touchEnd touchstart touchStart volumechange volumeChange".split(" "),
0);Sd("drag drag dragenter dragEnter dragexit dragExit dragleave dragLeave dragover dragOver mousemove mouseMove mouseout mouseOut mouseover mouseOver pointermove pointerMove pointerout pointerOut pointerover pointerOver scroll scroll toggle toggle touchmove touchMove wheel wheel".split(" "),1);Sd(Rj,2);(function(a,b){for(var c=0;c<a.length;c++)Td.set(a[c],b)})("change selectionchange textInput compositionstart compositionend compositionupdate".split(" "),0);var Hi=Zh,Gi=Pd,tc=!0,Kb={animationIterationCount:!0,
borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,
strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},Sj=["Webkit","ms","Moz","O"];Object.keys(Kb).forEach(function(a){Sj.forEach(function(b){b=b+a.charAt(0).toUpperCase()+a.substring(1);Kb[b]=Kb[a]})});var Ii=M({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0}),ng="$",og="/$",$d="$?",Zd="$!",Ze=null,$e=null,We="function"===typeof setTimeout?setTimeout:void 0,vj="function"===
typeof clearTimeout?clearTimeout:void 0,jf=Math.random().toString(36).slice(2),Aa="__reactInternalInstance$"+jf,vc="__reactEventHandlers$"+jf,Lb="__reactContainere$"+jf,Ba=null,ce=null,wc=null;M(R.prototype,{preventDefault:function(){this.defaultPrevented=!0;var a=this.nativeEvent;a&&(a.preventDefault?a.preventDefault():"unknown"!==typeof a.returnValue&&(a.returnValue=!1),this.isDefaultPrevented=xc)},stopPropagation:function(){var a=this.nativeEvent;a&&(a.stopPropagation?a.stopPropagation():"unknown"!==
typeof a.cancelBubble&&(a.cancelBubble=!0),this.isPropagationStopped=xc)},persist:function(){this.isPersistent=xc},isPersistent:yc,destructor:function(){var a=this.constructor.Interface,b;for(b in a)this[b]=null;this.nativeEvent=this._targetInst=this.dispatchConfig=null;this.isPropagationStopped=this.isDefaultPrevented=yc;this._dispatchInstances=this._dispatchListeners=null}});R.Interface={type:null,target:null,currentTarget:function(){return null},eventPhase:null,bubbles:null,cancelable:null,timeStamp:function(a){return a.timeStamp||
Date.now()},defaultPrevented:null,isTrusted:null};R.extend=function(a){function b(){return c.apply(this,arguments)}var c=this,d=function(){};d.prototype=c.prototype;d=new d;M(d,b.prototype);b.prototype=d;b.prototype.constructor=b;b.Interface=M({},c.Interface,a);b.extend=c.extend;sg(b);return b};sg(R);var Tj=R.extend({data:null}),Uj=R.extend({data:null}),Ni=[9,13,27,32],de=wa&&"CompositionEvent"in window,cc=null;wa&&"documentMode"in document&&(cc=document.documentMode);var Vj=wa&&"TextEvent"in window&&
!cc,xg=wa&&(!de||cc&&8<cc&&11>=cc),wg=String.fromCharCode(32),ua={beforeInput:{phasedRegistrationNames:{bubbled:"onBeforeInput",captured:"onBeforeInputCapture"},dependencies:["compositionend","keypress","textInput","paste"]},compositionEnd:{phasedRegistrationNames:{bubbled:"onCompositionEnd",captured:"onCompositionEndCapture"},dependencies:"blur compositionend keydown keypress keyup mousedown".split(" ")},compositionStart:{phasedRegistrationNames:{bubbled:"onCompositionStart",captured:"onCompositionStartCapture"},
dependencies:"blur compositionstart keydown keypress keyup mousedown".split(" ")},compositionUpdate:{phasedRegistrationNames:{bubbled:"onCompositionUpdate",captured:"onCompositionUpdateCapture"},dependencies:"blur compositionupdate keydown keypress keyup mousedown".split(" ")}},vg=!1,mb=!1,Wj={eventTypes:ua,extractEvents:function(a,b,c,d,e){var f;if(de)b:{switch(a){case "compositionstart":var g=ua.compositionStart;break b;case "compositionend":g=ua.compositionEnd;break b;case "compositionupdate":g=
ua.compositionUpdate;break b}g=void 0}else mb?tg(a,c)&&(g=ua.compositionEnd):"keydown"===a&&229===c.keyCode&&(g=ua.compositionStart);g?(xg&&"ko"!==c.locale&&(mb||g!==ua.compositionStart?g===ua.compositionEnd&&mb&&(f=rg()):(Ba=d,ce="value"in Ba?Ba.value:Ba.textContent,mb=!0)),e=Tj.getPooled(g,b,c,d),f?e.data=f:(f=ug(c),null!==f&&(e.data=f)),lb(e),f=e):f=null;(a=Vj?Oi(a,c):Pi(a,c))?(b=Uj.getPooled(ua.beforeInput,b,c,d),b.data=a,lb(b)):b=null;return null===f?b:null===b?f:[f,b]}},Qi={color:!0,date:!0,
datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0},Ag={change:{phasedRegistrationNames:{bubbled:"onChange",captured:"onChangeCapture"},dependencies:"blur change click focus input keydown keyup selectionchange".split(" ")}},Mb=null,Nb=null,kf=!1;wa&&(kf=Tf("input")&&(!document.documentMode||9<document.documentMode));var Xj={eventTypes:Ag,_isInputEventSupported:kf,extractEvents:function(a,b,c,d,e){e=b?Pa(b):window;var f=
e.nodeName&&e.nodeName.toLowerCase();if("select"===f||"input"===f&&"file"===e.type)var g=Si;else if(yg(e))if(kf)g=Wi;else{g=Ui;var h=Ti}else(f=e.nodeName)&&"input"===f.toLowerCase()&&("checkbox"===e.type||"radio"===e.type)&&(g=Vi);if(g&&(g=g(a,b)))return zg(g,c,d);h&&h(a,e,b);"blur"===a&&(a=e._wrapperState)&&a.controlled&&"number"===e.type&&Ed(e,"number",e.value)}},dc=R.extend({view:null,detail:null}),Yi={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"},di=0,ei=0,fi=!1,gi=!1,ec=dc.extend({screenX:null,
screenY:null,clientX:null,clientY:null,pageX:null,pageY:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,getModifierState:fe,button:null,buttons:null,relatedTarget:function(a){return a.relatedTarget||(a.fromElement===a.srcElement?a.toElement:a.fromElement)},movementX:function(a){if("movementX"in a)return a.movementX;var b=di;di=a.screenX;return fi?"mousemove"===a.type?a.screenX-b:0:(fi=!0,0)},movementY:function(a){if("movementY"in a)return a.movementY;var b=ei;ei=a.screenY;return gi?"mousemove"===
a.type?a.screenY-b:0:(gi=!0,0)}}),hi=ec.extend({pointerId:null,width:null,height:null,pressure:null,tangentialPressure:null,tiltX:null,tiltY:null,twist:null,pointerType:null,isPrimary:null}),fc={mouseEnter:{registrationName:"onMouseEnter",dependencies:["mouseout","mouseover"]},mouseLeave:{registrationName:"onMouseLeave",dependencies:["mouseout","mouseover"]},pointerEnter:{registrationName:"onPointerEnter",dependencies:["pointerout","pointerover"]},pointerLeave:{registrationName:"onPointerLeave",dependencies:["pointerout",
"pointerover"]}},Yj={eventTypes:fc,extractEvents:function(a,b,c,d,e){var f="mouseover"===a||"pointerover"===a,g="mouseout"===a||"pointerout"===a;if(f&&0===(e&32)&&(c.relatedTarget||c.fromElement)||!g&&!f)return null;f=d.window===d?d:(f=d.ownerDocument)?f.defaultView||f.parentWindow:window;if(g){if(g=b,b=(b=c.relatedTarget||c.toElement)?Bb(b):null,null!==b){var h=Na(b);if(b!==h||5!==b.tag&&6!==b.tag)b=null}}else g=null;if(g===b)return null;if("mouseout"===a||"mouseover"===a){var m=ec;var n=fc.mouseLeave;
var l=fc.mouseEnter;var k="mouse"}else if("pointerout"===a||"pointerover"===a)m=hi,n=fc.pointerLeave,l=fc.pointerEnter,k="pointer";a=null==g?f:Pa(g);f=null==b?f:Pa(b);n=m.getPooled(n,g,c,d);n.type=k+"leave";n.target=a;n.relatedTarget=f;c=m.getPooled(l,b,c,d);c.type=k+"enter";c.target=f;c.relatedTarget=a;d=g;k=b;if(d&&k)a:{m=d;l=k;g=0;for(a=m;a;a=pa(a))g++;a=0;for(b=l;b;b=pa(b))a++;for(;0<g-a;)m=pa(m),g--;for(;0<a-g;)l=pa(l),a--;for(;g--;){if(m===l||m===l.alternate)break a;m=pa(m);l=pa(l)}m=null}else m=
null;l=m;for(m=[];d&&d!==l;){g=d.alternate;if(null!==g&&g===l)break;m.push(d);d=pa(d)}for(d=[];k&&k!==l;){g=k.alternate;if(null!==g&&g===l)break;d.push(k);k=pa(k)}for(k=0;k<m.length;k++)be(m[k],"bubbled",n);for(k=d.length;0<k--;)be(d[k],"captured",c);return 0===(e&64)?[n]:[n,c]}},Qa="function"===typeof Object.is?Object.is:Zi,$i=Object.prototype.hasOwnProperty,Zj=wa&&"documentMode"in document&&11>=document.documentMode,Eg={select:{phasedRegistrationNames:{bubbled:"onSelect",captured:"onSelectCapture"},
dependencies:"blur contextmenu dragend focus keydown keyup mousedown mouseup selectionchange".split(" ")}},nb=null,he=null,Pb=null,ge=!1,ak={eventTypes:Eg,extractEvents:function(a,b,c,d,e,f){e=f||(d.window===d?d.document:9===d.nodeType?d:d.ownerDocument);if(!(f=!e)){a:{e=Jd(e);f=rd.onSelect;for(var g=0;g<f.length;g++)if(!e.has(f[g])){e=!1;break a}e=!0}f=!e}if(f)return null;e=b?Pa(b):window;switch(a){case "focus":if(yg(e)||"true"===e.contentEditable)nb=e,he=b,Pb=null;break;case "blur":Pb=he=nb=null;
break;case "mousedown":ge=!0;break;case "contextmenu":case "mouseup":case "dragend":return ge=!1,Dg(c,d);case "selectionchange":if(Zj)break;case "keydown":case "keyup":return Dg(c,d)}return null}},bk=R.extend({animationName:null,elapsedTime:null,pseudoElement:null}),ck=R.extend({clipboardData:function(a){return"clipboardData"in a?a.clipboardData:window.clipboardData}}),dk=dc.extend({relatedTarget:null}),ek={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",
Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},fk={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",
224:"Meta"},gk=dc.extend({key:function(a){if(a.key){var b=ek[a.key]||a.key;if("Unidentified"!==b)return b}return"keypress"===a.type?(a=Ac(a),13===a?"Enter":String.fromCharCode(a)):"keydown"===a.type||"keyup"===a.type?fk[a.keyCode]||"Unidentified":""},location:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,repeat:null,locale:null,getModifierState:fe,charCode:function(a){return"keypress"===a.type?Ac(a):0},keyCode:function(a){return"keydown"===a.type||"keyup"===a.type?a.keyCode:0},which:function(a){return"keypress"===
a.type?Ac(a):"keydown"===a.type||"keyup"===a.type?a.keyCode:0}}),hk=ec.extend({dataTransfer:null}),ik=dc.extend({touches:null,targetTouches:null,changedTouches:null,altKey:null,metaKey:null,ctrlKey:null,shiftKey:null,getModifierState:fe}),jk=R.extend({propertyName:null,elapsedTime:null,pseudoElement:null}),kk=ec.extend({deltaX:function(a){return"deltaX"in a?a.deltaX:"wheelDeltaX"in a?-a.wheelDeltaX:0},deltaY:function(a){return"deltaY"in a?a.deltaY:"wheelDeltaY"in a?-a.wheelDeltaY:"wheelDelta"in a?
-a.wheelDelta:0},deltaZ:null,deltaMode:null}),lk={eventTypes:dg,extractEvents:function(a,b,c,d,e){e=cg.get(a);if(!e)return null;switch(a){case "keypress":if(0===Ac(c))return null;case "keydown":case "keyup":a=gk;break;case "blur":case "focus":a=dk;break;case "click":if(2===c.button)return null;case "auxclick":case "dblclick":case "mousedown":case "mousemove":case "mouseup":case "mouseout":case "mouseover":case "contextmenu":a=ec;break;case "drag":case "dragend":case "dragenter":case "dragexit":case "dragleave":case "dragover":case "dragstart":case "drop":a=
hk;break;case "touchcancel":case "touchend":case "touchmove":case "touchstart":a=ik;break;case $h:case ai:case bi:a=bk;break;case ci:a=jk;break;case "scroll":a=dc;break;case "wheel":a=kk;break;case "copy":case "cut":case "paste":a=ck;break;case "gotpointercapture":case "lostpointercapture":case "pointercancel":case "pointerdown":case "pointermove":case "pointerout":case "pointerover":case "pointerup":a=hi;break;default:a=R}b=a.getPooled(e,b,c,d);lb(b);return b}};(function(a){if(ic)throw Error(k(101));
ic=Array.prototype.slice.call(a);nf()})("ResponderEventPlugin SimpleEventPlugin EnterLeaveEventPlugin ChangeEventPlugin SelectEventPlugin BeforeInputEventPlugin".split(" "));(function(a,b,c){td=a;rf=b;mf=c})(ae,Hb,Pa);pf({SimpleEventPlugin:lk,EnterLeaveEventPlugin:Yj,ChangeEventPlugin:Xj,SelectEventPlugin:ak,BeforeInputEventPlugin:Wj});var ie=[],ob=-1,Ca={},B={current:Ca},G={current:!1},Ra=Ca,bj=Pd,je=$f,Rg=Lj,aj=Nj,Dc=Oj,Ig=Zh,Jg=ag,Kg=Pj,Lg=Qj,Qg={},yj=Mj,Cj=void 0!==Yh?Yh:function(){},qa=null,
Ec=null,ke=!1,ii=ff(),Y=1E4>ii?ff:function(){return ff()-ii},Ic={current:null},Hc=null,qb=null,Gc=null,Tg=0,Jc=2,Ga=!1,Vb=da.ReactCurrentBatchConfig,$g=(new ea.Component).refs,Mc={isMounted:function(a){return(a=a._reactInternalFiber)?Na(a)===a:!1},enqueueSetState:function(a,b,c){a=a._reactInternalFiber;var d=ka(),e=Vb.suspense;d=Va(d,a,e);e=Ea(d,e);e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Fa(a,e);Ja(a,d)},enqueueReplaceState:function(a,b,c){a=a._reactInternalFiber;var d=ka(),e=Vb.suspense;
d=Va(d,a,e);e=Ea(d,e);e.tag=1;e.payload=b;void 0!==c&&null!==c&&(e.callback=c);Fa(a,e);Ja(a,d)},enqueueForceUpdate:function(a,b){a=a._reactInternalFiber;var c=ka(),d=Vb.suspense;c=Va(c,a,d);d=Ea(c,d);d.tag=Jc;void 0!==b&&null!==b&&(d.callback=b);Fa(a,d);Ja(a,c)}},Qc=Array.isArray,wb=ah(!0),Fe=ah(!1),Sb={},ja={current:Sb},Ub={current:Sb},Tb={current:Sb},D={current:0},Sc=da.ReactCurrentDispatcher,X=da.ReactCurrentBatchConfig,Ia=0,z=null,K=null,J=null,Uc=!1,Tc={readContext:W,useCallback:S,useContext:S,
useEffect:S,useImperativeHandle:S,useLayoutEffect:S,useMemo:S,useReducer:S,useRef:S,useState:S,useDebugValue:S,useResponder:S,useDeferredValue:S,useTransition:S},dj={readContext:W,useCallback:ih,useContext:W,useEffect:eh,useImperativeHandle:function(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;return ze(4,2,gh.bind(null,b,a),c)},useLayoutEffect:function(a,b){return ze(4,2,a,b)},useMemo:function(a,b){var c=ub();b=void 0===b?null:b;a=a();c.memoizedState=[a,b];return a},useReducer:function(a,b,c){var d=
ub();b=void 0!==c?c(b):b;d.memoizedState=d.baseState=b;a=d.queue={pending:null,dispatch:null,lastRenderedReducer:a,lastRenderedState:b};a=a.dispatch=ch.bind(null,z,a);return[d.memoizedState,a]},useRef:function(a){var b=ub();a={current:a};return b.memoizedState=a},useState:xe,useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=xe(a),d=c[0],e=c[1];eh(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=
xe(!1),c=b[0];b=b[1];return[ih(Ce.bind(null,b,a),[b,a]),c]}},ej={readContext:W,useCallback:Yc,useContext:W,useEffect:Xc,useImperativeHandle:hh,useLayoutEffect:fh,useMemo:jh,useReducer:Vc,useRef:dh,useState:function(a){return Vc(Ua)},useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=Vc(Ua),d=c[0],e=c[1];Xc(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=Vc(Ua),c=b[0];b=b[1];return[Yc(Ce.bind(null,
b,a),[b,a]),c]}},fj={readContext:W,useCallback:Yc,useContext:W,useEffect:Xc,useImperativeHandle:hh,useLayoutEffect:fh,useMemo:jh,useReducer:Wc,useRef:dh,useState:function(a){return Wc(Ua)},useDebugValue:Be,useResponder:ue,useDeferredValue:function(a,b){var c=Wc(Ua),d=c[0],e=c[1];Xc(function(){var c=X.suspense;X.suspense=void 0===b?null:b;try{e(a)}finally{X.suspense=c}},[a,b]);return d},useTransition:function(a){var b=Wc(Ua),c=b[0];b=b[1];return[Yc(Ce.bind(null,b,a),[b,a]),c]}},ra=null,Ka=null,Wa=
!1,gj=da.ReactCurrentOwner,ia=!1,Je={dehydrated:null,retryTime:0};var jj=function(a,b,c,d){for(c=b.child;null!==c;){if(5===c.tag||6===c.tag)a.appendChild(c.stateNode);else if(4!==c.tag&&null!==c.child){c.child.return=c;c=c.child;continue}if(c===b)break;for(;null===c.sibling;){if(null===c.return||c.return===b)return;c=c.return}c.sibling.return=c.return;c=c.sibling}};var wh=function(a){};var ij=function(a,b,c,d,e){var f=a.memoizedProps;if(f!==d){var g=b.stateNode;Ta(ja.current);a=null;switch(c){case "input":f=
Cd(g,f);d=Cd(g,d);a=[];break;case "option":f=Fd(g,f);d=Fd(g,d);a=[];break;case "select":f=M({},f,{value:void 0});d=M({},d,{value:void 0});a=[];break;case "textarea":f=Gd(g,f);d=Gd(g,d);a=[];break;default:"function"!==typeof f.onClick&&"function"===typeof d.onClick&&(g.onclick=uc)}Ud(c,d);var h,m;c=null;for(h in f)if(!d.hasOwnProperty(h)&&f.hasOwnProperty(h)&&null!=f[h])if("style"===h)for(m in g=f[h],g)g.hasOwnProperty(m)&&(c||(c={}),c[m]="");else"dangerouslySetInnerHTML"!==h&&"children"!==h&&"suppressContentEditableWarning"!==
h&&"suppressHydrationWarning"!==h&&"autoFocus"!==h&&(db.hasOwnProperty(h)?a||(a=[]):(a=a||[]).push(h,null));for(h in d){var k=d[h];g=null!=f?f[h]:void 0;if(d.hasOwnProperty(h)&&k!==g&&(null!=k||null!=g))if("style"===h)if(g){for(m in g)!g.hasOwnProperty(m)||k&&k.hasOwnProperty(m)||(c||(c={}),c[m]="");for(m in k)k.hasOwnProperty(m)&&g[m]!==k[m]&&(c||(c={}),c[m]=k[m])}else c||(a||(a=[]),a.push(h,c)),c=k;else"dangerouslySetInnerHTML"===h?(k=k?k.__html:void 0,g=g?g.__html:void 0,null!=k&&g!==k&&(a=a||
[]).push(h,k)):"children"===h?g===k||"string"!==typeof k&&"number"!==typeof k||(a=a||[]).push(h,""+k):"suppressContentEditableWarning"!==h&&"suppressHydrationWarning"!==h&&(db.hasOwnProperty(h)?(null!=k&&oa(e,h),a||g===k||(a=[])):(a=a||[]).push(h,k))}c&&(a=a||[]).push("style",c);e=a;if(b.updateQueue=e)b.effectTag|=4}};var kj=function(a,b,c,d){c!==d&&(b.effectTag|=4)};var pj="function"===typeof WeakSet?WeakSet:Set,wj="function"===typeof WeakMap?WeakMap:Map,sj=Math.ceil,gd=da.ReactCurrentDispatcher,
Uh=da.ReactCurrentOwner,H=0,Ye=8,ca=16,ma=32,Xa=0,hd=1,Oh=2,ad=3,bd=4,Xe=5,p=H,U=null,t=null,P=0,F=Xa,id=null,ta=1073741823,Yb=1073741823,kd=null,Xb=0,jd=!1,Re=0,Ph=500,l=null,cd=!1,Se=null,La=null,ld=!1,Zb=null,$b=90,bb=null,ac=0,af=null,dd=0,Ja=function(a,b){if(50<ac)throw ac=0,af=null,Error(k(185));a=ed(a,b);if(null!==a){var c=Cc();1073741823===b?(p&Ye)!==H&&(p&(ca|ma))===H?Te(a):(V(a),p===H&&ha()):V(a);(p&4)===H||98!==c&&99!==c||(null===bb?bb=new Map([[a,b]]):(c=bb.get(a),(void 0===c||c>b)&&bb.set(a,
b)))}};var zj=function(a,b,c){var d=b.expirationTime;if(null!==a){var e=b.pendingProps;if(a.memoizedProps!==e||G.current)ia=!0;else{if(d<c){ia=!1;switch(b.tag){case 3:sh(b);Ee();break;case 5:bh(b);if(b.mode&4&&1!==c&&e.hidden)return b.expirationTime=b.childExpirationTime=1,null;break;case 1:N(b.type)&&Bc(b);break;case 4:se(b,b.stateNode.containerInfo);break;case 10:d=b.memoizedProps.value;e=b.type._context;y(Ic,e._currentValue);e._currentValue=d;break;case 13:if(null!==b.memoizedState){d=b.child.childExpirationTime;
if(0!==d&&d>=c)return th(a,b,c);y(D,D.current&1);b=sa(a,b,c);return null!==b?b.sibling:null}y(D,D.current&1);break;case 19:d=b.childExpirationTime>=c;if(0!==(a.effectTag&64)){if(d)return vh(a,b,c);b.effectTag|=64}e=b.memoizedState;null!==e&&(e.rendering=null,e.tail=null);y(D,D.current);if(!d)return null}return sa(a,b,c)}ia=!1}}else ia=!1;b.expirationTime=0;switch(b.tag){case 2:d=b.type;null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;e=pb(b,B.current);rb(b,c);e=we(null,
b,d,a,e,c);b.effectTag|=1;if("object"===typeof e&&null!==e&&"function"===typeof e.render&&void 0===e.$$typeof){b.tag=1;b.memoizedState=null;b.updateQueue=null;if(N(d)){var f=!0;Bc(b)}else f=!1;b.memoizedState=null!==e.state&&void 0!==e.state?e.state:null;ne(b);var g=d.getDerivedStateFromProps;"function"===typeof g&&Lc(b,d,g,a);e.updater=Mc;b.stateNode=e;e._reactInternalFiber=b;pe(b,d,a,c);b=Ie(null,b,d,!0,f,c)}else b.tag=0,T(null,b,e,c),b=b.child;return b;case 16:a:{e=b.elementType;null!==a&&(a.alternate=
null,b.alternate=null,b.effectTag|=2);a=b.pendingProps;ri(e);if(1!==e._status)throw e._result;e=e._result;b.type=e;f=b.tag=Gj(e);a=aa(e,a);switch(f){case 0:b=He(null,b,e,a,c);break a;case 1:b=rh(null,b,e,a,c);break a;case 11:b=nh(null,b,e,a,c);break a;case 14:b=oh(null,b,e,aa(e.type,a),d,c);break a}throw Error(k(306,e,""));}return b;case 0:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),He(a,b,d,e,c);case 1:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),rh(a,b,d,e,c);
case 3:sh(b);d=b.updateQueue;if(null===a||null===d)throw Error(k(282));d=b.pendingProps;e=b.memoizedState;e=null!==e?e.element:null;oe(a,b);Qb(b,d,null,c);d=b.memoizedState.element;if(d===e)Ee(),b=sa(a,b,c);else{if(e=b.stateNode.hydrate)Ka=kb(b.stateNode.containerInfo.firstChild),ra=b,e=Wa=!0;if(e)for(c=Fe(b,null,d,c),b.child=c;c;)c.effectTag=c.effectTag&-3|1024,c=c.sibling;else T(a,b,d,c),Ee();b=b.child}return b;case 5:return bh(b),null===a&&De(b),d=b.type,e=b.pendingProps,f=null!==a?a.memoizedProps:
null,g=e.children,Yd(d,e)?g=null:null!==f&&Yd(d,f)&&(b.effectTag|=16),qh(a,b),b.mode&4&&1!==c&&e.hidden?(b.expirationTime=b.childExpirationTime=1,b=null):(T(a,b,g,c),b=b.child),b;case 6:return null===a&&De(b),null;case 13:return th(a,b,c);case 4:return se(b,b.stateNode.containerInfo),d=b.pendingProps,null===a?b.child=wb(b,null,d,c):T(a,b,d,c),b.child;case 11:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),nh(a,b,d,e,c);case 7:return T(a,b,b.pendingProps,c),b.child;case 8:return T(a,
b,b.pendingProps.children,c),b.child;case 12:return T(a,b,b.pendingProps.children,c),b.child;case 10:a:{d=b.type._context;e=b.pendingProps;g=b.memoizedProps;f=e.value;var h=b.type._context;y(Ic,h._currentValue);h._currentValue=f;if(null!==g)if(h=g.value,f=Qa(h,f)?0:("function"===typeof d._calculateChangedBits?d._calculateChangedBits(h,f):1073741823)|0,0===f){if(g.children===e.children&&!G.current){b=sa(a,b,c);break a}}else for(h=b.child,null!==h&&(h.return=b);null!==h;){var m=h.dependencies;if(null!==
m){g=h.child;for(var l=m.firstContext;null!==l;){if(l.context===d&&0!==(l.observedBits&f)){1===h.tag&&(l=Ea(c,null),l.tag=Jc,Fa(h,l));h.expirationTime<c&&(h.expirationTime=c);l=h.alternate;null!==l&&l.expirationTime<c&&(l.expirationTime=c);Sg(h.return,c);m.expirationTime<c&&(m.expirationTime=c);break}l=l.next}}else g=10===h.tag?h.type===b.type?null:h.child:h.child;if(null!==g)g.return=h;else for(g=h;null!==g;){if(g===b){g=null;break}h=g.sibling;if(null!==h){h.return=g.return;g=h;break}g=g.return}h=
g}T(a,b,e.children,c);b=b.child}return b;case 9:return e=b.type,f=b.pendingProps,d=f.children,rb(b,c),e=W(e,f.unstable_observedBits),d=d(e),b.effectTag|=1,T(a,b,d,c),b.child;case 14:return e=b.type,f=aa(e,b.pendingProps),f=aa(e.type,f),oh(a,b,e,f,d,c);case 15:return ph(a,b,b.type,b.pendingProps,d,c);case 17:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:aa(d,e),null!==a&&(a.alternate=null,b.alternate=null,b.effectTag|=2),b.tag=1,N(d)?(a=!0,Bc(b)):a=!1,rb(b,c),Yg(b,d,e),pe(b,d,e,c),Ie(null,
b,d,!0,a,c);case 19:return vh(a,b,c)}throw Error(k(156,b.tag));};var bf=null,Ne=null,la=function(a,b,c,d){return new Fj(a,b,c,d)};ef.prototype.render=function(a){md(a,this._internalRoot,null,null)};ef.prototype.unmount=function(){var a=this._internalRoot,b=a.containerInfo;md(null,a,null,function(){b[Lb]=null})};var Di=function(a){if(13===a.tag){var b=Fc(ka(),150,100);Ja(a,b);df(a,b)}};var Yf=function(a){13===a.tag&&(Ja(a,3),df(a,3))};var Bi=function(a){if(13===a.tag){var b=ka();b=Va(b,a,null);Ja(a,
b);df(a,b)}};sd=function(a,b,c){switch(b){case "input":Dd(a,c);b=c.name;if("radio"===c.type&&null!=b){for(c=a;c.parentNode;)c=c.parentNode;c=c.querySelectorAll("input[name="+JSON.stringify(""+b)+'][type="radio"]');for(b=0;b<c.length;b++){var d=c[b];if(d!==a&&d.form===a.form){var e=ae(d);if(!e)throw Error(k(90));Gf(d);Dd(d,e)}}}break;case "textarea":Lf(a,c);break;case "select":b=c.value,null!=b&&hb(a,!!c.multiple,b,!1)}};(function(a,b,c,d){ee=a;eg=b;vd=c;vf=d})(Qh,function(a,b,c,d,e){var f=p;p|=4;
try{return Da(98,a.bind(null,b,c,d,e))}finally{p=f,p===H&&ha()}},function(){(p&(1|ca|ma))===H&&(uj(),xb())},function(a,b){var c=p;p|=2;try{return a(b)}finally{p=c,p===H&&ha()}});var mk={Events:[Hb,Pa,ae,pf,qd,lb,function(a){Kd(a,Ki)},sf,tf,sc,pc,xb,{current:!1}]};(function(a){var b=a.findFiberByHostInstance;return Ej(M({},a,{overrideHookState:null,overrideProps:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:da.ReactCurrentDispatcher,findHostInstanceByFiber:function(a){a=Sf(a);
return null===a?null:a.stateNode},findFiberByHostInstance:function(a){return b?b(a):null},findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null}))})({findFiberByHostInstance:Bb,bundleType:0,version:"16.13.1",rendererPackageName:"react-dom"});I.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=mk;I.createPortal=Xh;I.findDOMNode=function(a){if(null==a)return null;if(1===a.nodeType)return a;var b=a._reactInternalFiber;if(void 0===
b){if("function"===typeof a.render)throw Error(k(188));throw Error(k(268,Object.keys(a)));}a=Sf(b);a=null===a?null:a.stateNode;return a};I.flushSync=function(a,b){if((p&(ca|ma))!==H)throw Error(k(187));var c=p;p|=1;try{return Da(99,a.bind(null,b))}finally{p=c,ha()}};I.hydrate=function(a,b,c){if(!bc(b))throw Error(k(200));return nd(null,a,b,!0,c)};I.render=function(a,b,c){if(!bc(b))throw Error(k(200));return nd(null,a,b,!1,c)};I.unmountComponentAtNode=function(a){if(!bc(a))throw Error(k(40));return a._reactRootContainer?
(Rh(function(){nd(null,null,a,!1,function(){a._reactRootContainer=null;a[Lb]=null})}),!0):!1};I.unstable_batchedUpdates=Qh;I.unstable_createPortal=function(a,b){return Xh(a,b,2<arguments.length&&void 0!==arguments[2]?arguments[2]:null)};I.unstable_renderSubtreeIntoContainer=function(a,b,c,d){if(!bc(c))throw Error(k(200));if(null==a||void 0===a._reactInternalFiber)throw Error(k(38));return nd(a,b,c,!1,d)};I.version="16.13.1"});
</script>
    <script>const e = React.createElement;

function pathToString(path) {
  if (path[0] === '/') {
    return '/' + path.slice(1).join('/');
  } else {
    return path.join('/');
  }
}

function findCommonPath(files) {
  if (!files || !files.length) {
    return [];
  }

  function isPrefix(arr, prefix) {
    if (arr.length < prefix.length) {
      return false;
    }
    for (let i = prefix.length - 1; i >= 0; --i) {
      if (arr[i] !== prefix[i]) {
        return false;
      }
    }
    return true;
  }

  let commonPath = files[0].path.slice(0, -1);
  while (commonPath.length) {
    if (files.every(file => isPrefix(file.path, commonPath))) {
      break;
    }
    commonPath.pop();
  }
  return commonPath;
}

function findFolders(files) {
  if (!files || !files.length) {
    return [];
  }

  let folders = files.filter(file => file.path.length > 1).map(file => file.path[0]);
  folders = [...new Set(folders)]; // unique
  folders.sort();

  folders = folders.map(folder => {
    let filesInFolder = files
      .filter(file => file.path[0] === folder)
      .map(file => ({
        ...file,
        path: file.path.slice(1),
        parent: [...file.parent, file.path[0]],
      }));

    const children = findFolders(filesInFolder); // recursion

    return {
      is_folder: true,
      path: [folder],
      parent: files[0].parent,
      children,
      covered: children.reduce((sum, file) => sum + file.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.coverable, 0),
      prevRun: {
        covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
        coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
      }
    };
  });

  return [
    ...folders,
    ...files.filter(file => file.path.length === 1),
  ];
}

class App extends React.Component {
  constructor(...args) {
    super(...args);

    this.state = {
      current: [],
    };
  }

  componentDidMount() {
    this.updateStateFromLocation();
    window.addEventListener("hashchange", () => this.updateStateFromLocation(), false);
  }

  updateStateFromLocation() {
    if (window.location.hash.length > 1) {
      const current = window.location.hash.substr(1).split('/');
      this.setState({current});
    } else {
      this.setState({current: []});
    }
  }

  getCurrentPath() {
    let file = this.props.root;
    let path = [file];
    for (let p of this.state.current) {
      file = file.children.find(file => file.path[0] === p);
      if (!file) {
        return path;
      }
      path.push(file);
    }
    return path;
  }

  render() {
    const path = this.getCurrentPath();
    const file = path[path.length - 1];

    let w = null;
    if (file.is_folder) {
      w = e(FilesList, {
        folder: file,
        onSelectFile: this.selectFile.bind(this),
        onBack: path.length > 1 ? this.back.bind(this) : null,
      });
    } else {
      w = e(DisplayFile, {
        file,
        onBack: this.back.bind(this),
      });
    }

    return e('div', {className: 'app'}, w);
  }

  selectFile(file) {
    this.setState(({current}) => {
      return {current: [...current, file.path[0]]};
    }, () => this.updateHash());
  }

  back(file) {
    this.setState(({current}) => {
      return {current: current.slice(0, current.length - 1)};
    }, () => this.updateHash());
  }

  updateHash() {
    if (!this.state.current || !this.state.current.length) {
      window.location = '#';
    } else {
      window.location = '#' + this.state.current.join('/');
    }
  }
}

function FilesList({folder, onSelectFile, onBack}) {
  let files = folder.children;
  return e('div', {className: 'display-folder'},
    e(FileHeader, {file: folder, onBack}),
    e('table', {className: 'files-list'},
      e('thead', {className: 'files-list__head'},
        e('tr', null,
          e('th', null, "Path"),
          e('th', null, "Coverage")
        )
      ),
      e('tbody', {className: 'files-list__body'},
        files.map(file => e(File, {file, onClick: onSelectFile}))
      )
    )
  );
}

function File({file, onClick}) {
  const coverage = file.coverable ? file.covered / file.coverable * 100 : -1;
  const coverageDelta = file.prevRun &&
    (file.covered / file.coverable * 100 - file.prevRun.covered / file.prevRun.coverable * 100);

  return e('tr', {
      className: 'files-list__file'
        + (coverage >= 0 && coverage < 50 ? ' files-list__file_low': '')
        + (coverage >= 50 && coverage < 80 ? ' files-list__file_medium': '')
        + (coverage >= 80 ? ' files-list__file_high': '')
        + (file.is_folder ? ' files-list__file_folder': ''),
      onClick: () => onClick(file),
    },
    e('td', null, e('a', null, pathToString(file.path))),
    e('td', null,
      file.covered + ' / ' + file.coverable +
      (coverage >= 0 ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e('span', {title: 'Change from the previous run'},
        (coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : ''))
    )
  );
}

function DisplayFile({file, onBack}) {
  return e('div', {className: 'display-file'},
    e(FileHeader, {file, onBack}),
    e(FileContent, {file})
  );
}

function FileHeader({file, onBack}) {
  const coverage = file.covered / file.coverable * 100;
  const coverageDelta = file.prevRun && (coverage - file.prevRun.covered / file.prevRun.coverable * 100);

  return e('div', {className: 'file-header'},
    onBack ? e('a', {className: 'file-header__back', onClick: onBack}, 'Back') : null,
    e('div', {className: 'file-header__name'}, pathToString([...file.parent, ...file.path])),
    e('div', {className: 'file-header__stat'},
      'Covered: ' + file.covered + ' of ' + file.coverable +
      (file.coverable ? ' (' + coverage.toFixed(2) + '%)' : ''),
      e('span', {title: 'Change from the previous run'},
        (coverageDelta ? ` (${coverageDelta > 0 ? '+' : ''}${coverageDelta.toFixed(2)}%)` : ''))
    )
  );
}

function FileContent({file}) {
  return e('pre', {className: 'file-content'},
    file.content.split(/\r?\n/).map((line, index) => {
      const trace = file.traces.find(trace => trace.line === index + 1);
      const covered = trace && trace.stats.Line;
      const uncovered = trace && !trace.stats.Line;
      return e('code', {
          className: 'code-line'
            + (covered ? ' code-line_covered' : '')
            + (uncovered ? ' code-line_uncovered' : ''),
          title: trace ? JSON.stringify(trace.stats, null, 2) : null,
        }, line);
    })
  );
}

(function(){
  const commonPath = findCommonPath(data.files);
  const prevFilesMap = new Map();

  previousData && previousData.files.forEach((file) => {
    const path = file.path.slice(commonPath.length).join('/');
    prevFilesMap.set(path, file);
  });

  const files = data.files.map((file) => {
    const path = file.path.slice(commonPath.length);
    const { covered = 0, coverable = 0 } = prevFilesMap.get(path.join('/')) || {};
    return {
      ...file,
      path,
      parent: commonPath,
      prevRun: { covered, coverable },
    };
  });

  const children = findFolders(files);

  const root = {
    is_folder: true,
    children,
    path: commonPath,
    parent: [],
    covered: children.reduce((sum, file) => sum + file.covered, 0),
    coverable: children.reduce((sum, file) => sum + file.coverable, 0),
    prevRun: {
      covered: children.reduce((sum, file) => sum + file.prevRun.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.prevRun.coverable, 0),
    }
  };

  ReactDOM.render(e(App, {root, prevFilesMap}), document.getElementById('root'));
}());
</script>
</body>
</html>